# 1 ç±»å‹è½¬æ¢

## åŸç”Ÿç±»å‹è½¬æ¢



## From\<T\> å’Œ Into\<T\>



## TryFrom\<T\> å’Œ TryInto\<T\>



## AsRef\<T\> å’Œ AsMut\<T\>



## FromStrã€ToString å’Œ Display



# 2 è¿­ä»£å™¨

## ç”¨è¿­ä»£å™¨å¤„ç†å…ƒç´ åºåˆ—

**è¿­ä»£å™¨**å¯ä»¥å¯¹å…ƒç´ åºåˆ—è¿›è¡Œå¤„ç†ï¼Œå®ƒè´Ÿè´£éå†åºåˆ—ä¸­çš„æ¯ä¸€é¡¹å¹¶å†³å®šä½•æ—¶ç»“æŸçš„é€»è¾‘ã€‚å½“ä½¿ç”¨è¿­ä»£å™¨æ—¶ï¼Œæ— éœ€é‡æ–°å®ç°è¿™äº›é€»è¾‘ã€‚

è¿­ä»£å™¨æ˜¯**æƒ°æ€§çš„**ï¼Œå³åœ¨è°ƒç”¨æ–¹æ³•ä½¿ç”¨è¿­ä»£å™¨ä¹‹å‰éƒ½ä¸ä¼šæœ‰æ•ˆæœï¼š

```rust
let v = vec![1, 2, 3, 4, 5];
let v_iter = v.iter();        // v_iter åœ¨å®é™…è°ƒç”¨ä¹‹ä¸Šçš„æ–¹æ³•å‰æ²¡æœ‰ä»»ä½•æ•ˆæœ
```

åˆ›å»ºè¿­ä»£å™¨åï¼Œå¯ä»¥ä½¿ç”¨ç”¨å¤šç§æ–¹å¼æ¥åˆ©ç”¨ï¼Œå¦‚ä½¿ç”¨ for å¾ªç¯æ¥éå†ï¼š

```rust
for i in v_iter {
    println!("{}", i);
}
```

å½“ä¸ä½¿ç”¨æ—¶è¿­ä»£å™¨æ¥è¿›è¡Œéå†æ—¶ï¼Œå¯èƒ½ä¼šéœ€è¦ä¸€ä¸ªç´¢å¼•æ¥è®°å½•ä½ç½®ï¼Œè¿˜éœ€è¦æ‹…å¿ƒå¯èƒ½è¶…å‡ºç´¢å¼•çš„ä½¿ç”¨ï¼Œä½†ä½¿ç”¨è¿­ä»£å™¨åˆ™æ²¡æœ‰è¿™ç§é¡¾è™‘ï¼Œæé«˜äº†çµæ´»æ€§ã€‚

## Iterator trait 

è¿­ä»£å™¨éƒ½å®ç°äº†æ ‡å‡†åº“ä¸­çš„ `Iterator` traitï¼š

```rust
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
    // --snip--
}
```

`type Item` å’Œ `Self::Item` å®šä¹‰äº† trait çš„**å…³è”ç±»å‹**ï¼Œè¿™ä¸ª `Item` ç±»å‹è¢«ç”¨ä½œ `next` æ–¹æ³•çš„è¿”å›å€¼ç±»å‹ï¼Œå³ `Item` ç±»å‹æ˜¯è¿­ä»£å™¨è¿”å›å…ƒç´ çš„ç±»å‹ã€‚

`next` æ˜¯ `Iterator` å®ç°è€…è¢«è¦æ±‚å®šä¹‰çš„å”¯ä¸€æ–¹æ³•ã€‚`next` æ¯æ¬¡è¿”å›è¿­ä»£å™¨ä¸­çš„ä¸€ä¸ªå…ƒç´ ï¼Œå¹¶å°è£…åœ¨ `Some` ä¸­ï¼Œå½“è¿­ä»£å™¨ç»“æŸæ—¶è¿”å› `None`ã€‚

å¯ä»¥ç›´æ¥è°ƒç”¨è¿­ä»£å™¨çš„ `next` æ–¹æ³•ï¼š

```rust
fn iterator_demonstration() {
    let v = vec![1, 2, 3];
    let mut v_iter = v1.iter();
    assert_eq!(v_iter.next(), Some(&1));
    assert_eq!(v_iter.next(), Some(&2));
    assert_eq!(v_iter.next(), Some(&3));
    assert_eq!(v_iter.next(), None);
}
```

`iter` æ–¹æ³•ç”Ÿæˆä¸€ä¸ªä¸å¯å˜å¼•ç”¨çš„è¿­ä»£å™¨ï¼Œå› æ­¤ä» `next` è°ƒç”¨ä¸­å¾—åˆ°çš„å€¼æ˜¯ vector çš„ä¸å¯å˜å¼•ç”¨ã€‚è€Œ `v_iter` éœ€è¦æ˜¯å¯å˜çš„ï¼Œå› ä¸ºåœ¨è¿­ä»£å™¨ä¸Šè°ƒç”¨ `next` æ–¹æ³•æ”¹å˜äº†è¿­ä»£å™¨ä¸­ç”¨æ¥è®°å½•åºåˆ—ä½ç½®çš„çŠ¶æ€ã€‚å³**æ¶ˆè€—**äº†è¿­ä»£å™¨ï¼Œæ¯ä¸€ä¸ª `next` è°ƒç”¨éƒ½ä¼šä»è¿­ä»£å™¨ä¸­æ¶ˆè€—ä¸€ä¸ªé¡¹ã€‚

>   -   ä½¿ç”¨ `for` å¾ªç¯æ—¶æ— éœ€ä½¿ `v_iter` å¯å˜ï¼Œå› ä¸º `for` å¾ªç¯ä¼šè·å– `v_iter` çš„æ‰€æœ‰æƒå¹¶ä½¿ `v_iter` å¯å˜ã€‚`for` å®é™…ä¸Šæ˜¯ä¸€ä¸ªè¯­æ³•ç³–ï¼Œå®ƒåœ¨å†…éƒ¨ä¸æ–­è°ƒç”¨ `next` è·å–å…ƒç´ ï¼›
>
>   | ç®€åŒ–å½¢å¼                      | ç­‰ä»·                                 | è®¿é—®çº§åˆ«   |
>   | ----------------------------- | ------------------------------------ | ---------- |
>   | `for item in collection`      | `for item in collection.into_iter()` | æ‹¥æœ‰æ‰€æœ‰æƒ |
>   | `for item in &collection`     | `for item in collection.iter()`      | åªè¯»       |
>   | `for item in &mut collection` | `for item in collection.iter_mut()`  | è¯» / å†™    |
>
>   -   åªæœ‰åœ¨ç±»å‹å…·æœ‰é›†åˆè¯­ä¹‰æ—¶ï¼Œæ‰æœ‰å¿…è¦å®ç° `Iterator` traitï¼Œå¦‚å¯¹å•å…ƒç±»å‹ `()` å®ç°æ˜¯æ— æ„ä¹‰çš„ã€‚

## IntoIterator trait

è‹¥ç±»å‹å®ç°äº† `IntoIterator` traitï¼Œå°±å¯ä»¥ä¸ºè¯¥ç±»å‹ç”Ÿæˆè¿­ä»£å™¨ï¼Œå³å¯ä»¥æŠŠè¯¥ç±»å‹è½¬æ¢ä¸ºè¿­ä»£å™¨ï¼Œä»è€Œèƒ½å¤Ÿè°ƒç”¨è¿­ä»£å™¨æ–¹æ³•ã€‚

ç”Ÿæˆè¿­ä»£å™¨çš„æ–¹æ³•æœ‰ä¸‰ç§ï¼š

-   `into_iter`ï¼šè·å–å…ƒç´ åºåˆ—çš„æ‰€æœ‰æƒå¹¶è¿”å›æ‹¥æœ‰æ‰€æœ‰æƒçš„è¿­ä»£å™¨ï¼›
-   `iter`ï¼šè¿”å›å…ƒç´ åºåˆ—çš„ä¸å¯å˜å¼•ç”¨çš„è¿­ä»£å™¨ï¼›
-   `iter_mut`ï¼šè¿”å›å…ƒç´ åºåˆ—çš„å¯å˜å¼•ç”¨çš„è¿­ä»£å™¨ã€‚

`Iterator` å’Œ `IntoIterator` trait çš„å…³ç³»ï¼š

-   å®ç°äº† `Iterator ` trait çš„å°±æ˜¯è¿­ä»£å™¨ï¼Œä¸éœ€è¦è½¬æ¢å³å¯ä½¿ç”¨è¿­ä»£å™¨æ–¹æ³•ï¼›
-   å®ç°äº† `IntoIterator` trait çš„å¯é€šè¿‡  `into_iter()` æ–¹æ³•è½¬æ¢ä¸ºè¿­ä»£å™¨ï¼›
-   è‹¥ç±»å‹ `T` å®ç°äº† `Iterator ` traitï¼Œé‚£ä¹ˆå°±ä¸èƒ½ä¸º `T` å†å®ç° `IntoIterator` traitï¼Œå› ä¸º `T` æœ¬èº«å°±æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼Œä¸éœ€è¦è½¬æ¢ï¼Œä½†å¯ä»¥ä¸º `&T` æˆ– `&mut T` å®ç° `IntoIterator` traitã€‚

## æ¶ˆè€—é€‚é…å™¨

`Iterator` trait æœ‰ä¸€ç³»åˆ—ç”±æ ‡å‡†åº“æä¾›é»˜è®¤å®ç°æ–¹æ³•ï¼Œä¸€äº›æ–¹æ³•åœ¨å…¶å®šä¹‰ä¸­è°ƒç”¨äº† `next` æ–¹æ³•ï¼Œè¿™ä¹Ÿæ˜¯è¦å®ç° `Iterator` trait åˆ™å¿…é¡»å®ç° `next` æ–¹æ³•çš„åŸå› ã€‚

è¿™äº›è°ƒç”¨ `next` çš„æ–¹æ³•è¢«ç§°ä¸º**æ¶ˆè€—é€‚é…å™¨**ï¼Œå› ä¸ºè°ƒç”¨å®ƒä»¬ä¼šæ¶ˆè€—è¿­ä»£å™¨ï¼Œå³ä¼šè·å–è¿­ä»£å™¨çš„æ‰€æœ‰æƒã€‚å¦‚ `Iterator` trait çš„é»˜è®¤å®ç°æ–¹æ³•ä¸­çš„ `sum` æ–¹æ³•ã€‚æ­¤æ–¹æ³•è·å–è¿­ä»£å™¨çš„æ‰€æœ‰æƒå¹¶åå¤è°ƒç”¨ `next` æ¥éå†è¿­ä»£å™¨ï¼Œæ¯éå†ä¸€ä¸ªé¡¹ï¼Œä¾¿ä¼šå°†å…¶åŠ åˆ°ä¸€ä¸ªæ€»å’Œå¹¶åœ¨è¿­ä»£ç»“æŸæ—¶è¿”å›æ€»å’Œã€‚

```rust
let v = vec![1, 2, 3, 4, 5];
let v_iter = v.iter();
let total: i32 = v_iter.sum();
v_iter;    // æ­¤å¤„ v_iter å·²å¤±æ•ˆ
```

è¿­ä»£å™¨æ–¹æ³• `fold`ï¼Œå®ƒæ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œä¸€ä¸ªåˆå§‹å€¼å’Œä¸€ä¸ªå¸¦æœ‰ä¸¤ä¸ªå‚æ•°çš„é—­åŒ…ï¼Œé—­åŒ…çš„ä¸¤ä¸ªå‚æ•°ä¸ºç´¯åŠ å™¨å’Œè¿­ä»£å™¨å…ƒç´ ï¼Œé—­åŒ…è¿”å›ç´¯åŠ å™¨åœ¨ä¸‹ä¸€æ¬¡è¿­ä»£ä¸­çš„å€¼ï¼Œæœ€åè¯¥æ–¹æ³•è¿”å›ç´¯åŠ å™¨çš„å€¼ã€‚

```rust
let v = vec![1, 2, 3, 4, 5];
let add_sum = v.iter().fold(0, |acc, x| acc + x);
let mul_sum = v.iter().fold(1, |acc, x| acc * x);
println!("add_sum = {}, mul_sum = {}", add_sum, mul_sum);
```

ä½¿ç”¨ `fold` æ–¹æ³•å¯ä»¥æ–¹ä¾¿åœ°è®¡ç®—ç´¯åŠ å’Œä¸å…ƒç´ ä¹˜ç§¯ã€‚ä¸å…¶ç›¸ä¼¼çš„è¿˜æœ‰ `reduce` æ–¹æ³•ï¼Œä½†åªæ¥å—ä¸€ä¸ªé—­åŒ…å‚æ•°ï¼Œå¹¶æŠŠè¿­ä»£å™¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä½œä¸ºåˆå§‹å€¼ï¼Œè¿”å›ä¸€ä¸ª `Option<T>`ï¼Œå½“è¿­ä»£å™¨ä¸ºç©ºæ—¶ï¼Œè¿”å› `None`ã€‚

```rust
let v: Vec<i32> = vec![];
assert_eq!(None, v.into_iter().reduce(|acc, x| acc + x));
```

ä½¿ç”¨ `for_each` æ–¹æ³•å¯ä»¥ç«‹å³å¯¹æ¯ä¸ªå…ƒç´ è¿›è¡Œæ“ä½œï¼Œä¸”ä¸è¿”å›å€¼ã€‚

```rust
let mut m = [0; 10];
m.iter_mut().for_each(|x| *x += 1);
```

## è¿­ä»£é€‚é…å™¨

`Iterator` trait ä¸­å®šä¹‰äº†å¦ä¸€ç±»æ–¹æ³•ï¼Œç§°ä¸º**è¿­ä»£å™¨é€‚é…å™¨**ï¼Œå¯ä»¥å°†å½“å‰è¿­ä»£å™¨è½¬æ¢ä¸ºä¸åŒç±»å‹çš„è¿­ä»£å™¨ã€‚å¯ä»¥é“¾å¼è°ƒç”¨å¤šä¸ªè¿­ä»£å™¨é€‚é…å™¨ï¼Œä½†å› ä¸ºæ‰€æœ‰çš„è¿­ä»£å™¨éƒ½æ˜¯æƒ°æ€§çš„ï¼Œéœ€è¦è°ƒç”¨ä¸€ä¸ªæ¶ˆè€—é€‚é…å™¨æ–¹æ³•ä»¥è·å–è¿­ä»£å™¨é€‚é…å™¨è°ƒç”¨çš„ç»“æœã€‚

`zip` å°†è¿­ä»£å™¨å’Œå¦ä¸€ä¸ªè¿­ä»£å™¨ç»„åˆä¸ºä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå…ƒç»„ï¼Œå…ƒç»„çš„ç¬¬ä¸€ä¸ªé¡¹æ¥è‡ªç¬¬ä¸€ä¸ªè¿­ä»£å™¨ï¼Œç¬¬äºŒä¸ªé¡¹æ¥è‡ªç¬¬äºŒä¸ªè¿­ä»£å™¨ã€‚

```rust
let v1 = vec![1, 2, 3];
let v2 = vec![2, 3, 4];
let v3: Vec<_> = v1.iter().zip(v2.iter()).collect();
assert_eq!(vec![(&1, &2), (&2, &3), (&3, &4)], v3);
```

---

`map` æ˜¯ä¸€ä¸ªå…¸å‹çš„è¿­ä»£å™¨é€‚é…å™¨ï¼Œå®ƒæ¥å—ä¸€ä¸ªé—­åŒ…ä½œä¸ºå‚æ•°ï¼Œä½¿ç”¨é—­åŒ…æ¥è°ƒç”¨æ¯ä¸ªå…ƒç´ ä»¥ç”Ÿæˆæ–°çš„è¿­ä»£å™¨ã€‚

```rust
let v = vec![1, 2, 3, 4, 5];
let v_add_one = v.iter().map(|x| x + 1);  // å¾—åˆ°ä¸€ä¸ªè­¦å‘Š
```

è¿™é‡Œçš„é—­åŒ…åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ï¼Œå¯¹ vector ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½åŠ ä¸€ï¼Œä½†æ˜¯ç”±äºæ²¡æœ‰è°ƒç”¨ä»»ä½•æ¶ˆè€—é€‚é…å™¨ï¼Œå› æ­¤å®ƒå®é™…ä»€ä¹ˆä¹Ÿä¸åšï¼Œå› æ­¤ä¼šå¾—åˆ°ä¸€ä¸ªè­¦å‘Šã€‚

å¯ä»¥è°ƒç”¨ `collect` æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šæ¶ˆè€—è¿­ä»£å™¨å¹¶å°†ç»“æœæ‰“åŒ…åˆ°ä¸€ä¸ªé›†åˆä¸­ï¼š

```rust
let v_add_one: Vec<_> = v.iter().map(|x| x + 1).collect();
```

ç”±äº `collect` æ–¹æ³•å¯ä»¥æ‰“åŒ…ä¸ºä»»æ„ç±»å‹ï¼Œå› æ­¤éœ€è¦æ˜¾å¼æ ‡æ³¨é›†åˆçš„ç±»å‹ï¼Œä½†é›†åˆé‡Œé¢çš„å…ƒç´ ç±»å‹å¯ä»¥æ¨æ–­å‡ºæ¥ã€‚

---

`filter` æ¥å—ä¸€ä¸ªè¿”å›å€¼ä¸º `bool` çš„é—­åŒ…ä½œä¸ºå‚æ•°ï¼Œè·å–è¿­ä»£å™¨çš„æ¯ä¸ªå…ƒç´ ä½œç”¨äºé—­åŒ…ã€‚è‹¥é—­åŒ…è¿”å› `true`ï¼Œåˆ™è¯¥å…ƒç´ å°†ä¼šåŒ…å«åœ¨ `filter` åˆ›å»ºçš„æ–°è¿­ä»£å™¨ä¸­ï¼Œå¦åˆ™ä»è¿­ä»£å™¨ä¸­è¿‡æ»¤æ‰è¯¥å…ƒç´ ã€‚

```rust
let v = 1..100;
let v_filter: Vec<_> = v.filter(|x| x % 3 == 0).collect();
```

`v` æ˜¯ä¸€ä¸ª 1 åˆ° 99 çš„å…ƒç´ åºåˆ—ï¼ŒåŒæ ·ä¹Ÿæ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼Œç±»å‹æ˜¯ `Range<i32>`ï¼Œ`filter` è·å–è¿­ä»£å™¨çš„æ¯ä¸€ä¸ªå…ƒç´ ï¼Œç„¶åå°†ä¸º 3 çš„å€æ•°çš„å…ƒç´ æ”¾å…¥æ–°çš„è¿­ä»£å™¨ã€‚

`filter_map` æ¥å—ä¸€ä¸ªè¿”å›å€¼ä¸º `Option<T>` çš„é—­åŒ…ï¼Œå¹¶è¿‡æ»¤æ‰å€¼ä¸º `None` çš„å…ƒç´ ã€‚è¿™å¯ä»¥åŒæ—¶è¿‡æ»¤å’Œäº§ç”Ÿæ–°çš„è¿­ä»£å™¨ï¼Œå¯ä½¿ `filter` å’Œ `map` çš„é“¾æ›´åŠ ç®€æ´ã€‚

```rust
let v = ["1", "2", "three", "4", "zero"];

// ä¸¤ä¸ªä½œç”¨ç›¸åŒ
let result: Vec<_> = v.iter()
    .filter_map(|e| e.parse::<i32>().ok())
    .collect();
let result2: Vec<_> = v.iter()
    .map(|e| e.parse::<i32>())
    .filter(|e| e.is_ok())
    .map(|e| e.unwrap())
    .collect();

assert_eq!(result, vec![1, 2, 4]);
assert_eq!(result, result2);
```

---

è¿­ä»£å™¨æ–¹æ³• `flatten` å’Œ `flat_map` å¯ä»¥åˆ›å»ºä¸€ä¸ªæ‰å¹³åŒ–åµŒå¥—ç»“æ„çš„è¿­ä»£å™¨ï¼Œä½†åè€…è¿˜ä¼šåƒ `map` ä¸€æ ·åœ¨åˆ›å»ºæ—¶å¯¹å…ƒç´ è¿›è¡Œé¢å¤–çš„æ“ä½œã€‚

```rust
let words = ["alpha", "beta", "gamma"];

// ä¸¤ä¸ªä½œç”¨ç›¸åŒ
let merged: String = words.iter()
    .flat_map(|s| s.chars())
    .collect();
let merged2: String = words.iter()
    .map(|s| s.chars())
    .flatten()
    .collect();

assert_eq!(merged, "alphabetagamma");
assert_eq!(merged, merged2);
```

æ­¤å¤–è¿˜æœ‰æ¯”è¾ƒå¸¸ç”¨çš„ `take`ã€`take_while`ã€`skip` ç­‰è¿­ä»£å™¨é€‚é…å™¨ã€‚

## è‡ªå®šä¹‰è¿­ä»£å™¨

å¯ä»¥é€šè¿‡åœ¨ vector ä¸Šè°ƒç”¨ `into_iter`ã€`iter` æˆ– `iter_mut` æ¥åˆ›å»ºä¸€ä¸ªè¿­ä»£å™¨ï¼Œä¹Ÿå¯ä»¥ç”¨æ ‡å‡†åº“ä¸­å…¶ä»–çš„é›†åˆç±»å‹åˆ›å»ºè¿­ä»£å™¨ï¼Œå¦‚å“ˆå¸Œ mapï¼Œä½†è¿˜å¯ä»¥å®ç° `Iterator` trait æ¥è‡ªå®šä¹‰è¿­ä»£å™¨ã€‚

è‡ªå®šä¹‰è¿­ä»£å™¨å”¯ä¸€è¦æ±‚å°±æ˜¯å®ç° `next` æ–¹æ³•ï¼Œå®šä¹‰åå°±å¯ä»¥ä½¿ç”¨æ‰€æœ‰å…¶ä»–ç”± `Iterator` trait ä¸­æ‹¥æœ‰é»˜è®¤å®ç°çš„æ–¹æ³•ã€‚

è®¾æœ‰ä¸€ä¸ªåªä¼šä» 1 æ•°åˆ° 5 çš„è¿­ä»£å™¨ï¼Œé¦–å…ˆåˆ›å»ºä¸€ä¸ªç»“æ„ä½“æ¥å­˜æ”¾å€¼ï¼Œå¹¶å®šä¹‰ `new` æ¥è¿”å›ä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ï¼š

```rust
struct Counter {
    count: i32,
}

impl Counter {
    fn new() -> Self {
        Self { count: 0 }
    }
}
```

ç„¶ååœ¨ `Counter` ç»“æ„ä½“ä¸Šå®ç° `Iterator` traitï¼š

```rust
impl Iterator for Counter {
    type Item = i32;
    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
```

å°†è¿­ä»£å™¨çš„å…³è”ç±»å‹ `Item` è®¾ç½®ä¸º `i32`ï¼Œè¡¨ç¤ºè¿­ä»£å™¨ä¼šè¿”å› `i32` å€¼é›†åˆã€‚è‹¥ `count` å€¼å°äº 5ï¼Œ`next` ä¼šè¿”å›å°è£…åœ¨ `Some` ä¸­çš„å½“å‰å€¼ï¼Œå¦åˆ™è¿”å› `None`ã€‚

### ä½¿ç”¨ next æ–¹æ³•

ä¸€æ—¦å®ç°äº† `Iterator` traitï¼Œå°±æœ‰äº†ä¸€ä¸ªè¿­ä»£å™¨ï¼Œå¯ä»¥ç›´æ¥è°ƒç”¨ `next` æ–¹æ³•ï¼š

```rust
let mut counter = Counter::new();
assert_eq!(counter.next(), Some(1));
assert_eq!(counter.next(), Some(2));
assert_eq!(counter.next(), Some(3));
assert_eq!(counter.next(), Some(4));
assert_eq!(counter.next(), Some(5));
assert_eq!(counter.next(), None);
```

è°ƒç”¨ `next` æ–¹æ³•ï¼Œä¼šæ”¹å˜è¿­ä»£å™¨å†…éƒ¨çš„çŠ¶æ€ï¼Œå› æ­¤è¦å°†è¿­ä»£å™¨å£°æ˜ä¸º `mut`ã€‚

### è¿”å›è¿­ä»£å™¨

å¯¹å®ç°äº† `Iterator` trait çš„ç±»å‹è€Œè¨€ï¼Œè¿”å›ä¸€ä¸ª `Self` å°±ç›¸å½“äºè¿”å›ä¸€ä¸ª `impl Iterator`ï¼Œå› æ­¤ `Counter` çš„ `new` å‡½æ•°ä¹Ÿå¯ä»¥å†™ä¸ºå¦‚ä¸‹å½¢å¼ã€‚

```rust
fn new() -> impl Iterator<Item = i32> {
    Self { count: 0 }
}
```

### ç»“åˆè¿­ä»£å™¨æ–¹æ³•

é€šè¿‡å®šä¹‰ `next` æ–¹æ³•å®ç° `Iterator` traitï¼Œå°±å¯ä»¥ä½¿ç”¨æ ‡å‡†åº“å®šä¹‰çš„æ‹¥æœ‰é»˜è®¤å®ç°çš„ `Iterator` trait æ–¹æ³•äº†ã€‚

è¿™é‡Œç»“åˆ `zip`ã€`map` å’Œ `filter` è¿™ä¸‰ä¸ªè¿­ä»£å™¨é€‚é…å™¨ã€‚è®¾ä¸€ä¸ª `Counter` é€šè¿‡ `zip` æ–¹æ³•ä¸å¦ä¸€ä¸ª `Counter` ç»„åˆï¼Œç„¶åä¼ é€’ç»™ `map` æ–¹æ³•ä½¿ä¸¤ä¸ªè¿­ä»£å™¨çš„å…ƒç´ ç›¸ä¹˜ï¼Œæœ€åä½¿ç”¨ `filter` æ–¹æ³•åªä¿ç•™ç»“æœä¸º 3 çš„å€æ•°çš„å…ƒç´ ï¼Œç„¶åè°ƒç”¨ `sum` æ–¹æ³•è®¡ç®—è¿™ä¸ªæ–°ç”Ÿæˆçš„è¿­ä»£å™¨çš„å„å…ƒç´ ä¹‹å’Œã€‚

```rust
let counter = Counter::new();
let result: i32 = counter
    .zip(Counter::new().skip(1))
    .map(|(a, b)| a * b)
    .filter(|x| x % 3 == 0)
    .sum();
assert_eq!(18, result);
```

`skip` æ–¹æ³•åˆ›å»ºä¸€ä¸ªå¿½ç•¥å‰ N ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ã€‚`zip` åªäº§ç”Ÿå››å¯¹å€¼ï¼Œç†è®ºä¸Šç¬¬äº”å¯¹å€¼ `(5, None)` ä»æœªè¢«äº§ç”Ÿï¼Œå› ä¸º `zip` åœ¨ä»»ä¸€è¾“å…¥çš„è¿­ä»£å™¨è¿”å› `None` æ—¶ä¹Ÿè¿”å› `None`ã€‚ç”±äº `zip` è¿”å›ä¸€ä¸ªå…ƒç»„ï¼Œ`map` æ–¹æ³•çš„é—­åŒ…åˆ©ç”¨æ¨¡å¼åŒ¹é…äº†ä¸¤ä¸ªå€¼ï¼Œå¹¶å°†å®ƒä»¬ç›¸ä¹˜ã€‚

# 3 é›†åˆ

Rust æ ‡å‡†åº“ä¸­æœ‰ä¸€ç³»åˆ—è¢«ç§°ä¸º**é›†åˆ**çš„æ•°æ®ç»“æ„ã€‚ä¸€èˆ¬çš„æ•°æ®ç±»å‹éƒ½ä»£è¡¨ä¸€ä¸ªç‰¹å®šçš„å€¼ï¼Œä½†é›†åˆå¯ä»¥åŒ…å«å¤šä¸ªå€¼ã€‚ä¸åŒäºå†…å»ºçš„æ•°ç»„å’Œå…ƒç»„ç±»å‹ï¼Œè¿™äº›é›†åˆæŒ‡å‘çš„æ•°æ®æ˜¯å‚¨å­˜åœ¨å †ä¸Šçš„ï¼Œå…¶æ•°æ®çš„æ•°é‡ä¸å¿…åœ¨ç¼–è¯‘æ—¶å°±å·²çŸ¥ï¼Œä¸”å¯ä»¥éšç€ç¨‹åºçš„è¿è¡ŒåŠ¨æ€å¢é•¿æˆ–ç¼©å°ã€‚

æ ‡å‡†åº“ `std::collections` ä¸­å«æœ‰æœ€å¸¸è§çš„é€šç”¨æ•°æ®ç»“æ„ï¼Œåˆ†ä¸ºå››å¤§ç±»ï¼š

-   Sequencesï¼š`Vec`ã€`VecDeque`ã€`LinkedList`
-   Mapsï¼š`HashMap`ã€`BTreeMap`
-   Setsï¼š`HashSet`ã€`BTreeSet`
-   Miscï¼š`BinaryHeap`

å…¶ä¸­å¹¿æ³›ä½¿ç”¨çš„ä¸‰ç§é›†åˆï¼š

-   vector å…è®¸é¡ºåºåœ°å‚¨å­˜æ•°é‡å¯å˜çš„å€¼ï¼›
-   å­—ç¬¦ä¸²æ˜¯å­—ç¬¦çš„é›†åˆï¼›
-   HashMap å…è®¸å°†å€¼ä¸ä¸€ä¸ªç‰¹å®šçš„é”®ç›¸å…³è”ã€‚

## vector

vector å…è®¸åœ¨ä¸€ä¸ªå•ç‹¬çš„æ•°æ®ç»“æ„ä¸­å‚¨å­˜å¤šäºä¸€ä¸ªçš„å€¼ï¼Œå®ƒä»¬åœ¨å†…å­˜ä¸­ç›¸é‚»åœ°æ’åˆ—ï¼Œä¸”ç±»å‹ç›¸åŒã€‚

### åˆ›å»º

ä½¿ç”¨ `new` å‡½æ•°æ¥åˆ›å»ºé•¿åº¦ä¸º 0 çš„ vectorã€‚

```rust
// ç”±äºæ²¡æœ‰åˆå§‹åŒ–ï¼Œéœ€è¦ç±»å‹æ³¨è§£
let v: Vec<i32> = Vec::new();
```

å¯ä»¥ä½¿ç”¨å®æ¥åˆ›å»ºå¹¶åˆå§‹åŒ– `Vec`ï¼Œå› ä¸ºæœ‰äº†åˆå§‹å€¼ï¼Œæ‰€ä»¥å¯ä»¥æ¨æ–­å‡ºç±»å‹ã€‚

```rust
let v1 = vec![1, 2, 3];
let v2 = vec![0; 5];
```

vector åœ¨å…¶ç¦»å¼€ä½œç”¨åŸŸæ—¶ä¼šè¢«é‡Šæ”¾ï¼Œå¹¶ä¸¢å¼ƒæ‰€æœ‰å…ƒç´ ï¼š

```rust
{
    let v = vec![1, 2, 3];
}   // v è¢«ä¸¢å¼ƒ
```

### è¯»å–

ä½¿ç”¨ç´¢å¼•æˆ–è€… `get` æ–¹æ³•è¯»å– vector çš„å€¼ï¼š

```rust
let mut v = vec![1, 2, 3];
let v2 = &v[1];
match v.get(1) {
    Some(i) => println!("{i}"),
    None => println!("None")
}
```

æœ‰ä¸¤ç§è¯»å–æ–¹å¼çš„åŸå› æ˜¯ï¼Œå½“å°è¯•è·å–è¶…è¿‡ç´¢å¼•èŒƒå›´çš„å€¼æ—¶å¤„ç†ä¸åŒï¼š

```rust
let v = vec![1, 2, 3];
let e1 = &v[10];
let e2 = v.get(10);
```

å¯¹äº `[]` æ–¹æ³•ï¼Œå½“å¼•ç”¨ä¸€ä¸ªä¸å­˜åœ¨çš„å…ƒç´ æ—¶ Rust ä¼šé€ æˆ panicã€‚è€Œ `get` æ–¹æ³•è¿”å›ä¸€ä¸ª `Option<T>`ï¼Œå½“è¢«ä¼ é€’äº†ä¸€ä¸ªæ•°ç»„å¤–çš„ç´¢å¼•æ—¶ï¼Œå®ƒä¸ä¼š panic è€Œæ˜¯è¿”å› `None`ã€‚

---

ä½¿ç”¨ `for` æ¥éå† vector ä¸­æ¯ä¸€ä¸ªå…ƒç´ ï¼š

```rust
let mut v = vec![1, 2, 3];
for i in &v {
    println!("{i}");
}

// éå†æ—¶ä¿®æ”¹
for i in &mut v {
    *i += 1;
    println!("{i}");
}
```

è‹¥åœ¨éå†æ—¶æ²¡æœ‰ä½¿ç”¨ vector çš„å¼•ç”¨ï¼Œé‚£ä¹ˆå°±ä¼šå‘ç”Ÿç§»åŠ¨ï¼Œæ­¤åä¸èƒ½å†ä½¿ç”¨è¯¥ vectorã€‚

```rust
for i in v {}
// v è¢«ç§»åŠ¨ï¼Œæ­¤å¤„ä¸èƒ½ä½¿ç”¨
```

---

vector ä¹Ÿæ˜¯å¯ä»¥ slice çš„ï¼Œä½¿ç”¨ `&` æˆ– `as_slice` æ–¹æ³•è·å¾—ä¸€ä¸ª sliceï¼š

```rust
let v = vec![1, 2, 3, 4, 5];
let s = &v[..3];
let s2 = v.as_slice();
```

### æ›´æ–°

å¯ä»¥é€šè¿‡ç´¢å¼•æ¥ä¿®æ”¹å€¼ï¼š

```rust
v[0] = 10;
```

---

`push` æ–¹æ³•å¢åŠ å…ƒç´ ï¼Œç”±äºå¯å˜ï¼Œå› æ­¤éœ€è¦ä½¿ç”¨ `mut`ï¼š

```rust
let mut v = Vec::new();
v.push(1);
v.push(2);
```

`insert` æ–¹æ³•ä»æŒ‡å®šç´¢å¼•æ’å…¥ä¸€ä¸ªå…ƒç´ ï¼Œè‹¥è¶…å‡ºç´¢å¼•ï¼Œåˆ™å‘ç”Ÿ panicï¼š

```rust
let mut v = vec![1, 2, 3];
v.insert(1, 4);
assert_eq!(v, [1, 4, 2, 3]);
vec.insert(4, 5);
assert_eq!(v, [1, 4, 2, 3, 5]);
```

---

`pop` æ–¹æ³•åˆ é™¤å¹¶è¿”å›æœ€åä¸€ä¸ªå…ƒç´ ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ª `Option<T>`ï¼Œä»¥ä¾¿èƒ½å¤Ÿå¤„ç†ä¸ºç©ºçš„æƒ…å†µï¼š

```rust
let mut v = vec![1, 2, 3];
let e: Option<i32> = v.pop();
```

`remove` æ–¹æ³•åˆ é™¤å¹¶è¿”å›æŒ‡å®šç´¢å¼•çš„å…ƒç´ ï¼Œå‰©ä¸‹çš„å…ƒç´ ä¾æ¬¡å‘å‰ç§»åŠ¨ï¼Œè‹¥è¶…å‡ºç´¢å¼•ï¼Œåˆ™å‘ç”Ÿ panicï¼š

```rust
let mut v = vec![1, 2, 3];
assert_eq!(v.remove(1), 2);
assert_eq!(v, [1, 3]);
```

ç”±äº `remove` æ–¹æ³•ä¼šç§»åŠ¨å…ƒç´ ï¼Œå› æ­¤ä¼šå½±å“æ•ˆç‡ï¼Œè‹¥ä¸å…³å¿ƒå…ƒç´ çš„é¡ºåºï¼Œå¯ä»¥ä½¿ç”¨ `swap_remove` æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¼šæŠŠæœ€åä¸€ä¸ªå…ƒç´ ç§»åŠ¨åˆ°è¢«åˆ é™¤çš„ä½ç½®ä¸Šï¼š

```rust
let mut v = vec![1, 2, 3, 4];
assert_eq!(v.swap_remove(1), 2);
assert_eq!(v, [1, 4, 3]);
```

`dedup` æ–¹æ³•åˆ é™¤**è¿ç»­é‡å¤**çš„å…ƒç´ ï¼Œå¦‚æœå·²ç»æ’å¥½åºï¼Œåˆ™ä¼šåˆ é™¤æ‰€æœ‰é‡å¤çš„å…ƒç´ ï¼š

```rust
let mut v = vec![1, 2, 2, 3, 3, 2, 4, 2, 5, 5];
v.dedup();
assert_eq!(v, [1, 2, 3, 2, 4, 2, 5]);
```

`clear` æ–¹æ³•æ¸…ç©ºæ‰€æœ‰å…ƒç´ ï¼Œ`is_empty` åˆ¤æ–­æ˜¯å¦ä¸ºç©ºï¼Œæ¸…ç©ºå³å°†é•¿åº¦å˜ä¸º 0ï¼Œä½†å®¹é‡ä¾ç„¶å­˜åœ¨ï¼š

```rust
let mut v = vec![0; 5];
v.clear();
assert!(v.is_empty());
```

---

`split_off` æ–¹æ³•ä»æŒ‡å®šç´¢å¼•å¤„å°† vector åˆ†å‰²æˆä¸¤ä¸ª vectorï¼Œè‹¥è¶…å‡ºç´¢å¼•ï¼Œåˆ™å‘ç”Ÿ panicï¼š

```rust
let mut v = vec![1, 2, 3];
let v2 = v.split_off(1);
assert_eq!(v, [1]);
assert_eq!(v2, [2, 3]);
```

### é‡æ–°åˆ†é…

vector æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªåŒ…å«æŒ‡é’ˆã€é•¿åº¦å’Œå®¹é‡çš„å˜é‡ï¼Œä¸”ä¿è¯è¯¥æŒ‡é’ˆæŒ‡å‘çš„å€¼æ˜¯æœ‰æ•ˆçš„ã€‚

![vector æ„æˆ](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202203270427221.png)

é•¿åº¦æŒ‡å®é™…çš„å…ƒç´ æ•°é‡ï¼Œå®¹é‡ä¸ºå®é™…åˆ†é…çš„å†…å­˜å¤§å°ï¼Œå…¶ä¸­ `uninit` è¡¨ç¤ºæœªè¢«åˆå§‹åŒ–çš„å†…å­˜ã€‚è‹¥é•¿åº¦è¶…è¿‡äº†å®¹é‡ï¼Œé‚£ä¹ˆå®¹é‡ä¼šè‡ªåŠ¨å¢åŠ ï¼Œä½†å› ä¸º vector ä¿è¯å…ƒç´ æ˜¯åœ¨å†…å­˜ä¸­è¿ç»­åˆ†é…çš„ï¼Œè‹¥åœ¨å½“å‰ä½ç½®è¿›è¡Œå¢åŠ ä½†æ— æ³•æ»¡è¶³è¿™ä¸ªè¦æ±‚ï¼Œåˆ™ä¼šåœ¨å †ä¸Šé‡æ–°å¯»æ‰¾ç©ºé—´ï¼Œå¹¶æŠŠæ•°æ®æ‹·è´è¿‡å»ï¼Œè¿™ç§°ä¸º**é‡æ–°åˆ†é…**ã€‚è¿™æ—¶è‹¥æœ‰ä¸€ä¸ªè¯¥ vector å¼•ç”¨ï¼Œä½†é‡æ–°åˆ†é…åï¼Œè¯¥ vector å·²ç»ä¸åœ¨åŸæ¥çš„ä½ç½®ä¸Šï¼Œç›¸å½“äºæŒ‡å‘äº†è¢«é‡Šæ”¾çš„å†…å­˜ï¼Œè¿™è¿åäº†å¼•ç”¨æ€»æ˜¯æœ‰æ•ˆçš„åŸåˆ™ï¼Œäºæ˜¯ç¼–è¯‘å™¨ä¼šæŠ¥é”™ã€‚

```rust
let mut v = vec![1, 2, 3];
let e = &v[0];
v.push(4);     // é”™è¯¯ï¼Œä¸èƒ½åœ¨ç›¸åŒä½œç”¨åŸŸä¸­åŒæ—¶å­˜åœ¨å¯å˜å’Œä¸å¯å˜å¼•ç”¨
```

å½“å‘ç”Ÿäº†é‡æ–°åˆ†é…çš„æƒ…å†µï¼Œç”±äºéœ€è¦åœ¨å †ä¸­é‡æ–°åˆ†é…å†…å­˜å¹¶è¿›è¡Œæ‹·è´æ“ä½œï¼Œå› æ­¤ä¼šå½±å“æ•ˆç‡ï¼Œè‹¥èƒ½ç¡®å®š vector å¯èƒ½çš„å¤§å°ï¼Œå¯ä»¥ä½¿ç”¨ `Vec::with_capacity` æ¥æŒ‡å®šé¢„æœŸå¤§å°ï¼Œè¿˜å¯ä½¿ç”¨ `as_ptr`ã€`len` å’Œ `capacity` æ–¹æ³•æ¥è·å– vector çš„æŒ‡é’ˆã€é•¿åº¦å’Œå®¹é‡ã€‚æ­¤å¤–ï¼Œå¯ä»¥ä½¿ç”¨ `shrink_to_fit` æ–¹æ³•å‡å°å®¹é‡ä»¥åŒ¹é…å½“å‰é•¿åº¦ã€‚

```rust
let mut v = Vec::with_capacity(10);
assert_eq!(v.len(), 0);
assert_eq!(v.capacity(), 10);
println!("{:?}", v.as_ptr());
for i in 0..10 {
    v.push(i);
}
assert_eq!(v.len(), 10);
assert_eq!(v.capacity(), 10);
```

### å­˜å‚¨æšä¸¾

vector åªèƒ½å‚¨å­˜ç›¸åŒç±»å‹çš„å€¼ï¼Œå½“éœ€è¦åœ¨ vector ä¸­å‚¨å­˜ä¸åŒç±»å‹å€¼æ—¶ï¼Œå¯ä»¥ä½¿ç”¨æšä¸¾ï¼Œå› ä¸ºæšä¸¾å€¼è¢«è®¤ä¸ºæ˜¯åŒä¸€ä¸ªç±»å‹ã€‚

```rust
enum ShoesSize {
    Cm(f64),
    Eur(i32)
}

let sizes = vec![
    ShoesSize::Cm(27.5),
    ShoesSize:Eur(43)
];
```

## å­—ç¬¦ä¸²

Rust åªæœ‰ä¸€ç§å­—ç¬¦ä¸²ç±»å‹ï¼š`&str`ï¼Œå³å­—ç¬¦ä¸² sliceï¼Œå®ƒæ˜¯ä¸€äº›å‚¨å­˜åœ¨åˆ«å¤„çš„ UTF-8 ç¼–ç å­—ç¬¦ä¸²æ•°æ®çš„å¼•ç”¨ã€‚

`String` ç±»å‹æ˜¯ç”±æ ‡å‡†åº“æä¾›çš„ï¼Œå®ƒæ˜¯å¯å¢é•¿çš„ã€å¯å˜çš„ã€æœ‰æ‰€æœ‰æƒçš„ã€UTF-8 ç¼–ç çš„å­—ç¬¦ä¸²ç±»å‹ï¼Œæ˜¯ `Vec<u8>` çš„å°è£…ï¼Œå› æ­¤å’Œ vector ç›¸åŒï¼Œç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼šæŒ‡é’ˆã€é•¿åº¦å’Œå®¹é‡ï¼Œä¹Ÿå…·æœ‰ vector çš„æ€§è´¨ï¼Œå¦‚æ·»åŠ å…ƒç´ æ—¶ï¼Œä¹Ÿå¯èƒ½ä¼šé‡æ–°åˆ†é…ã€‚

### åˆ›å»º

æœ‰å¤šç§æ–¹æ³•åˆ›å»º Stringï¼š

-   `to_string` æ–¹æ³•å°† `&str` è½¬æ¢æˆ `String`ï¼›
-   `new` å‡½æ•°åˆ›å»ºç©º Stringï¼›
-   `from` å‡½æ•°åˆ›å»ºæŒ‡å®š Stringï¼›
-   `from_utf8` å‡½æ•°åˆ›å»ºæ¥è‡ª UTF-8 å­—èŠ‚ vector çš„ Stringï¼›
-   `with_capacity` å‡½æ•°åˆ›å»ºæŒ‡å®šå®¹é‡å¤§å°ä¸”é•¿åº¦ä¸º 0 çš„å­—ç¬¦ä¸²ï¼›

```rust
let s = "hello".to_string();
let s = String::new();
let s = String::from("hello");
// "ğŸ˜…" çš„ UTF-8 ç¼–ç ä¸º 0xf0, 0x9f, 0x98, 0x85
let s = String::from_utf8(vec![0xf0, 0x9f, 0x98, 0x85]).unwrap();
let s = String::with_capacity(10);
```

`from_utf8` å‡½æ•°ä¼šè¿”å›ä¸€ä¸ª `Result`ï¼Œç”¨äºæ£€æŸ¥ç»™å®šçš„ UTF-8 å­—èŠ‚æ˜¯å¦æœ‰æ•ˆã€‚

```rust
let s = String::from_utf8(vec![0xf0, 0x9f, 0x18, 0x85]);
let s = match s {
    Ok(s) => s,
    Err(_) => "vaild utf-8 code".to_string(),
};
```

å¯ä»¥ä½¿ç”¨ `from_utf8_lossy` åˆ›å»ºæ¥è‡ª UTF-8 å­—èŠ‚ vector çš„ Stringï¼Œä¸”åŒ…æ‹¬æ— æ•ˆå­—èŠ‚ã€‚

```rust
let s = b"Hello \xF0\x90\x80World";
let s = String::from_utf8_lossy(s);
assert_eq!("Hello ï¿½World", s);
```

åŒç†ï¼Œ`from_utf16` å’Œ `from_utf16_lossy` å‡½æ•°åˆ™åˆ›å»ºæ¥è‡ª UTF-16 å­—èŠ‚ vector çš„ Stringã€‚

### è¯»å–

åœ¨ Rust ä¸­ï¼Œä½¿ç”¨ç´¢å¼•è¯­æ³•è®¿é—® `String` çš„ä¸€éƒ¨åˆ†ï¼Œä¼šå‡ºç°ä¸€ä¸ªé”™è¯¯ã€‚

```rust
let s1 = String::from("hello");
let h = s1[0];	// é”™è¯¯
```

åœ¨ Rust ä¸­ï¼Œ`String` æ˜¯ä¸€ä¸ª `Vec<u8>` çš„å°è£…ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨ `as_ptr`ã€`len` å’Œ `capacity` æ–¹æ³•æ¥æŸ¥çœ‹æŒ‡é’ˆã€é•¿åº¦å’Œå®¹é‡ï¼š

```rust
let s = String::from("Hola");
println!("{:?}", s.as_ptr());
assert_eq!(s.len(), 4);
assert_eq!(s.capacity(), 4);
```

å­—ç¬¦ä¸² `Hola` çš„é•¿åº¦å’Œå®¹é‡éƒ½æ˜¯ 4ï¼Œè¯¥å­—ç¬¦ä¸²æ¯ä¸€ä¸ªå­—æ¯çš„ UTF-8 ç¼–ç éƒ½å ç”¨ä¸€ä¸ªå­—èŠ‚ã€‚

```rust
let s = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ");
assert_eq!(s.len(), 24);
```

è¿™é‡Œçš„é•¿åº¦æ˜¯ 24ï¼Œè¿™æ˜¯ä½¿ç”¨ UTF-8 ç¼–ç  `Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ` æ‰€éœ€è¦çš„å­—èŠ‚æ•°ï¼Œè¯¥å­—ç¬¦ä¸²æ¯ä¸€ä¸ªå­—æ¯çš„ UTF-8 ç¼–ç éƒ½å ç”¨ä¸¤ä¸ªå­—èŠ‚ã€‚

å­—ç¬¦ä¸²ä¸æ”¯æŒç´¢å¼•ï¼Œå› ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²å­—èŠ‚å€¼çš„ç´¢å¼•å¹¶ä¸æ€»æ˜¯å¯¹åº”ä¸€ä¸ªæœ‰æ•ˆçš„ Unicode æ ‡é‡å€¼ã€‚

```rust
let s = "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ";
let c = &s[0];  // é”™è¯¯
```

å½“ä½¿ç”¨ UTF-8 ç¼–ç æ—¶ï¼Œ`Ğ—` çš„ç¬¬ä¸€ä¸ªå­—èŠ‚ `208`ï¼Œç¬¬äºŒä¸ªæ˜¯ `151`ï¼Œæ‰€ä»¥ `c` çš„å€¼ä¸º `208`ï¼Œä½† `208` è‡ªèº«å¹¶ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„å­—æ¯ã€‚ä¸ºäº†é¿å…è¿”å›æ„å¤–çš„å€¼å¹¶é€ æˆä¸èƒ½ç«‹åˆ»å‘ç°çš„ bugï¼Œç¼–è¯‘å™¨ä¼šç›´æ¥æŠ¥é”™ã€‚

---

Rust ä¸­ï¼Œæœ‰ä¸‰ç§ç›¸å…³æ–¹å¼çš„å­—ç¬¦ä¸²ç†è§£ï¼š**å­—èŠ‚**ã€**æ ‡é‡å€¼**å’Œ**å­—å½¢ç°‡**ã€‚

```
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]
```

è¿™äº›æ˜¯ç”¨æ¢µæ–‡ä¹¦å†™çš„å°åº¦è¯­å•è¯ `à¤¨à¤®à¤¸à¥à¤¤à¥‡` å‚¨å­˜åœ¨ vector ä¸­çš„ `u8` å€¼ã€‚

è¿™é‡Œæœ‰ 18 ä¸ªå­—èŠ‚ï¼Œæ˜¯è®¡ç®—æœºæœ€ç»ˆä¼šå‚¨å­˜çš„æ•°æ®ã€‚è‹¥ä» Unicode æ ‡é‡å€¼çš„è§’åº¦ç†è§£ï¼Œå³ Rust çš„ `char` ç±»å‹ï¼Œåˆ™ä¸ºå¦‚ä¸‹å­—ç¬¦ï¼š

```text
['à¤¨', 'à¤®', 'à¤¸', 'à¥', 'à¤¤', 'à¥‡']
```

è¿™é‡Œæœ‰å…­ä¸ª `char`ï¼Œä¸è¿‡ç¬¬å››ä¸ªå’Œç¬¬å…­ä¸ªéƒ½ä¸æ˜¯å­—æ¯ï¼Œå®ƒä»¬æ˜¯å‘éŸ³ç¬¦å·ï¼Œæœ¬èº«å¹¶æ²¡æœ‰ä»»ä½•æ„ä¹‰ï¼Œéœ€è¦å’Œå…¶å®ƒå­—æ¯ç»„åˆèµ·æ¥æ‰èƒ½å½¢æˆä¸€ä¸ªå®Œæ•´çš„å­—æ¯ï¼Œä¹Ÿå°±æ˜¯å­—å½¢ç°‡ã€‚å¦‚æœä»¥å­—å½¢ç°‡çš„è§’åº¦ç†è§£ï¼Œå°±ä¼šå¾—åˆ°æ„æˆè¿™ä¸ªå•è¯çš„å››ä¸ªå­—æ¯ï¼š

```text
["à¤¨", "à¤®", "à¤¸à¥", "à¤¤à¥‡"]
```

Rust ä¸å…è®¸ä½¿ç”¨ç´¢å¼•è·å– `String` å­—ç¬¦çš„å¦ä¸€ä¸ªåŸå› æ˜¯ï¼Œç´¢å¼•æ“ä½œé¢„æœŸæ€»æ˜¯éœ€è¦å¸¸æ•°æ—¶é—´ O(1)ï¼Œä½†æ˜¯å¯¹äº `String` å¿…é¡»ä»å¼€å¤´åˆ°ç´¢å¼•ä½ç½®éå†æ¥ç¡®å®šæœ‰å¤šå°‘æœ‰æ•ˆçš„å­—ç¬¦ï¼Œå› æ­¤ä¸èƒ½ä¿è¯æ€§èƒ½ã€‚

#### ç´¢å¼•å­—ç¬¦ä¸² slice

å¯¹äº `&str` ç±»å‹å¯ä»¥ä½¿ç”¨ç´¢å¼•ï¼Œä½†æ˜¯è¿”å›çš„ç±»å‹æ˜¯ä¸æ˜ç¡®çš„ï¼šå­—èŠ‚å€¼ã€å­—ç¬¦ã€å­—å½¢ç°‡æˆ–å­—ç¬¦ä¸² sliceã€‚å¯ä»¥ä½¿ç”¨ `[]` å’Œä¸€ä¸ª range æ¥åˆ›å»ºå«ç‰¹å®šå­—èŠ‚çš„å­—ç¬¦ä¸² sliceã€‚

```rust
let s = "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ";
let s1 = String::from("ä½ å¥½");
let s = &s[..4];
let s1 = &s[3..];
```

è¿™é‡Œï¼Œ`s` ä¼šæ˜¯ä¸€ä¸ª `&str`ï¼Œå®ƒåŒ…å«å­—ç¬¦ä¸²çš„å¤´å››ä¸ªå­—èŠ‚ï¼Œå³ `s` å°†ä¼šæ˜¯ `Ğ—Ğ´`ï¼Œä½†è·å– `&s[0..1]` æ—¶ï¼ŒRust ä¼šåœ¨è¿è¡Œæ—¶ panicï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªæ— æ•ˆçš„å­—ç¬¦ã€‚

è¿˜å¯ä»¥ç”¨ `get` æ–¹æ³•æ¥è·å–å€¼ï¼Œé€šè¿‡ä¼ é€’ä¸€ä¸ª rangeï¼Œè¿”å›ä¸€ä¸ª `Option`ï¼Œç”¨äºæ£€æµ‹å€¼æ˜¯å¦å­˜åœ¨ï¼š

```rust
let s = String::from("ä½ å¥½");
assert_eq!(Some("å¥½"), s.get(3..6));
```

### éå†

è·å–å•ç‹¬çš„ Unicode æ ‡é‡å€¼ï¼Œæ— è®ºæ˜¯ `&str` è¿˜æ˜¯ `String`ï¼Œéƒ½å¯ä»¥ä½¿ç”¨ `chars` æ–¹æ³•ã€‚å¯¹ `à¤¨à¤®à¤¸à¥à¤¤à¥‡` è°ƒç”¨ `chars` æ–¹æ³•ä¼šå°†å…¶åˆ†å¼€å¹¶è¿”å›å…­ä¸ª `char` ç±»å‹çš„å€¼ï¼Œæ¥ç€å°±å¯ä»¥éå†å…¶ç»“æœæ¥è®¿é—®æ¯ä¸€ä¸ªå…ƒç´ ã€‚

```rust
for c in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".chars() {
    println!("{}", c);
}
```

`bytes` æ–¹æ³•è¿”å›ä¸€ä¸ª Bytes ç±»å‹çš„å­—ç¬¦ä¸² slice è¿­ä»£å™¨ã€‚

```rust
for b in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".bytes() {
    println!("{}", b);
}
```

>   ä»å­—ç¬¦ä¸²ä¸­è·å–å­—å½¢ç°‡æ˜¯å¾ˆå¤æ‚çš„ï¼Œæ‰€ä»¥æ ‡å‡†åº“å¹¶æ²¡æœ‰æä¾›è¿™ä¸ªåŠŸèƒ½ã€‚

### æ›´æ–°

`String` çš„å†…å®¹å¯ä»¥æ”¹å˜ã€‚ä½¿ç”¨ `+` æˆ– `format!` å®æ¥æ‹¼æ¥ `String` å€¼ã€‚

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2;   // s1 è¢«ç§»åŠ¨äº†ï¼Œä¸èƒ½ç»§ç»­ä½¿ç”¨
```

`s1` åœ¨ç›¸åŠ åä¸å†æœ‰æ•ˆçš„åŸå› ï¼Œå’Œä½¿ç”¨ `s2` çš„å¼•ç”¨çš„åŸå› ï¼Œä¸ä½¿ç”¨ `+` è¿ç®—ç¬¦æ—¶è°ƒç”¨çš„å‡½æ•°ç­¾åæœ‰å…³ã€‚

`+` è¿ç®—ç¬¦ä½¿ç”¨äº† `add` å‡½æ•°ï¼Œå…¶å‡½æ•°ç­¾åç±»ä¼¼ï¼š

```rust
fn add(self, s: &str) -> String {
```

è¿™å¹¶ä¸æ˜¯æ ‡å‡†åº“ä¸­å®é™…çš„ç­¾åï¼Œæ ‡å‡†åº“ä¸­çš„ `add` ä½¿ç”¨æ³›å‹å®šä¹‰ã€‚è¿™é‡Œ `add` çš„ç­¾åä½¿ç”¨å…·ä½“ç±»å‹ä»£æ›¿äº†æ³›å‹ã€‚

é¦–å…ˆï¼Œ`s2` ä½¿ç”¨äº† `&`ï¼Œä½¿ç”¨ç¬¬äºŒä¸ªå­—ç¬¦ä¸²çš„**å¼•ç”¨**ä¸ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ç›¸åŠ ã€‚è¿™æ˜¯å› ä¸º `add` å‡½æ•°çš„ `s` å‚æ•°ï¼šåªèƒ½å°† `&str` å’Œ `String` ç›¸åŠ ï¼Œä¸èƒ½å°†ä¸¤ä¸ª `String` ç›¸åŠ ã€‚

èƒ½å¤Ÿåœ¨ `add` è°ƒç”¨ä¸­ä½¿ç”¨ `&s2` æ˜¯å› ä¸º `&String` å¯ä»¥è¢«**å¼ºè½¬**æˆ `&str`ã€‚å½“ `add` å‡½æ•°è¢«è°ƒç”¨æ—¶ï¼ŒRust ä½¿ç”¨äº† **Deref å¼ºåˆ¶è½¬æ¢**ï¼Œå³æŠŠ `&s2` å˜æˆäº† `&s2[..]`ã€‚å› ä¸º `add` æ²¡æœ‰è·å–å‚æ•°çš„æ‰€æœ‰æƒï¼Œæ‰€ä»¥ `s2` åœ¨è¿™ä¸ªæ“ä½œåä»ç„¶æ˜¯æœ‰æ•ˆçš„ `String`ã€‚

å…¶æ¬¡ï¼Œ`add` è·å–äº† `self` çš„æ‰€æœ‰æƒï¼Œå› ä¸º `self` **æ²¡æœ‰**ä½¿ç”¨ `&`ã€‚`s1` çš„æ‰€æœ‰æƒå°†è¢«ç§»åŠ¨åˆ° `add` è°ƒç”¨ä¸­ï¼Œä¹‹åå°±ä¸å†æœ‰æ•ˆã€‚è™½ç„¶çœ‹èµ·æ¥åƒå¤åˆ¶ä¸¤ä¸ªå­—ç¬¦ä¸²å¹¶åˆ›å»ºä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ï¼Œè€Œå®é™…ä¸Šè¿™ä¸ªè¯­å¥ä¼šè·å– `s1` çš„æ‰€æœ‰æƒï¼Œé™„åŠ ä¸Šä» `s2` ä¸­æ‹·è´çš„å†…å®¹ï¼Œå¹¶è¿”å›ç»“æœçš„æ‰€æœ‰æƒï¼Œè¿™ä¸ªå®ç°æ¯”æ‹·è´è¦æ›´é«˜æ•ˆã€‚

çº§è”å¤šä¸ªå­—ç¬¦ä¸²ï¼Œ`+` çš„è¡Œä¸ºå°±ååˆ†ç¹çï¼š

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");
let s = s1 + "-" + &s2 + "-" + &s3;
```

å¯¹æ­¤å¯ä»¥ä½¿ç”¨ `format!` å®ï¼š

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");
let s = format!("{}-{}-{}", s1, s2, s3);
```

`format!` ä¸ `println!` çš„å·¥ä½œåŸç†ç›¸åŒï¼Œä¸è¿‡å®ƒä¸æŠŠè¾“å‡ºæ‰“å°åˆ°å±å¹•ä¸Šï¼Œè€Œæ˜¯è¿”å›ä¸€ä¸ªå¸¦æœ‰ç»“æœå†…å®¹çš„ `String`ï¼Œä¸”ä¸ä¼šè·å–ä»»ä½•å‚æ•°çš„æ‰€æœ‰æƒã€‚

---

`push` æ–¹æ³•é™„åŠ å•ç‹¬çš„å­—ç¬¦ï¼š

```rust
let mut s = String::from("lo");
s.push('l');
```

`push_str` æ–¹æ³•é™„åŠ å­—ç¬¦ä¸² sliceï¼š

```rust
let mut s = String::from("foo");
s.push_str("bar");
```

`insert` æ–¹æ³•ä»æŒ‡å®šä½ç½®æ’å…¥ä¸€ä¸ªå­—ç¬¦ï¼Œè‹¥è¯¥ä½ç½®ä¸åœ¨ UTF-8 è¾¹ç•Œæˆ–è¶…å‡ºèŒƒå›´ï¼Œåˆ™å‘ç”Ÿ panicï¼š

```rust
let mut s = String::from("ä½ å¥½");
s.insert(0, '0');
s.insert(4, '4');
s.insert(8, '8');
assert_eq!("0ä½ 4å¥½8", s);
```

`insert_str` æ–¹æ³•ä»æŒ‡å®šä½ç½®æ’å…¥å­—ç¬¦ä¸² sliceï¼Œè‹¥è¯¥ä½ç½®ä¸åœ¨ UTF-8 è¾¹ç•Œæˆ–è¶…å‡ºèŒƒå›´ï¼Œåˆ™å‘ç”Ÿ panicï¼š

```rust
let mut s = String::from("ä½ å¥½");
s.insert_str(0, "å“ˆå“ˆï¼Œ");
s.insert_str(15, "ï¼Œå†è§");
assert_eq!("å“ˆå“ˆï¼Œä½ å¥½ï¼Œå†è§", s);
```

---

`pop` æ–¹æ³•åˆ é™¤æœ€åä¸€ä¸ªå­—ç¬¦å¹¶è¿”å›è¯¥å­—ç¬¦ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ª `Option`ï¼š

```rust
let mut s = String::from("foo");
assert_eq!(s.pop(), Some('o'));
assert_eq!(s, "fo");
```

`remove` æ–¹æ³•åˆ é™¤æŒ‡å®šä½ç½®çš„å­—ç¬¦å¹¶è¿”å›å®ƒï¼Œè‹¥è¯¥ä½ç½®ä¸åœ¨ UTF-8 è¾¹ç•Œæˆ–è¶…å‡ºèŒƒå›´ï¼Œåˆ™å‘ç”Ÿ panicï¼š

```rust
let mut s = String::from("ä½ å¥½");
assert_eq!(s.remove(0), 'ä½ ');
assert_eq!(s.remove(0), 'å¥½');

let mut s = String::from("ä½ å¥½");
assert_eq!(s.remove(3), 'å¥½');
```

`clear` æ–¹æ³•æ¸…ç©ºå­—ç¬¦ä¸²ï¼Œ`is_empty` æ–¹æ³•åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦ä¸ºç©ºï¼Œæ¸…ç©ºå³å°†é•¿åº¦å˜ä¸º 0ï¼Œä½†å®¹é‡ä¾ç„¶å­˜åœ¨ï¼š

```rust
let mut s = String::from("foo");
s.clear();
assert!(s.is_empty());
```

---

`split_off` æ–¹æ³•ä»æŒ‡å®šä½ç½®å°†åŸå­—ç¬¦ä¸²åˆ†å‰²æˆä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œè‹¥è¯¥ä½ç½®ä¸åœ¨ UTF-8 è¾¹ç•Œæˆ–è¶…å‡ºèŒƒå›´ï¼Œåˆ™å‘ç”Ÿ panicï¼š

```rust
let mut s = String::from("ä½ å¥½ï¼Œä¸–ç•Œ");
let s2 = s.split_off(6);
assert_eq!(s, "ä½ å¥½");
assert_eq!(s2, "ï¼Œä¸–ç•Œ");
```

`replace` æ–¹æ³•ç”¨å¦ä¸€ä¸ªå­—ç¬¦ä¸²æ›¿æ¢åŒ¹é…é¡¹ï¼ŒåŒ¹é…é¡¹å¯ä»¥æ˜¯æ¨¡å¼ï¼Œè‹¥ä¸åŒ¹é…ï¼Œåˆ™ä¸æ›¿æ¢ï¼š

```rust
let s = "this is old";
assert_eq!("this is new", s.replace("old", "new"));
```

`replacen` æ–¹æ³•ç”¨å¦ä¸€ä¸ªå­—ç¬¦ä¸²æ›¿æ¢å‰ N ä¸ªåŒ¹é…é¡¹ï¼ŒåŒ¹é…é¡¹å¯ä»¥æ˜¯æ¨¡å¼ï¼Œè‹¥ä¸åŒ¹é…ï¼Œåˆ™ä¸æ›¿æ¢ï¼š

```rust
let s = "foo foo 123 foo";
assert_eq!("new new 123 foo", s.replacen("foo", "new", 2));
assert_eq!("foo foo new23 foo", s.replacen(char::is_numeric, "new", 1));
```

### å…¶ä»–æ“ä½œ

`into_bytes` æ–¹æ³•å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º `Vec<u8>`ï¼Œä¸”ä¼šè·å–æ‰€æœ‰æƒï¼Œå› æ­¤ä½¿ç”¨ååŸ String ä¸å¯ç”¨ï¼š

```rust
let s = String::from("hello");
let bytes = s.into_bytes();
assert_eq!(&[104, 101, 108, 108, 111][..], &bytes[..]);
s;    // s åœ¨æ­¤å¤„ä¸å¯ç”¨
```

`as_bytes` æ–¹æ³•å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º `&[u8] `ï¼š

```rust
let s = String::from("hello");
assert_eq!(&[104, 101, 108, 108, 111], s.as_bytes());
```

`as_str` æ–¹æ³•å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå­—ç¬¦ä¸² sliceï¼š

```rust
let s = String::from("foo");
assert_eq!("foo", s.as_str());
```

---

`to_lowercase` å’Œ `to_uppercase` æ–¹æ³•åˆ†åˆ«è¿”å›å­—ç¬¦ä¸²çš„å°å†™å’Œå¤§å†™å½¢å¼ï¼Œæ²¡æœ‰å¤§å°å†™çš„å­—ç¬¦ä¸ä¼šæ”¹å˜ï¼š

```rust
let s = "HELLO";
let s2 = "world";
assert_eq!("hello", s.to_lowercase());
assert_eq!("WORLD", s2.to_uppercase());

let s = "å“ˆå“ˆ";
assert_eq!(s, s.to_lowercase());
```

---

`repeat` æ–¹æ³•é‡å¤å­—ç¬¦ä¸² N æ¬¡å¹¶å°†å…¶è¿”å›ï¼Œå½“è¶…å‡º usize::MAX æ—¶ï¼Œåˆ™å‘ç”Ÿ panicï¼š

```rust
assert_eq!("abc".repeat(4), String::from("abcabcabcabc"));
```

---

`parse` æ–¹æ³•å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå¦ä¸€ç§æŒ‡å®šçš„ç±»å‹ï¼Œå¹¶è¿”å›ä¸€ä¸ª `Result`ï¼Œç”¨äºæ£€æŸ¥æ˜¯å¦æˆåŠŸè½¬æ¢ï¼š

```rust
let four = "4".parse::<u32>();
match four {
    Ok(i) => println!("{}", i),
    Err(_) => println!("Not a number"),
}
```

---

`trim`ã€`trim_start` å’Œ `trim_end` æ–¹æ³•åˆ†åˆ«è¿”å›åˆ é™¤äº†ä¸¤ç«¯ã€å¼€å¤´å’Œç»“å°¾ä½ç½®çš„ç©ºç™½å­—ç¬¦çš„å­—ç¬¦ä¸²ï¼š

```rust
let s = "\tHello\tworld\t";
assert_eq!("Hello\tworld", s.trim());
assert_eq!("Hello\tworld\t", s.trim_start());
assert_eq!("\tHello\tworld", s.trim_end());
```

---

`find` æ–¹æ³•è¿”å›æ¨¡å¼åŒ¹é…çš„ç¬¬ä¸€ä¸ªå­—ç¬¦çš„ç´¢å¼•çš„ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ª `Option`ï¼Œç”¨äºæ£€æŸ¥æ˜¯å¦åŒ¹é…æˆåŠŸï¼š

```rust
let s = "ä½ å¥½ï¼Œä¸–ç•Œï¼Œhello world";
assert_eq!(s.find('ä½ '), Some(0));
assert_eq!(s.find('ï¼Œ'), Some(6));
assert_eq!(s.find(char::is_lowercase), Some(18));
assert_eq!(s.find("å“ˆå“ˆ"), None);
```

---

`split` æ–¹æ³•è¿”å›ä¸€ä¸ªç”±æŒ‡å®šæ¨¡å¼åŒ¹é…åˆ†å‰²çš„å­—ç¬¦ä¸²çš„ slice è¿­ä»£å™¨ã€‚

```rust
let iter = "Mary had a little lamb".split(' ');
assert_eq!(iter.collect::<Vec<&str>>(), ["Mary", "had", "a", "little", "lamb"]);
```

`split_whitespace` æ–¹æ³•è¿”å›ä¸€ä¸ªç”±ç©ºç™½ç¬¦åˆ†å‰²çš„å­—ç¬¦ä¸² slice è¿­ä»£å™¨ã€‚

```rust
let iter = "A few words".split_whitespace();
assert_eq!(iter.collect::<Vec<&str>>(), ["A", "few", "words"]);
```

## å“ˆå¸Œ map

`HashMap` ç±»å‹å‚¨å­˜äº†ä¸€ä¸ªé”®ç±»å‹ `K` å¯¹åº”ä¸€ä¸ªå€¼ç±»å‹ `V` çš„æ˜ å°„ã€‚å®ƒé€šè¿‡ **Hash å‡½æ•°**æ¥å®ç°æ˜ å°„ï¼Œå†³å®šå¦‚ä½•å°†é”®å’Œå€¼æ”¾å…¥å†…å­˜ä¸­ã€‚å¯ä»¥ç”¨äºéœ€è¦ä»»ä½•ç±»å‹ä½œä¸ºé”®æ¥å¯»æ‰¾æ•°æ®çš„æƒ…å†µï¼Œè€Œä¸æ˜¯åƒ vector é‚£æ ·é€šè¿‡ç´¢å¼•ã€‚åŒæ—¶å…·æœ‰ç±»ä¼¼ vector çš„æ€§è´¨ï¼Œå¦‚é•¿åº¦ã€å®¹é‡å’Œé‡æ–°åˆ†é…ã€‚

### åˆ›å»º

ä½¿ç”¨ `new` æ–¹æ³•åˆ›å»ºä¸€ä¸ªç©ºçš„ `HashMap`ï¼Œå¹¶ä½¿ç”¨ `insert` æ–¹æ³•å¢åŠ å…ƒç´ ã€‚

```rust
use std::collections::HashMap;
let mut scores = HashMap::new();
scores.insert(String::from("Red"), 10);
scores.insert(String::from("Green"), 20);
```

éœ€è¦ `use` æ ‡å‡†åº“ä¸­é›†åˆéƒ¨åˆ†çš„ `HashMap`ï¼Œå› ä¸ºæ²¡æœ‰è¢« prelude è‡ªåŠ¨å¼•ç”¨ã€‚

å“ˆå¸Œ map å°†çš„æ•°æ®å‚¨å­˜åœ¨å †ä¸Šï¼Œè¿™ä¸ª `HashMap` çš„é”®ç±»å‹æ˜¯ `String` è€Œå€¼ç±»å‹æ˜¯ `i32`ï¼Œæ‰€æœ‰çš„é”®å¿…é¡»æ˜¯ç›¸åŒç±»å‹ï¼Œå€¼ä¹Ÿå¿…é¡»éƒ½æ˜¯ç›¸åŒç±»å‹ã€‚

---

è¿˜å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå…ƒç»„çš„ vector çš„ `collect` æ–¹æ³•ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç»„åŒ…å«ä¸€ä¸ªé”®å€¼å¯¹ã€‚`collect` æ–¹æ³•å¯ä»¥å°†æ•°æ®æ”¶é›†è¿›ä¸€ç³»åˆ—çš„é›†åˆç±»å‹ï¼Œä½¿ç”¨ `zip` æ–¹æ³•æ¥åˆ›å»ºä¸€ä¸ªå…ƒç»„çš„ vectorã€‚

```rust
let teams = vec![String::from("Red"), String::from("Green")];
let init_scores= vec![10, 20];
let scores: HashMap<_, _> = teams.iter().zip(init_scores.iter()).collect();
```

`HashMap<_, _>` éœ€è¦ç±»å‹æ³¨è§£ï¼Œå› ä¸º `collect` æœ‰å¾ˆå¤šä¸åŒçš„æ•°æ®ç»“æ„ï¼Œè€Œé™¤éæ˜¾å¼æŒ‡å®šå¦åˆ™æ— æ³•è¿›è¡Œç±»å‹æ¨æ–­ã€‚ä½†æ˜¯å¯¹äºé”®å’Œå€¼çš„ç±»å‹å‚æ•°æ¥è¯´ï¼Œå¯ä»¥ä½¿ç”¨ä¸‹åˆ’çº¿å ä½ï¼ŒRust èƒ½å¤Ÿæ ¹æ® vector ä¸­æ•°æ®çš„ç±»å‹æ¨æ–­å‡º `HashMap` æ‰€åŒ…å«çš„ç±»å‹ã€‚

---

è¿˜èƒ½ä½¿ç”¨ `from` æ–¹æ³•ï¼Œå°†å…ƒç»„ä½œä¸ºæ•°ç»„çš„å…ƒç´ è¿›è¡Œåˆå§‹åŒ–ï¼š

```rust
let solar_distance = HashMap::from([
    ("Mercury", 0.4),
    ("Venus", 0.7),
    ("Earth", 1.0),
    ("Mars", 1.5),
]);
```

#### æ‰€æœ‰æƒ

å¯¹äºåƒ `i32` è¿™æ ·çš„ `Copy` trait çš„ç±»å‹ï¼Œå…¶å€¼å¯ä»¥æ‹·è´è¿›å“ˆå¸Œ mapã€‚å¯¹äºåƒ `String` è¿™æ ·æ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼ï¼Œå…¶å€¼å°†è¢«ç§»åŠ¨è€Œå“ˆå¸Œ map ä¼šæˆä¸ºè¿™äº›å€¼çš„æ‰€æœ‰è€…ã€‚

```rust
let field_name = String::from("Red");
let field_value = String::from("10");
let mut map = HashMap::new();
// field_name å’Œ field_value ä¸å†æœ‰æ•ˆï¼Œ
map.insert(field_name, field_value);
```

è‹¥å°†å€¼çš„å¼•ç”¨æ’å…¥å“ˆå¸Œ mapï¼Œè¿™äº›å€¼æœ¬èº«ä¸ä¼šè¢«ç§»è¿›å“ˆå¸Œ mapï¼Œä½†æ˜¯è¿™äº›å¼•ç”¨æŒ‡å‘çš„å€¼å¿…é¡»è‡³å°‘åœ¨å“ˆå¸Œ map æœ‰æ•ˆæ—¶ä¹Ÿæ˜¯æœ‰æ•ˆçš„ã€‚

### è¯»å–

å°†é”®åä½œä¸ºç´¢å¼•æ¥è·å–å€¼ï¼š

```rust
assert_eq!(10, scores["Red"]);
```

å°†é”®åä½œä¸ºç´¢å¼•æ—¶ï¼Œå¦‚æœè¢«ç´¢å¼•çš„é”®ä¸åœ¨å“ˆå¸Œ map ä¸­ï¼Œåœ¨ç¼–è¯‘æ—¶ä¸ä¼šæŠ¥é”™ï¼Œä½†è¿è¡Œæ—¶ä¼šå‘ç”Ÿ panicã€‚ä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œå¯ä»¥é€šè¿‡ `get` æ–¹æ³•å¹¶æä¾›å¯¹åº”çš„é”®æ¥ä»å“ˆå¸Œ map ä¸­è·å–å€¼ã€‚

```rust
let mut scores = HashMap::new();
scores.insert(String::from("Red"), 10);
scores.insert(String::from("Green"), 20);
let score = scores.get(&String::from("Red"));
```

`score` çš„å€¼åº”ä¸º `Some(10)`ï¼Œå› ä¸º `get` è¿”å› `Option`ï¼Œæ‰€ä»¥ç»“æœè¢«è£…è¿› `Some`ï¼›å¦‚æœæŸä¸ªé”®åœ¨å“ˆå¸Œ map ä¸­æ²¡æœ‰å¯¹åº”çš„å€¼ï¼Œ`get` ä¼šè¿”å› `None`ï¼Œè¿™æ—¶éœ€è¦ç”¨ match æ¥å¤„ç† `Option`ï¼Œå› æ­¤ä½¿ç”¨ `get` æ–¹æ³•ä¸ä¼šå‘ç”Ÿ panicã€‚

---

ä½¿ç”¨ `for` æ¥éå†å“ˆå¸Œ map ä¸­çš„æ¯ä¸€ä¸ªé”®å€¼å¯¹ï¼š

```rust
let mut scores = HashMap::new();
scores.insert(String::from("Red"), 10);
scores.insert(String::from("Green"), 20);
for (key, value) in &scores {
    println!("{key}: {value}");
}
```

`len` å’Œ `capacity` æ–¹æ³•æ¥æŸ¥çœ‹é•¿åº¦å’Œå®¹é‡ï¼š

```rust
println!("{}", scores.len());
println!("{}", scores.capacity());
```

`shrink_to_fit` æ–¹æ³•å‡å°å®¹é‡ä»¥åŒ¹é…å½“å‰é•¿åº¦ï¼š

```rust
let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);
map.insert(1, 2);
map.insert(3, 4);
map.shrink_to_fit();
assert!(map.capacity() >= 2);
```

`keys` å’Œ `values` æ–¹æ³•åˆ†åˆ«è¿”å›ä¸€ä¸ªé”®å’Œå€¼çš„è¿­ä»£å™¨ï¼š

```rust
let map = HashMap::from([
    ("a", 1),
    ("b", 2),
    ("c", 3),
]);

for key in map.keys() {
    println!("{key}");
}

for val in map.values() {
    println!("{val}");
}
```

`contains_key` æ–¹æ³•åˆ¤æ–­æ˜¯å¦å«æœ‰æŒ‡å®šé”®ï¼š

```rust
let map = HashMap::from([("a", 1)]);
assert_eq!(map.contains_key("a"), true);
```

### æ›´æ–°

é”®å€¼å¯¹çš„æ•°é‡å¯å¢é•¿ï¼Œä½†ä»»ä½•æ—¶å€™æ¯ä¸ªé”®åªèƒ½å…³è”ä¸€ä¸ªå€¼ã€‚å½“è¦æ›´æ–°å“ˆå¸Œ map ä¸­çš„æ•°æ®æ—¶ï¼Œå¿…é¡»å¤„ç†ä¸€ä¸ªé”®å·²ç»æœ‰å€¼äº†çš„æƒ…å†µã€‚

-   å¯ä»¥é€‰æ‹©ç”¨æ–°å€¼æ›¿ä»£æ—§å€¼ï¼›

-   å¯ä»¥é€‰æ‹©ä¿ç•™æ—§å€¼è€Œå¿½ç•¥æ–°å€¼ï¼Œå¹¶åœ¨é”®æ²¡æœ‰å¯¹åº”å€¼æ—¶å¢åŠ æ–°å€¼ï¼›

-   å¯ä»¥ç»“åˆæ–°æ—§ä¸¤å€¼ã€‚

å½“æ’å…¥äº†ä¸€ä¸ªé”®å€¼å¯¹ï¼Œæ¥ç€ç”¨ç›¸åŒçš„é”®æ’å…¥ä¸€ä¸ªä¸åŒçš„å€¼ï¼Œä¸è¿™ä¸ªé”®ç›¸å…³è”çš„æ—§å€¼å°†è¢«æ›¿æ¢ã€‚

```rust
let mut scores = HashMap::from([(String::from("Red"), 10)]);
// åŸå§‹å€¼ 10 è¢«è¦†ç›–
scores.insert(String::from("Red"), 20);

// å¯ä»¥å°†é”®å½“ä½œç´¢å¼•æ¥è·å–å€¼ï¼Œä½†ä¸èƒ½ä¿®æ”¹å€¼
scores["Red"] = 20;              // é”™è¯¯
println!("{}", scores["Red"]);   // æ­£ç¡®
```

æ£€æŸ¥æŸä¸ªç‰¹å®šçš„é”®æ˜¯å¦æœ‰å€¼ï¼Œè‹¥æ²¡æœ‰åˆ™æ’å…¥ä¸€ä¸ªå€¼ã€‚å“ˆå¸Œ map æœ‰ä¸€ä¸ª `entry` æ–¹æ³•ï¼Œå®ƒè·å–è¦æ£€æŸ¥çš„é”®ä½œä¸ºå‚æ•°ã€‚`entry` æ–¹æ³•çš„è¿”å›å€¼æ˜¯ä¸€ä¸ª `Entry` æšä¸¾ï¼Œå®ƒä»£è¡¨äº†å¯èƒ½å­˜åœ¨æˆ–ä¸å­˜åœ¨çš„å€¼ã€‚

```rust
let mut scores = HashMap::from([(String::from("Red"), 10)]);
scores.entry(String::from("Green")).or_insert(20);
// Red å·²å­˜åœ¨ï¼Œåˆ™ä¸æ’å…¥å€¼
scores.entry(String::from("Red")).or_insert(30);
```

`Entry` çš„ `or_insert` æ–¹æ³•åœ¨é”®å¯¹åº”çš„å€¼å­˜åœ¨æ—¶å°±è¿”å›è¿™ä¸ªå€¼çš„å¯å˜å¼•ç”¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™å°†å‚æ•°ä½œä¸ºæ–°å€¼æ’å…¥å¹¶è¿”å›æ–°å€¼çš„å¯å˜å¼•ç”¨ã€‚

---

è¦æ‰¾åˆ°ä¸€ä¸ªé”®å¯¹åº”çš„å€¼å¹¶æ ¹æ®æ—§çš„å€¼æ›´æ–°å®ƒï¼Œå¦‚è®¡æ•°æ–‡æœ¬ä¸­æ¯ä¸€ä¸ªå•è¯åˆ†åˆ«å‡ºç°äº†å¤šå°‘æ¬¡ã€‚ä½¿ç”¨å“ˆå¸Œ map ä»¥å•è¯ä½œä¸ºé”®å¹¶é€’å¢å…¶å€¼æ¥è®°å½•é‡åˆ°è¿‡å‡ æ¬¡è¿™ä¸ªå•è¯ï¼Œè‹¥ç¬¬ä¸€æ¬¡çœ‹åˆ°æŸä¸ªå•è¯ï¼Œåˆ™æ’å…¥å€¼ `0`ã€‚

```rust
let text = "hello world hello ok 123 world hello";
let mut map = HashMap::new();
for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count +=1;
}
println!("{:?}", map);
```

---

`clear` æ–¹æ³•æ¸…ç©ºå“ˆå¸Œ mapï¼Œ`is_empty` æ–¹æ³•åˆ¤æ–­æ˜¯å¦ä¸ºç©ºï¼š

```rust
let mut map = HashMap::from([("a", 1)]);
map.clear();
assert!(map.is_empty());
```

`remove` å’Œ `remove_entry` æ–¹æ³•åˆ é™¤æŒ‡å®šé”®ã€‚å‰è€…è‹¥å­˜åœ¨æŒ‡å®šé”®ï¼Œåˆ™è¿”å›å¯¹åº”çš„å€¼ï¼Œåè€…è‹¥å­˜åœ¨æŒ‡å®šé”®ï¼Œåˆ™è¿”å›å¯¹åº”çš„é”®å’Œå€¼ç»„æˆçš„å…ƒç»„ï¼š

```rust
let mut map = HashMap::from([("a", 1)]);
assert_eq!(map.remove("a"), Some(1));
assert_eq!(map.remove("a"), None);
map.insert("a", 1);
assert_eq!(map.remove_entry("a"), Some(("a", 1)));
assert_eq!(map.remove("a"), None);
```

### åˆå¹¶

`extend` æ–¹æ³•å°†å¦ä¸€ä¸ª HashMap çš„é”®å€¼å¯¹æ·»åŠ åˆ°ç›®æ ‡ HashMap ä¸­ã€‚è‹¥å­˜åœ¨é‡å¤çš„é”®ï¼Œåˆ™ç›®æ ‡ HashMap ä¸­çš„å€¼å°†è¢«è¦†ç›–ã€‚

```rust
let mut map1 = HashMap::from([("a", 1)]);
let map2 = HashMap::from([("a", 2), ("b", 3)]);

map1.extend(map2);
assert_eq!(HashMap::from([("a", 2), ("b", 3)]), map1);
```

# 4 IO

