# 1 语言基础

## 标识符

-   由任意非空的，且非 emoji 的 Unicode 字符构成；
-   不能以数字开头，且不能为关键字；

-   当以下划线开头时，长度至少为 **2**；

-   单个 `_` 作为标识符表示**忽略**。

### 原始标识符

当和外部 FFI 进行交互时，如调用 C 库中名为 `match` 的函数。在 C 中 match 不是关键字，但在 Rust 中是关键字，因此需要使用以 `r#` 开头的原始标识符。

```rust
fn r#fn() {
    let r#i32 = 123;
    println!("{}", r#i32);
}

fn main() {
    r#fn();
}
```

## 常量和变量

**常量**使用 `const` 关键字声明，必须显式指明类型，并在声明时初始化，声明后值不可变。

**变量**使用 `let` 关键字声明，可以不显式声明类型，值与变量通过**绑定**来关联。但 Rust 默认变量也是**不可变的**，需要显式使用 `mut` 关键字修饰来使其可变。

```rust
const MAX: i32 = 5;  // 常量
let x = 1;           // 不可变变量
let mut y:u32 = 2;   // 可变变量
```

同时 `let` 和 `mut` 是一个**模式**，可以利用**模式匹配**来声明变量：

```rust
let (mut a, b) = (1, 2);  // a 可变，b 不可变
```

变量可以不必在声明时初始化，但使用前必须被初始化：

```rust
let x;
x = 1;
println!("{x}");
```

常量和不可变变量的区别：

-   常量的值必须能够在编译期就能计算出，不能是在运行时才能计算出的值；
-   常量可以在任何作用域中声明，包括全局作用域，而变量只能在函数作用域生效。

### 隐藏

可以通过 `let` 来定义一个与已声明变量或函数同名的新变量，新变量会隐藏之前的变量或函数。

```rust
fn sum(x: i32, y: i32) -> i32 {
    x + y
}

fn main() {
    let x = 1;
    let x = x + 2;
    let x = 1.2;    // 类型可以不同
    let sum = sum(1, 2);
    sum(3, 4);      // 错误，sum 函数在此处不可用
}
```

新变量只在其作用域内起作用，当离开作用域时，外部被隐藏的项会恢复：

```rust
let v = 2;
{
    let v = 4;
    println!("{v}");   // 输出 4
}
println!("{v}");       // 输出 2
```

## 静态项

静态项使用 `static` 声明，必须显式指明类型和初始化，类似于常量，但在程序中表示一个精确的内存位置。所有对静态项的引用都指向相同的内存位置，并具有 ` 'static` 生命周期，且不会在程序结束时调用析构函数 `drop`。

静态项的初始化是在编译期求值的常量表达式，并可引用其它静态项。

所有访问静态项的操作都是安全的，但有一些限制：

-   静态项的数据类型必须有 `Sync` trait；
-   常量项不能引用静态项。

静态想可以使用 `mut` 声明，但对其所有访问操作都是不安全的，需要在 `unsafe` 块中使用。

```rust
static mut COUNT: i32 = 0;

unsafe fn read_count() -> i32 {
    COUNT
}

unsafe fn write_count(n: i32) {
    COUNT += n;
}
```

## 基本类型

Rust 是**静态类型**语言，编译器能够进行类型推断。当多种类型均有可能时，必须增加**类型注解**。

```rust
let x: u32 = 10;
let y: f32 = 3.14;
```

每一个值都属于某种数据类型，Rust 有两类数据类型子集：**标量**和**复合**。

### 标量类型

标量类型代表一个单独的值。Rust 有四种基本的标量类型：**整型**、**浮点型**、**布尔类型**和**字符类型**。

#### 整型

| 长度    | 有符号     | 无符号 |
| ------- | ---------- | ------ |
| 8 bit   | i8         | u8     |
| 16 bit  | i16        | u16    |
| 32 bit  | i32 (默认) | u32    |
| 64 bit  | i64        | u64    |
| 128 bit | i128       | u128   |
| arch    | isize      | usize  |

-   有符号数以**补码**形式存储；

-   `isize` 和 `usize` 依赖于运行程序的计算机架构。

| 字面值         | 例            |
| -------------- | ------------- |
| Decimal        | `10_000`      |
| Hex            | `0xfe`        |
| Octal          | `0o77`        |
| Binary         | `0b1010_1000` |
| Byte (仅 `u8`) | `b'A'`        |

-   除 Byte 以外的所有字面值允许使用类型后缀，如 `12_u8`，也允许使用 `_` 做为分隔符；

-   对于整数溢出，非优化编译时，会检查这类问题并 panic。优化编译时不检查，并按照补码计算实际值。


#### 浮点型

Rust 有 `f32` 和 `f64` 两种浮点类型，遵循 [IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754) 标准，字面值默认为 `f64`。

#### 布尔型

`bool` 表示布尔类型，只有两个可能的值：`true` 和 `false`。

#### 字符类型

`char` 表示字符类型，值由单引号包括。

```rust
let a: char = 'a';
let b = '你';
let c = 'あ';
let d = 'Ω';
let e = '😅';
let f = '\u{102c0}';
```

`char` 可以是合法的 Unicode 标量值，一个 `char` 占 4 个字节。

Unicode 中有一些字符是**零宽度字符**，和 `''` 这种空白字符是不一样的，**Rust 没有空值**，因此 `''` 是不被允许的。

```rust
let c = '';  // 错误，不能为空值
```

可以将字符值赋值给整型变量，但限制如下：

-   必须增加类型前缀 `b`；

-   只支持 `u8`。

```rust
let n: u8 = b'A';   // n = 65
```

### 复合类型

复合类型由多个值组合而成一个类型。Rust 的原生复合类型为**元组**和**数组**。

#### 元组类型

元组是一个包含多个相同或不同类型值的列表，且长度固定，类型表示为 `(T, U, ..)`。可通过模式匹配来**解构**其中的值，或使用 `.index` 来直接访问其中的值。 

```rust
let tup: (i32, f64, u8) = (100, 2.1, 20);
let (x, y, z) = tup;
assert!(x == tup.0);
```

为了避免混淆，单元素元组需要在追加 `,`：

```rust
let tup = (1,);
```

没有任何值的元组为**单元类型**类型 `()`，只有一个**单元值** 。若表达式或函数不返回任何值，则会隐式返回单元值。

```rust
fn foo() {}
let empty: () = ();
let x = {};     // x = ()
let y = foo();  // y = ()
```

#### 数组类型

数组是一个包含多个相同类型值的列表，且长度固定，类型表示为 `[T; N]`。可通过 `[index]` 来直接访问其中的值。

```rust
let arr: [i32; 5] = [1, 2, 3, 4, 5];
let x = arr[0];
let y = arr[1];
```

可通过 `[V; N]` 来创建一个长度为 `N`，元素值都为 `V` 的数组：

```rust
let arr = [0; 5];
```

当对无效的数组元素进行访问时会 panic：

```rust
arr[10];  // panic
```

## 动态大小类型

在编译时就已知的大小的类型为**固定大小类型**，具有 `Sized` trait；在运行时才知道大小的类型为**动态大小类型**（Dynamically Sized Types，DST），具有 `?Sized` trait。如切片 `[T]` 和 trait 对象 `dyn Trait` 都是 DST，这种类型都不能直接使用，需要通过指针或引用来间接使用，如 `&[T]` 和 `Box<dyn Trait>`。

-   指向 DST 的指针大小是固定的，且为指向 `Sized` 的指针大小的两倍；
    -   指向切片的指针额外存储了切片的元素数量；
    -   指向 trait 对象的指针额外存储了 vtable 的地址。
-   DST 可以作为实参来传递给有 `?Sized` 约束的泛型类型参数。当关联类型的声明有 `?Sized` 约束时，也可以被用于关联类型定义；
-   默认情况下，任何类型参数或关联类型都有 `Sized` 约束，除非使用 `?Sized` 来放宽约束；
-   与泛型类型参数不同，由于 `Self: ?Sized` 是 trait 定义中的默认约束，因此可以为 DST 实现 trait；
-   结构体最后一个字段可以为 DST，这使得该结构体也是一个 DST。

>   变量、函数参数、常量和静态项必须是 `Sized`。

## 字符串

Rust 中主要有 `str` 和 `String` 两种字符串类型，其中 `str` 是原生类型，存储在栈上，`String` 存储在堆上。这两种值的表示方法与 `[u8]` 相同，且都保证数据是有效的 UTF-8 序列。由于 `str` 是一个 DST，具有 `?Sized` trait，因此只能通过指针类型实例化并使用，如 `&str`。

```rust
let s1: &str = "hello";  // 实际上会被推导为 &'static str
let s2: &'static str = "world";
let s3: String = String::from("haha");
let s4: &str = &s3;
```

`&str` 和 `String`：

-   `&str`：一个字符串切片，表示对某个字符串数据的不可变引用；
-   `String`：在堆上分配的可变字符串。

`&str` 和 `&'static str`：

-   不是所有的 `&str` 都是 `&'static str`。一个字符串字面量如 `"hello"`，则默认具有 `'statuc` 生命周期；
-   若从 `String` 创建一个切片，那么该切片的生命周期则不是 `'static`。

大多数时候，可以不用显式指明 `&str` 或 `&'static str`，因为编译器会自动推导其生命周期。

### 原始字符串

以 `r` 或 `r#` 的形式来表示原始字符串，不会对字符进行转义。

```rust
let s1 = r"hello\t\nhello";
let s2 = r##"hello\t\nhello"##;
let s3 = r###"hello\t\nhello"###;
let s4 = r####"hello\t\nhello"####;
```

当使用 `r#` 的形式时，需要确保前后 `#` 的数量是一致的。

## 语句和表达式

Rust 是一种基于表达式的语言，求值都通过表达式完成。表达式可内嵌到另一个表达式中，求值规则包括指定表达式产生的值和指定其各个子表达式的求值顺序。语句则主要用于包含表达式，以及显式安排表达式的求值顺序。表达式和语句的显著区别为表达式**计算并产生一个值**，语句执行操作但**不返回值**。

### 声明语句

声明语句是在其封闭语句块内部引入一个或多个名称的语句，包含两种：程序项声明和 `let` 声明。

#### 程序项声明

程序项声明语句不会隐式捕获外部作用域中的函数参数、泛型参数和局部变量。

```rust
fn foo(a: i32) {
    let v = a + 1;

    fn bar() {
        a + v;  // 错误，参数 a 和局部变量 v 都不能被捕获
    }
}
```

#### let 声明

`let` 语句通过不可反驳的模式引入了一组新的变量。除非被另一个变量声明隐藏，否则任何变量从声明点到封闭块作用域的结束都是可见的。`let` 还通过**绑定**使值和变量关联起来，任何值只有被绑定后，才能继续存在，否则其生命周期会在当前语句结束时结束。

### 表达式语句

表达式语句是对表达式求值并忽略其结果的语句。

```rust
1 + 2;  // 忽略计算值
```

### 语句属性

语句可以有外部属性，在语句中有意义的属性是 `cfg` 和 lint 检查属性。

```rust
#[cfg(target_os = "windows")]
#[allow(unused)]
let greet = "Hello Windows!";

#[cfg(target_os = "linux")]
let greet = "Hello Linux!";
```

### 控制流表达式

Rust 中有 4 中控制流表达式：`if`、`loop`、`while` 和 `for`，其中的条件**必须是 `bool` 值**。

`if` 用于控制分支，可与 `else` 搭配使用。

```rust
let mut x = 10;
x = if x < 3 {
    x + 1
} else if x < 6 {
    x + 2
} else {
    x + 3
};
```

`loop` 用于无限循环，`while` 用于条件循环，`for` 用于遍历；`break` 用于提前跳出循环，`continue` 用于提前结束本次循环。其中**只有 `loop` 能够使用 `break + 值` 的形式来返回**。

```rust
// loop
let mut x = 0;
let y = loop {
    x = x + 1;
    if x > 10 {
        break x;
    }
};

// while
let arr = [1, 2, 3];
let mut i = 0;
while i < arr.len() {
    println!("{}", arr[i]);
    i += 1;
}

// for
for e in 1..4 {
    println!("{e}");
}
```

`break` 和 `continue` 只能用于内层循环，使用 `'` + `标识符` 的形式定义一个**循环标签**，则可作用于外层循环。

```rust
'out: loop {
    loop {
        println!("Do this");
        break 'out;
    }
    println!("Never do");
}
println!("Do this after loop");
```

### 其它表达式

Rust 中的表达式有很多种，主要有：

-   字面量表达式
-   路径表达式
-   块表达式
-   运算符表达式
-   结构体表达式
-   调用表达式
-   闭包表达式
-   区间表达式
-   模式匹配表达式
-   返回表达式
-   异步表达式
-   ...

>   更多关于表达式的信息，可参考 [Rust 表达式](https://minstrel1977.gitee.io/rust-reference/expressions.html)。

# 2 所有权

所有权是 Rust 用来管理内存的机制。

## 所有权规则

- Rust 中的每个值都有一个**所有者**；
- 值**有且仅有一个**所有者；
- 当所有者离开作用域，这个值将被丢弃。

### 作用域

作用域是一个项在程序中有效的范围。

```rust
let s1 = "hello";       // s1 生效
{                       // 作用域开始
    let s2 = "world";   // s2 生效
}                       // 作用域结束，s2 无效，s1 有效
```

当变量进入作用域时，就是有效的，并一直持续到离开作用域为止。

### 堆上的数据

在编译时就知道的大小的数据通常放在栈上，而变化的或运行时才知道大小的数据通常放在堆上。`String` 类型就是一种放在堆上的数据。

```rust
let mut s = String::from("hello");
s.push_str(", world!");
```

`&str` 在编译时就知道其内容，被直接硬编码进可执行文件的只读区块中，因此效率高，但也不可变。

对于 `String` 类型，为了支持一个可变的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容，这需要：

- 在运行时向操作系统申请内存；
- 在处理完后释放内存的方法。

在有垃圾回收的语言中， GC 管理这部分内存内存；在没有 GC 的语言中，需要手动管理。提前释放和重复释放都会导致问题，这需要精确配对每一个申请和释放。

**所有权的策略为：变量离开作用域后内存就自动释放。**

```rust
{
    let s = String::from("hello");  // s 从此处开始生效
}                                   // s 无效
```

当变量离开作用域时，在结尾的 `}` 处将自动调用析构函数 `drop` 释放内存。

>   在 C++ 中，这种在生命周期结束时释放**资源**的模式被称作 RAII（Resource Acquisition Is Initialization，资源获取即初始化）。资源可以是内存地址，包含某个值的变量、共享内存引用、文件句柄、网络套接字或数据库连接句柄等。

### 数据交互：移动

Rust 中的多个变量可以采用一种独特的方式与同一数据交互。

```rust
let x = 5;
let y = x;
let s1 = String::from("hello");
let s2 = s1;
```

`x` 和 `y` 都是固定大小类型，直接存放在栈上，因此 `y` 获得 `x` 的拷贝。而对于 `String`，`s2` 并不会获得一个 `s1` 的拷贝。

`String` 由三部分组成：**指向字符串的指针、长度和容量**。这一组数据存储在栈上，堆上则存放字符串的内容。

![String 在内存中的表示](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202203232352837.png)

当把 `s1` 赋值给 `s2` 时，`String` 在栈上的数据被复制了，而堆上的数据没有复制。只复制指针、长度和容量这些栈上的数据可看做**浅拷贝**，而把栈上和堆上的数据都进行复制可看做**深拷贝**。Rust 不会自动创建数据的深拷贝，因此任何自动的复制可以被认为对运行时性能影响较小。

![s1 和 s2 指向同一块堆内存](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202203240158188.png)

按照所有权规则，当变量离开作用域后，会自动调用析构函数，但 `s1` 和 `s2` 都指向了同一个堆内存，这就会导致二次释放。为了确保内存安全，这种情况下就认为 `s1` 不再有效，因此 `s1` 不需要在离开作用域时进行清理。

```rust
let s1 = String::from("hello");
let s2 = s1;        // s1 失效
println!("{s1}");   // 错误
```

这种行为可以看作 `s1` 被移动到了 `s2` 中，因此被称为**移动**。当持有堆中数据的变量离开作用域时，其值将通过 `drop` 函数被清理掉，**除非数据被移动为另一个变量所有**。

### 数据交互：克隆

若确实需要复制 `String` 中堆上的数据，而不仅仅是栈上的数据，可以调用 `clone` 函数。

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
println!("{s1}, {s2}");
```

由于 `clone` 函数需要复制堆上的数据，因此会影响运行时性能。

### Copy 和 Clone

任何能够在编译期就知道大小的类型，都具有 `Copy` trait，在赋值时会自动进行复制。而在堆上的数据则不具有该 trait，但可能具有 `Clone` trait，可以显式调用 `clone` 函数来复制数据。

对于引用类型，所有的 `&T` 都具有 `Copy` trait，而 `&mut T` 则不具有。

### 所有权与函数

将值传递给函数在语义上与给变量赋值相似，向函数传递值可能会移动或复制。

```rust
fn print_number(n: i32) {
    println!("{n}");
}   // n 被移出作用域

fn print_string(s: String) { // s 作用域开始
    println!("{s}");
}   // s 被移出作用域并调用 drop 函数

fn main() {
    let n = 1;
    let s = String::from("hello");
    print_number(n);      // n 的值移动到函数中，但 i32 是 Copy 的，可在之后继续使用
    print_string(s);      // s 的值移动到函数中，之后不能继续使用
    println!("{n}");      // n 依旧有效
    println!("{s}");      // s 已经无效，此行代码错误
}   // n 被移出作用域，s 的值已被移走，不会有特殊操作
```

### 返回值与作用域

返回值也可以转移所有权。

```rust
fn ret() -> String {
    let s = String::from("hello");
    s   // 将 s 的值移出，返回给调用它的函数
}

fn take_and_ret(ts: String) -> String {
    ts  // 将 ts 的值移出，返回给调用它的函数
}

fn main() {
    let s1 = ret();             // 函数将返回值移动到 s1
    let s2 = String::from("hello");
    let s3 = take_and_ret(s2);  // s2 的值被移动到函数中，函数将返回值移动到 s3
}   // s1、s3 被移出作用域，调用 drop 函数，s2 的值已被移走，不会有特殊操作
```

## 引用和借用

### 引用类型

以一个对象的**引用**作为参数而不是获取值的所有权，类型表示为 `&T`，创建一个引用的行为称为**借用**。

```rust
fn str_len(s: &String) -> usize {   // s 是对 String 的引用
    s.len()
}   // s 离开作用域，但它并不拥有引用值的所有权，所以不会有特殊操作

fn main() {
    let s1 = String::from("hello");
    let len = str_len(&s1);
    println!("s1: {s1}, len: {len}");
}
```

传递 `&s1` 给函数，同时在函数定义中，获取 `&String` 而不是 `String`。`&` 符号表示引用，允许使用值但不获取其所有权。因为并不拥有这个值，当引用离开作用域时其指向的值也不会被丢弃。函数签名使用 `&` 来表明参数 `s` 的类型是一个引用。

![对象的引用](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202203240005250.png)

引用和指针类似，其保存了一个地址，可以由此访问储存于该地址的数据，并且确保指向的值是有效的。

>   与 `&` 相反的操作是**解引用**，使用解引用运算符 `*`。

### 区分引用和借用

```rust
let s = String::new();
let s1 = &s;
```

`s1` 是一个引用，它借用了来自 `s` 的值，即来自 `String` 的借用，因此 `s1` 的类型为 `&String`，一般情况下可以不用严格区分这两者。

### 可变引用

变量默认是不可变的，引用也一样，**默认不允许修改引用的值**。

```rust
let s = String::from("hello");
let ps = &s;
ps.push_str(" world!");  // 错误，引用默认不可变
```

使用 `mut` 修饰变量和引用，可以使引用可变，类型表示为 `&mut T`。

```rust
let mut s = String::from("hello");
let ps = &mut s;
ps.push_str(" world!");
```

**`mut` 变量可被引用为 `&` 或 `&mut`，非 `mut` 变量只能被引用为 `&`。**

```rust
let x = 1;
let mut y = 2;
let rx = &mut x;    // 错误，非 mut 变量只能被引用为 &
let ry = &y;        // 正确，可以对 mut 变量引用为 &
```

`mut` 变量指的是该变量本身是否可变，`mut` 引用指的是所引用的值是否可变。

```rust
let x = 1;
let y = 2;
let mut rx = &x;
rx = &y;    // 改变的是变量自身

let mut z = 3;
let rz = &mut z;
*rz = 6;    // 改变的是引用的值
```

若变量本身的类型是引用，则 `&` 和 `&mut` 是两种数据类型，**因此一个 `mut` 变量的类型不能在 `&` 和 `&mut` 之间切换。**

```rust
let mut x = 1;
let mut y = 2;
let mut rx = &mut x;    // rx 的类型被确定为 &mut
rx = &y;                // 错误，不能将一个 & 类型赋值给 rx
let rx = &y;            // 正确，可以通过隐藏来改变 rx 的类型
```

**值在同一作用域内有且仅有一个可变引用**，这个限制可以避免数据竞争。

```rust
let mut s = String::from("hello");
let r1 = &mut s;
let r2 = &mut s;    // 错误
```

通过创建新的作用域，以允许拥有多个可变引用。

```rust
let mut s = String::from("hello");
{
    let r1 = &mut s;
}   // r1 离开作用域，r2 可以拥有 s 的可变引用
let r2 = &mut s;
```

**不能在拥有不可变引用的同时拥有可变引用**，**但可以拥有多个不可变引用**。

```rust
let mut s = String::from("hello");
let r1 = &s;
let r2 = &s;
let r3 = &mut s;    // 错误，已有不可变引用
```

一个引用的作用域从声明的地方开始一直持续到**最后一次使用为止**。如最后一次使用不可变引用在声明可变引用之前，或仅在最后一次使用可变引用**之后**，原始数据才可以再次可变或不可变的借用。编译器在作用域结束之前判断不再使用的引用的能力称为**非词法作用域生命周期**。

```rust
let mut s = String::from("hello");
let r1 = &s;
let r2 = &s;
println!("{r1}, {r2}");   // 最后一次使用引用，r1、r2 作用域结束
let r3 = &mut s;          // 可以使用
println!("{r3}");
```

在引用的生命周期内，被引用的变量本身不允许改变，不管是 `&` 还是 `&mut`。

```rust
let mut x = 1;
let rx = &mut x;              // 亦或是 &x
x = 2;                        // 错误，不允许 x 自身内容变化
println!("{rx}");
```

### 引用规则

- 在任意时刻，要么只能有一个可变引用，要么只能有一个或多个不可变引用；
- 引用的作用域持续到最后一次**使用**为止；
- 引用必须总是有效。

### 悬垂引用

在某些语言中，可以在释放内存时保留指向它的指针从而错误地生成一个悬垂指针。**悬垂指针**是其指向的内存可能已经被分配给其它所有者。Rust 确保引用永远也不会变成悬垂状态：**编译器确保数据不会在其引用之前离开作用域**。

```rust
fn main() {
    let r = dr();            // 引用指向无效的 String
}

fn dr() -> &String {        // 返回一个字符串引用
    let s = String::from("hello");
    &s                      // 错误
}   // s 离开作用域，其内存将被释放
```

## 切片类型

切片是没有所有权的数据类型，也是一种 DST，记作 `[T]`，对它的引用记作 `&[T]`，它允许引用集合中一段连续的元素序列，而不是引用整个集合。大部分情况下不用严格区分切片和切片的引用。

### 字符串切片

字符串切片是对 `String` 或 `str` 中一部分值的引用，记作 `&str`。实际上 `str` 就是一个类型为 `[u8]` 的动态大小类型，而 `&str` 就是一个 `&[u8]`。和通常的 `[u8]` 或 `&[u8]` 的区别为，`&str` 保证其中的值为合法的 UTF-8 编码，所以也可以看成是一个 `[char]` 或 `&[char]`。

```rust
let s = String::from("hello world");
let s1 = &s[0..5];
let s2 = &s[6..=10];
```

`..` 为**区间表达式**，`=` 表示闭区间。`s1` 将引用整个 `String` 中索引值为 `[0..5]` 部分。它不是对整个 `String` 的引用，而是对部分 `String` 的引用。

![字符串切片](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202203240457604.png)

字符串切片的索引必须位于有效的 UTF-8 字符边界内，若尝试从一个多字节字符的中间位置创建字符串切片，则会 panic。

```rust
let s = String::from("你好");
let s1 = &s[0..2];   // 错误，UTF-8 中汉字占 3 个字节
let s1 = &s[0..3];   // 正确
```

对于区间表达式，若从索引 0 开始或到尾部结束，可以不写两个点号之前或之后的值。

```rust
let s1 = &s[..5];
let s2 = &s[6..];
let s3 = &s[..];    // 获取整个字符串切片
```

#### 字符串字面值就是切片

字符串字面值被储存在二进制文件中，因此它就是一个切片。

```rust
let s = "hello world";
```

这里 `s` 的类型是 `&str`：它是一个指向二进制文件特定位置的切片，这也就是为什么字符串字面值是不可变的。

#### 字符串切片作为参数

对于一个接受 `&String` 参数的函数：

```rust
fn foo(s: &String) {}
```

可以改为接受 `&str`：

```rust
fn foo(s: &str) {}
```

这样可以对 `String` 值和 `&str` 值使用相同的函数，使 API 更加通用。

```rust
let s1 = String::from("hello world");
let s2 = "second string";

foo(&s1);
foo(&s1[..]);
foo(s2);
foo(&s2[..]);
```

###  其它切片类型

除了字符串切片，任何 `&[T]` 都是切片，如 `&[i32]`。

```rust
let arr = [1, 2, 3, 4, 5];
let slice = &arr[1..3];
assert_eq!(slice, &[2, 3]);
```

# 3 结构体和枚举

## 定义结构体

结构体使用 `struct` 定义，没有任何字段的为**单元结构体**，通常用于不存储数据仅实现某个 trait 时使用。没有字段名只有类型的为**元组结构体**。

```rust
struct User {
    name: String,
    age: u8,
}

struct U;
struct Rgb(u8, u8, u8);

fn main() {
    let mut user1 = User {
        name: String::from("Alice"),
        age: 18
    };

    let user2 = User {
        name: String::from("Bob"),
        ..user1
    };

    let u = [U, U {}];
    let color = Rgb(255, 255, 255);

    user1.age = 20;
}
```

在初始化结构体时，可以使用**结构体更新语法** `..`，来指定剩余未显式设置值的字段与给定实例对应字段的值相同，但注意若给定实例中的这些对应字段没有实现 `Copy` trait，则会发生移动，可能导致错误发生。

当使用变量来进行初始化时，若变量名与字段名相同，则可使用**字段初始化简写语法**。

```rust
fn new(name: String, age: u8) -> User {
    User {
        name,
        age
    }
}
```

若函数参数名与字段名不相同，则不能简写。

### 所有权

结构体不是标量类型，没有实现 `Copy` trait，因此直接赋值会发生移动。

```rust
struct Foo;

fn main() {
    let s = Foo;
    let s2 = s;    // s 被移动到 s2
}
```



## 枚举

## 定义枚举

枚举允许通过列举可能的成员来定义一个类型。

目前被广泛使用的两个主要 IP 标准：IPv4 和 IPv6。程序可能会遇到的所有可能的 IP 地址类型：可以枚举出所有可能的值。enum 中的所有值都属于同一种类型，也就是 enum 的名称所表示的类型。

通过在代码中定义一个 `IpKind` 枚举来列出可能的 IP 地址类型，`V4` 和 `V6`，这被称为枚举的**成员**。

```rust
enum IpKind {
    V4,
    V6
}
```

枚举成员拥有隐式的从 0 开始的整数值，且可以通过 `as` 来进行类型转换，也可以显式指定值：

```rust
// 隐式值，从 0 开始
enum Num {
    Zero,
    One,
    Two
}

// 显式值
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff
}

fn main() {
    println!("Zero is {}", Number::Zero as i32);
    println!("One is {}", Number::One as i32);

    println!("Roses are #{:06x}", Color::Red as i32);
    println!("Violets are #{:06x}", Color::Blue as i32);
}
```



### 枚举值

创建 `IpKind` 两个不同成员的实例。

```rust
let ipv4: IpKind = IpKind::V4;
let ipv6 = IpKind::V6;
```

枚举的成员位于其标识符的**命名空间**中，并使用两个冒号 `::` 分隔。

可以定义一个函数来获取任何 `IpKind`。

```rust
fn route(ip_type: IpKind) {}
```

然后使用成员调用该函数。

```rust
let ipv4 = IpKind::V4;
route(ipv4);
route(IpKind::V6);
```

还可以配合结构体来处理 IP 地址数据。

```rust
enum IpKind {
    V4,
    V6
}

struct IpAddr {
    kind: IpKind,
    address: String
}

let home = IpAddr {
    kind: IpKind::V4,
    address: String::from("127.0.0.1")
};

let loopback = IpAddr {
    kind: IpKind::V6,
    address: String::from("::1")
};
```

使用枚举并将数据直接放进每一个枚举成员而不是将枚举作为结构体的一部分。`IpAddr` 枚举的新定义表明了 `V4` 和 `V6` 成员都关联了 `String` 值。

```rust
enum IpKind {
    V4(String),
    V6(String)
}

let home = IpKind::V4(String::from("127.0.0.1"));
let loopback = IpKind::V6(String::from("::1"));
```

直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体。**这样定义的枚举成员的名字也变成了一个构建枚举实例的构造函数**，即 `IpAddr::V4()` 是一个获取 `String` 参数并返回 `IpKind` 类型实例的函数调用。作为定义枚举的结果，这些构造函数会自动被定义。

用枚举替代结构体还可以使每个成员可以处理不同类型和数量的数据。若想要将 `V4` 地址存储为四个 `u8` 值而 `V6` 地址仍然表现为一个 `String`，这样就不能使用结构体。

```rust
enum IpKind {
    V4(u8, u8, u8, u8),
    V6(String)
}

let home = IpKind::V4(127, 0, 0, 1);
let loopback = IpKind::V6(String::from("::1"));
```

可以将任意类型的数据放入枚举成员中：字符串、数字类型、结构体和枚举等。

枚举成员还可以为多种类型。

```rust
enum Message {
    Quit,
    Move { x: u32, y: u32 },
    Write(String),
    Color(u8, u8, u8)
}
```

这个枚举有四个含有不同类型的成员：

-   `Quit` 没有关联任何数据；
-   `Move` 包含一个匿名结构体；
-   `Write` 包含一个 `String；`
-   `Color` 包含三个 `u8`。

使用结构体也可以定义但不够简洁。

```rust
struct QuitMessage;                   // 类单元结构体
struct MoveMessage { x: u32, y: u32 }  
struct WriteMessage(String);          // 元组结构体
struct ColorMessage(u8, u8, u8);      // 元组结构体
```

枚举也可以像使用 `impl` 来为结构体定义方法那样，在枚举上定义方法或关联函数。

```rust
impl IpAddr {
	fn localhost_v4() -> IpAddr {
		IpAddr::V4(127, 0, 0, 1)
	}

	fn info(&self) {
		println!("{:?}", self);
	}
}

let ip = IpAddr::localhost_v4();
ip.info();
```

使用 `self` 来获取调用方法的值。

### Option 枚举

`Option` 是标准库定义的另一个枚举。

空值是一个值，它代表没有值。在有空值的语言中，变量总是这两种状态之一：空值和非空值。空值的问题在于当尝试像非空值那样使用空值，会出现某种形式的错误。

**Rust 没有空值**，不过它拥有一个可以编码存在或不存在概念的枚举。这个枚举是 `Option<T>`，它定义于标准库中。

```rust
enum Option<T> {
    Some(T),
    None
}
```

`Option<T>` 枚举是被包含在了 **prelude** 之中，不需要将其显式引入作用域。它的成员也不需要 `Option::` 前缀，可直接使用 `Some` 和 `None`。

`<T>` 语法是代表它是一个泛型类型参数，意味着 `Option` 枚举的 `Some` 成员可以包含任意类型的数据。

```rust
let some_number = Some(5);
let some_string = Some("a string");
let absent_number: Option<i32> = None;
```

若使用 `None` 而不是 `Some`，需要告诉 Rust `Option<T>` 是什么类型的，因为编译器只通过 `None` 值无法推断出 `Some` 成员保存的值的类型。

当有一个 `Some` 值时，就知道存在一个值，而这个值保存在 `Some` 中。当有个 `None` 值时，它跟空值具有类似的含义。

---

因为 `Option<T>` 和 `T` 是不同的类型，编译器不允许像一个肯定有效的值那样使用 `Option<T>`。如这段代码不能编译，因为它尝试将 `Option<i8>` 与 `i8` 相加：

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);
let sum = x + y;    // 错误
```

Rust 不知道该如何将 `Option<i8>` 与 `i8` 相加，因为它们的类型不同。当在 Rust 中拥有一个像 `i8` 这样类型的值时，编译器确保它总是有一个有效的值，可以直接使用而无需做空值检查。只有当使用 `Option<i8>`（或者任何用到的类型）的时候需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。

在对 `Option<T>` 进行 `T` 的运算之前必须将其转换为 `T`，因此哪怕类型相同，`Option<T>` 之间也是不能直接运算。

```rust
Some(1) + Some(2);  // 错误
```

通常这能捕获到空值最常见的问题之一：假设某值不为空但实际上为空的情况。Rust 通过限制空值的泛滥以增强 Rust 代码的安全性。

## 实现

## 方法

方法与函数类似：使用 `fn` 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数不同的是，它在结构体（枚举、trait）的上下文中被定义，且第一个参数总是 `self`，它代表调用该方法的实例。

```rust
struct Rect {
    width: u32,
    height: u32
}

impl Rect {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect = Rect { width: 2, height: 3 };
    println!("{}", rect.area());
}
```

为了使函数定义于 `Rect` 的上下文中，定义了一个 `impl` 块。将计算面积的函数移动到 `impl` 中，并将签名中的第一个参数和函数体中其他地方的对应参数改成 `self`，然后在先前 `main` 中调用 `area` 函数并传递 `rect` 作为参数的地方，改成使用**方法语法**在 `Rect` 实例上调用 `area` 方法。方法语法获取一个实例并加上一个点号，后跟方法名、圆括号以及任何参数。

在 `area` 的签名中，使用 `&self` 来替代 `rect: &Rect`，因为该方法位于 `impl Rect` 上下文中，所以 Rust 知道 `self` 的类型是 `Rect`，但仍然需要在 `self` 前面加上 `&`。

`&self` 实际上是 `self: &Self` 的缩写。在一个 `impl` 块中，`Self` 类型是 `impl` 块的类型的别名。方法的第一个参数必须有一个名为 `self` 的`Self` 类型的参数，因此以下例子是等价的：

```rust
fn area(&self) {}
fn area(self: &Rect) {}
fn area(self: &Self) {}
```

>   只要第一个参数名为 self，就代表了实例本身。

---

方法可以选择获取 `self` 的所有权、不可变或可变地借用 `self`。选择 `&self` 的理由是并不获取其所有权，只需能够读取结构体中的数据，而不用写入。若想要在方法中修改调用方法的实例，需要将第一个参数改为 `&mut self`。

通过仅仅使用 `self` 作为第一个参数来使方法获取实例的所有权是很少见的，这种技术通常用在当方法将 `self` 转换成别的实例的时候，这时可以防止调用者在转换之后继续使用原始的实例。

使用方法替代函数，除了可使用方法语法和不需要在每个函数签名中重复 `self` 的类型之外，其主要好处在于组织性。将某个类型实例能做的所有事情都一起放入 `impl` 块中，而不是在库中到处寻找 `Rect` 的功能。

---

字段与方法的名字可以相同：

```rust
fn width(&self) -> u32 { self.width } 
```

编译器可以判断出其对应的功能，当使用 `object.width` 时，为使用字段，当使用 `object.width()` 是，为使用方法，这种一般用于获取字段的值，即有些语言中的 `get` 方法。

## 关联函数

`impl` 块的另一个的功能是：允许在 `impl` 块中定义**不**以 `self` 作为参数的函数，这被称为**关联函数**，因为它与结构体相关联。关联函数仍是函数而不是方法，因为它**并不作用于一个结构体的实例， 而是作用于类型**，如 `String::from` 就是关联函数。关联还是可以看作是类型的方法而不是实例的方法，在有些语言中被称为**静态方法**。

关联函数经常被用作构造函数，以返回一个结构体新实例。

```rust
#[derive(Debug)]
struct Point {
    x: u32,
    y: u32
}

impl Point {
    fn dot(&self, other: &Point) -> u32 {
        self.x * other.x + self.y * other.y
    }
    
    fn new(x: u32, y: u32) -> Self {
        Point { x, y }
    }
}

fn main() {
    let p1 = Point::new(2, 3);
    let p2 = Point::new(3, 6);
    println!("{}", p1.dot(&p2));
    println!("{:#?}", (&p1).dot(&p2));
}
```

使用结构体名和 `::` 语法来调用这个关联函数。这个方法位于结构体的命名空间中，`::` 语法用于关联函数和模块创建的命名空间。

## 多个参数和 impl 块

方法可以拥有多个参数或者多个 `impl` 块，当有多个参数时，第一个参数必须是 `self`、`&mut self` 或 `self`。

```rust
#[derive(Debug)]
struct Point {
    x: u32,
    y: u32
}

impl Point {
    fn dot(&self, other: &Point) -> u32 {
        self.x * other.x + self.y * other.y
    }
}

impl Point {
    fn add(&self, other: &Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y
        }
    }
}
```

不过若多个 `impl` 是同一个结构体的方法，可以合并到同一个 `impl` 块中。

```rust
impl Point {
    fn dot(&self, other: &Point) -> u32 {
        self.x * other.x + self.y * other.y
    }

    fn add(&self, other: &Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y
        }
    }
}
```

## 自动引用和解引用

在 C / C++ 语言中，有两个不同的运算符来调用方法：`.` 直接在对象上调用方法，而 `->` 在一个对象的指针上调用方法，这时需要先解引用指针。如 `object` 是一个指针，那么 `object->method()` 等同于 `(*object).method()`。

Rust 并没有一个与 `->` 等效的运算符，但有**自动引用和解引用**。方法调用是 Rust 中少数几个拥有这种行为的地方。

当使用 `object.method()` 调用方法时，Rust 会自动为 `object` 添加 `&`、`&mut` 或 `*` 以使 `object` 与方法签名匹配。

```rust
let p1 = Point { x: 2, y: 3 };
let p2 = Point { x: 3, y: 4 };
println!("{}", p1.dot(&p2));
println!("{:#?}", (&p1).add(&p2));
```

两个 `println!` 宏中的 `p1`、`(&p1)` 实际上是等价的。这种自动引用的行为之所以有效，是因为方法明确的接收 `&self` 类型。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是 `&self`、`&mut self` 或 `self`。



# 模式匹配

## match 控制流运算符

`match` 为 Rust 中极为强大的控制流运算符，它允许将一个值与一系列的模式相比较并根据相匹配的模式执行相应代码。模式可由字面值、变量、通配符和许多其他内容构成。Rust 确保所有可能的情况都能得到处理。

```rust
enum Size {
   S,
   M,
   L,
   X
}

fn size_value(size: Size) -> u32 {
    match size {
        Size::S => 1,
        Size::M => 2,
        Size::L => 3,
        Size::X => {
            println!("X!");
            4
        }
    }
}
```

`match` 关键字后跟一个表达式，在这里是 `size` 的值。和 `if` 的区别是：`if` 表达式必须为布尔值，而 `match` 可以是任意类型。

接下来是 `match` 的分支。一个分支有两个部分：**模式**和**代码**。第一个分支的模式是值 `Size::S` 而之后的 `=>` 运算符将模式和将要运行的代码分开。每一个分支之间使用逗号分隔。

可以拥有任意多的分支，当 `match` 表达式执行时，它将结果值按顺序与每一个分支的模式相比较。若模式匹配了这个值，这个模式相关联的代码将被执行，并结束匹配；若模式并不匹配这个值，将继续执行下一个分支。

每个分支相关联的代码是一个表达式，而表达式的结果将作为整个 `match` 表达式的返回值，每个分支返回值类型都必须相同。

分支代码较短的话通常不使用大括号。若想要在分支中运行多行代码，可以使用大括号，大括号内最后一个表达式的值作为这条分支的值。

### 绑定值的模式

匹配分支的还可以绑定匹配的模式的部分值。

```rust
enum Size {
   S,
   M,
   L,
   X(Special)
}

enum Special {
    X,
    XL,
    XXL,
    XXXL
}

fn size_value(size: Size) -> u32 {
    match size {
        Size::S => 1,
        Size::M => 2,
        Size::L => 3,
        Size::X(state) => {
            match state {
                Special::X => 4,
                Special::XL => 5,
                Special::XXL => 6,
                Special::XXXL => 7
            }
        }
    }
}
```

在这些匹配表达式中，匹配 `Size:X` 成员的分支的模式中增加了一个叫做 `state` 的变量。当匹配到此分支时，继续通过 `match` 来匹配 `state` 的值，`state` 最终将绑定到 `Special` 枚举中的某个成员所对应的值。

### 匹配的所有权

如下代码不能通过编译：

```rust
let s = Some(String::from("hello"));
match s {
    Some(v) => println!("{v}"),
    None => println!("Nothing"),
}
println!("{:?}", s);    // 错误，s 中的值已经移动到 v
```

由于在进行匹配时，`Some(v)` 中的 `v` 会获得 `s` 中 `String` 的所有权，`s` 中的一部分被移动了，因此在之后 `s` 就不能继续使用整体，要在后续也能够使用，需要在匹配时获取一个引用，或者只使用没有被移动的部分。

#### 部分移动

可以移动一个变量的一部分，称为**部分移动**，这表示变量的某些部分将被移动，而其他部分将保留。在这种情况下，之后的代码不能使用变量的整体，但可以使用没有移动的部分。

通过 `ref` 关键字可以获得解构后的引用而不获取所有权：

```rust
struct Person {
    first_name: String,
    last_name: String,
}

let p = Person {
    fname: String::from("AAA"),
    lname: String::from("BBB"),
};

let Person {
    ref fname,  // 解构成一个引用
    lname,
} = p;

println!("{}", p.first_name);  // 正确
println!("{}", p.last_name);   // 错误
```

类似的使用 `ref mut` 获得一个可变引用：

```rust
let mut s = Some(5);
match s {
    Some(ref mut v) => *v += 1,
    _ => (),
}
println!("{:?}", s);
```

`ref` 通常用在要匹配的对象没有所有权的时候：

```rust
fn main() {
    let s = Some(String::from("hi"));
    print_s(&s);
}

fn print_s(s: &Option<String>) {
    match *s {
        Some(ref v) => println!("{}", v),
        None => println!("Nothing"),
    }
}
```

`print_s` 函数接收一个引用 `&T`，因此并没有这个参数的所有权，当对其进行解引用后，匹配中的类型变为 `T`，但不能对引用的对象获得所有权，因此必须对 `v` 使用 `ref` 修饰，否则无法通过编译。

>   `ref` 和 `&` 都在模式匹配中使用，但是前者不是模式的一部分，而后者是模式的一部分。`ref` 仅表示获得值的一个引用，而不获取所有权。

### 匹配 Option\<T\>

可以像处理枚举那样使用 `match` 处理 `Option<T>`。

```rust
fn main() {
    let x = plus_one(Some(5));
    let y = plus_one(None);
    println!("{:?}", x);
    println!("{:?}", y);
}

fn plus_one(x: Option<u32>) -> Option<u32> {
    match x {
        Some(i) => Some(i + 1),
        None => None
    }
}
```

该函数获取一个 `Option<u32>`，若其中有值，则加 1；若其中没有值，则返回 `None`。

### 匹配是穷尽的

```rust
match x {
    Some(i) => Some(i + 1)    // 错误
}
```

由于没有处理 `None` 的情况，所以不能通过编译。

Rust 中的**匹配是穷尽的**：必须穷举到最后的可能性来使代码有效。特别在使用 `Option<T>` 时，为了防止忘记明确的处理 `None` 的情况，这样可以避免使用实际上为空的值。

### 通配符

Rust 提供了一个模式用于不想列举出所有可能值的场景：使用 `_` 通配符。

```rust
let x = Some(1);
match x {
    Some(i) => Some(i + 1),
    _ => None
};
```

`_` 模式会匹配所有没有指定的可能的值，通常将其放置于其他分支之后。

```rust
let x = 1;
match x {
    1 => println!("one"),
    _ => ()
};
```

`()` 是单元值，所以 `_` 的情况什么也不会发生。

## if let 控制流

若只匹配一种情况，为了满足 `match` 表达式穷尽性的要求，必须在处理完这唯一的成员后使用 `_` 通配符。

`if let` 语法用来处理只匹配一个模式的值而忽略其他模式的情况。

```rust
let x = Some(1);
if let Some(3) = x {
    println!("{:?}", x);
}
else {
    println!("Others");
};
```

`if let` 获取通过 `=` 分隔的一个模式和一个表达式。它的工作方式与 `match` 相同，这里的表达式对应 `match` 而模式则对应第一个分支。使用 `if let` 可以编写更少的代码，但会失去 `match` 强制要求的穷尽性检查。

还可以在 `if let` 中包含一个 `else`，`else` 块中的代码与 `match` 表达式中的 `_` 分支块中的代码相同，这样的 `match` 表达式就等同于 `if let` 和 `else`。

由于 `if let` 本身也是一个表达式，因此可以返回值。当作为返回值使用时，必须保证隐含的 `else` 和返回的类型是相同的，或者显示指定 `else` 的返回值，某则默认的返回值为 `()`。

```rust
let x = Some(5);
let y = if let Some(i) = x {
    Some(i + 1)
} else {
    None
};
```

# 5 函数和闭包

## 函数

函数以 `fn` 定义，类型表示为 `fn(T, U, ..) -> R`，函数类型都实现了 `FnOnce`、`FnMut`、`Fn`、`Copy`、`Clone`、`Send` 和 `Sync` trait。

```rust
fn add(x: i32, y: i32) -> i32 {
    x + y
}
```

当函数的第一个参数带有 `self`，则是在 trait 或 impl 中的方法。

```rust
trait T {
    fn foo(&self);
}

struct S;
impl S {
    fn foo(&self) {}
}
```

对于 `extern` 块，可在最后一个参数使用 `...` 来表示可变参数。

```rust
extern "C" {
    fn foo(x: i32, ...);
    fn with_name(format: *const u8, args: ...);
}
```

函数也可以作为函数指针来赋值或传递参数。

```rust
fn add(x: i32, y: i32) -> i32 {
    x + y
}

fn get_add(x: i32, y: i32, f: fn(i32, i32) -> i32) {
    f(x, y);
}

fn main() {
    let f = add;
    get_add(1, 2, f);
}
```

### 常量函数

常量函数为在编译期执行的函数，通过 `const` 定义，必须是**纯函数**，也不能包含如堆分配这样的运行时操作。

```rust
const fn read_header(buf: &[u8]) -> (u8, u8, u8, u8) {
    (buf[0], buf[1], buf[2], buf[3])
}

const FILE_HEADER: (u8, u8, u8, u8) = read_header(include_bytes!("test.txt"));
```

### 参数属性

函数参数也可以有属性。

```rust
fn len(
    #[cfg(linux)]
    slice: &[u8],
    #[cfg(not(linux))]
    slice: &[u16]
) -> usize {
    slice.len()
}
```

## 什么是闭包

**闭包**是可以保存进变量、作为参数传递给其他函数或作为返回值的**匿名函数**。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。

## 函数重复调用

```rust
fn calc(x: i32) -> i32 {
    x + 1
}

fn run(n: i32) {
    if n < 10 {
        println!("{}", calc(n));
        println!("{}", calc(n));
    } else if n < 20 {
        println!("{}", calc(n));
    } else if n < 30 && n % 3 == 0 {
        println!("{}", calc(n));
    } else {
        println!("Do nothing");
    }
}
```

`calc` 函数用来模拟一些十分耗时的运算，这里简单返回参数值加一。`run` 函数用来模拟根据不同情况执行实际的运算。可以看到，这里有多处调用了 `calc` 函数。第一个 if 块调用了 2 次，第二个和第三个分别调用了 1 次，最后一个没有调用。

这里有两处问题：

-   第一个 if 块做了 2 次调用，但实际只需要 1 次；
-   多个 if 块中都进行了相同的调用，可以简化。

### 重构函数

首先可以将函数调用的返回值保存到一个变量中，之后直接传递变量值即可，如下：

```rust
fn run(n: i32) {
    let result = calc(n);
// --snip--
}
```

但这里还有一个问题，若 `n` 的值一开始就满足最后一个 if 块，那么就会做一次不必要的计算，而且若某个函数调用所传递的参数有所改变，那么变量保存的值则不能通用。

理想情况是，若参数相同，那么所需要的函数只需要调用一次，且只会在真正使用的时候才执行计算，这时候可以使用闭包。

## 定义闭包

闭包就是一个匿名函数，可以保存在变量中，这里可以将 `calc` 函数改写为闭包的形式：

```rust
fn run(n: i32) {
    let calc = |x| x + 1;
// --snip--
}
```

闭包的定义以一对竖线 `||` 开始，在竖线中指定闭包的参数，若有多个参数，则用逗号分隔，如 `|param1, param2|`。

参数之后是存放闭包体的大括号，若闭包体只有一行则大括号可以省略。大括号之后闭包的结尾，需要用于 `let` 语句的分号。因为闭包体的最后一行没有分号，所以闭包体最后一行的值作为调用闭包时的返回值。

```rust
let foo = |param| {
    println!("{}", param);
    param + 1
};
```

>   `let` 语句表示 `calc` 包含一个匿名函数的**定义**，而不是**返回值**。

定义了闭包之后，就可以像函数那样调用值。

```rust
calc(1);
foo(2);
```

## 闭包类型推断和注解

闭包不用像函数那样在参数和返回值上注明类型。函数中需要类型注解是因为需要作为接口给外部调用，因此需要严格定义。但闭包是在局部范围内使用，不用命名或作为接口。

闭包通常很短，只关联小范围的上下文。在这些有限制的上下文中，编译器可推断出参数和返回值的类型。

但也可以显式标注出类型：

```rust
|param1: i32, param2: i32| -> i32 {}
```

闭包语法和函数语法十分类似，除了使用竖线而不是括号以及几个可选的语法之外：

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

第一行展示了一个函数定义，而第二行展示了一个完整标注的闭包定义。第三行闭包定义中省略了类型注解，而第四行闭包体只有一行，因此去掉了可选的大括号。这些都是有效的闭包定义，并在调用时产生相同的行为。

>   当省略类型标注时，必须在上下文中给出能够让编译器推断出类型的信息。

---

闭包定义会为每个参数和返回值推断一个具体类型：

```rust
let c = |x| x;
let s = example_closure(String::from("hello"));
let n = example_closure(5);    // 报错
```

第一次使用时，已经推断出闭包的类型，因此第二次使用不同的参数类型就会报错。

---

每个定义的闭包都是唯一的类型，即使签名相同：

```rust
let c1 = |x: i32| -> i32 {x + 1};
let c2 = |x: i32| -> i32 {x + 1};
```

这两个闭包虽然签名相同，但类型是不同的。

## Fn trait

闭包周围的作用域被定义为其所处的**环境**，因此闭包除了能够作为内联匿名函数来使用外，和函数有一个最大的区别：**可以捕获环境中的值**。

```rust
fn main() {
    let x = 3;
    let equal_to_x = |n| n == x;
    assert!(equal_to_x(3));
}
```

即使 `x` 并不是 `equal_to_x` 闭包的一个参数，也被允许使用变量 `x`，因为它与 `equal_to_x` 定义于相同的作用域。

函数则不行，这样做将无法通过编译：

```rust
// 错误
fn main() {
    let x = 3;
    fn equal_to_x(n: i32) -> bool {
        n == x
    }
    assert!(equal_to_x(3));
}
```

---

当闭包从环境中捕获一个值，闭包会在闭包体中储存这个值，这会产生额外的内存开销，而函数不允许捕获环境，因此定义和使用函数也就没有这些额外开销。

闭包可以通过三种方式捕获其环境，对应函数的三种获取参数的方式：

-   获取所有权；

-   可变借用；

-   不可变借用。

这三种捕获值的方式对应三个 `Fn` trait：

-   `std::ops::FnOnce` 从环境获取值的所有权，因此该类闭包只能使用一次；
-   `std::ops::FnMut` 从环境获取值的可变的借用，因此可以改变其环境的值；
-   `std::ops::Fn` 从环境获取值的不可变的借用。

当定义一个闭包时，编译器会根据其如何使用环境中的值来推断如何引用环境的值：

-   由于所有闭包都可以被至少调用一次，因此所有闭包都实现了 `FnOnce` ；
-   没有获取被捕获值的所有权的闭包都实现了 `FnMut` ；
-   没有对被捕获值进行可变访问的闭包都实现了 `Fn` 。 

实际上，这三种闭包 trait 的限制程度依次增大，因为一个 `FnOnce` 闭包还可以接受 `&mut T` 和 `&T`，而一个 `Fn` 闭包则只能接受 `&T`。编译器会在满足使用需求的前提下尽量以限制最多的方式捕获。

---

`Fn` 系列 trait 由标准库提供，所有的闭包都自动实现了 `FnOnce`、`FnMut` 或 `Fn` 中的一个。

>   函数也都实现了这三个 `Fn` trait，若不需要捕获环境中的值，则可以使用实现了 `Fn` trait 的闭包，或者直接使用函数。

上面的代码中，由于 `equal_to_x` 闭包不可变的借用了 `x`，所以 `equal_to_x` 具有 `Fn` trait。

---

```rust
let mut s = String::from("hello");
let mut add_suffix = || s.push_str(" world");
println!("{s}");  // 错误
add_suffix();
```

`add_suffix` 这个闭包可变的借用了 `s`，因此具有 `FnMut` trait，且需要加上 `mut` 关键字。

这里由于 `s` 已经被闭包可变的借用了，因此 `println!` 会报错，因为它会不可变的借用。

---

若需要强制闭包获取其捕获值的所有权，可以使用 `move` 关键字，这个技巧通常用在将闭包传递给新线程以便将数据移动到新线程中时。

```rust
let s = String::from("hello");
let equal_to_s = move |n| s == n;
println!("{}", s);    // 此处 s 已失效
assert!(equal_to_s(String::from("hello")));
```

>   简单类型由于实现了 `Copy` trait，就算使用了 `move` 关键字，闭包获取的也只是值的拷贝，因此需要使用像 `vector`、`String` 这样的类型。

---

```rust
let f = |_| ();
let s = String::from("hello");
f(s);
```

这里，由于 `f` 没有捕获环境的值，因此 `f` 具有 `Fn` trait，但是其参数会获取所有权，在闭包运行结束后，就 `s` 被立刻回收，因此该闭包相当于 `drop` 函数的作用。

## 闭包作为返回值

Rust 需要在编译期知道返回类型的大小，而匿名的闭包的类型是未知的，因此只有使用 `impl Trait` 才能返回一个闭包，返回闭包的有效 trait 是：`FnOnce`、`FnMut` 和 `Fn`。

此外，还必须使用 `move` 关键字，因为在离开函数作用域时，任何通过引用捕获的值都被丢弃。

```rust
fn ret_fnonce() -> impl FnOnce() {
    move || println!("FnOnce")
}

fn ret_fnmut() -> impl FnMut() {
    move || println!("FnMut")
}

fn ret_fn() -> impl Fn() {
    move || println!("Fn")
}

fn main() {
    let f_once = ret_fnonce();
    let mut f_mut = ret_fnmut();  // FnMut 必须加上 mut 关键字
    let f = ret_fn();
    f_once();
    f_mut();
    f();
}
```

## 带有泛型和 Fn trait 的闭包

回到 `run` 函数：

```rust
fn run(n: i32) {
    let calc = |x| x + 1;

    if n < 10 {
        println!("{}", calc(n));
        println!("{}", calc(n));
    } else if n < 20 {
        println!("{}", calc(n + 1));
    } else if n < 30 && n % 3 == 0 {
        println!("{}", calc(n + 1));
    } else {
        println!("Do nothing");
    }
}
```

将原来的 `calc` 函数定义成了一个闭包，然后再调用它，但这里第一个 if 块重复调用了两次，后面的 if 块分别调用了一次，且由于参数不同，因此不能简单的在开头使用变量来保存返回值。

### 惰性求值

可以定义一个存放闭包和调用闭包结果的结构体。该结构体只会在需要结果时执行闭包，并缓存结果值，之后的代码就可以直接使用该值，这种模式被称为**惰性求值**。

为了让结构体存放闭包，需要指定闭包的类型。由于每一个闭包都是一个唯一的类型，因此需要将闭包放在泛型中，并使用 trait bound 来约束闭包的签名。

```rust
struct Cacher<F>
where
    F: Fn(i32) -> i32,
{
    calc: F,
    value: Option<i32>,
}
```

这里创建了一个 `Cacher` 结构体，包含用来存放闭包的泛型字段 `calc` 和缓存值 `value`。`F` 的 trait bound 指定了 `F` 是一个使用 `Fn` 的闭包。任何储存到 `Cacher` 实例的 `calc` 字段的闭包必须有一个 `i32` 参数，且必须返回一个 `i32`。

字段 `value` 是 `Option<i32>` 类型的。在执行闭包前，`value` 为 `None`，这时使用 `Cacher` 的实现来请求闭包的结果，会执行闭包并将结果储存在 `value` 字段的 `Some` 成员中。当再次请求闭包的结果时，由于 `value` 字段不是 `None`，因此不执行闭包，而是返回存放在 `Some` 成员中的结果。

然后对 `Cacher` 进行实现：

```rust
impl<F> Cacher<F>
where
    F: Fn(i32) -> i32,
{
    fn new(calc: F) -> Self {
        Self { calc, value: None }
    }

    fn value(&mut self, arg: i32) -> i32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.calc)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
```

`Cacher::new` 函数获取一个闭包作为参数，类型为泛型参数 `F`，定义于 `impl` 块上下文中并与 `Cacher` 结构体有着相同的 trait bound。`Cacher::new` 返回一个在 `calc` 字段中存放了指定闭包和在 `value` 字段中存放了 `None` 值的 `Cacher` 实例，因为此时还未执行闭包。

当需要闭包的执行结果时，不同于直接调用闭包，而是调用 `value` 方法。这个方法会检查 `self.value` 是否已经有了一个 `Some` 的结果值，若存在，则返回 `Some` 中的值而不是再次执行闭包。

若 `self.value` 是 `None`，则会调用 `self.calc` 中存储的闭包，并将结果保存到 `self.value` 同时返回结果值。

然后就可以在 `run` 函数中定义并使用：

```rust
fn run(n: i32) {
    let mut closure_cache = Cacher::new(|x| x + 1);

    if n < 10 {
        println!("{}", closure_cache.value(n));
        println!("{}", closure_cache.value(n));
    } else if n < 20 {
        println!("{}", closure_cache.value(n + 1));
    } else if n < 30 && n % 3 == 0 {
        println!("{}", closure_cache.value(n + 1));
    } else {
        println!("Do nothing");
    }
}
```

不同于直接将闭包保存进变量，而是保存一个 `Cacher` 实例来存放闭包，接着可以在多个地方调用，但实际计算只会执行一次。

### Cacher 实现的限制

`Cacher` 实例对于 `value` 方法的任何 `arg` 参数的值都会返回相同的值：

```rust
let mut closure_cache = Cacher::new(|x| x);
// 都打印 1
println!("{}", closure_cache.value(1));
println!("{}", closure_cache.value(2));
println!("{}", closure_cache.value(3));
```

第一次调用后，由于 `Cacher` 实例将 `Some(1)` 保存进 `self.value`。在这之后无论传递什么参数调用 `value`，总是会返回 1。

---

可以通过再增加一个 `arg` 字段用来存放之前传递的参数，若再次调用的参数和之前的一致，则直接返回 `value` 字段的值，否则再次调用闭包，并将参数和结果保存。

```rust
struct Cacher<F>
where
    F: Fn(i32) -> i32,
{
    calc: F,
    value: Option<i32>,
    arg: Option<i32>,
}

impl<F> Cacher<F>
where
    F: Fn(i32) -> i32,
{
    fn new(calc: F) -> Self {
        Self {
            calc,
            value: None,
            arg: None,
        }
    }

    fn value(&mut self, arg: i32) -> i32 {
        match self.value {
            Some(v) => match self.arg {
                Some(a) => {
                    if a == arg {
                        v
                    } else {
                        let v = (self.calc)(arg);
                        self.value = Some(v);
                        self.arg = Some(arg);
                        v
                    }
                }
                None => v,
            },
            None => {
                let v = (self.calc)(arg);
                self.value = Some(v);
                self.arg = Some(arg);
                v
            }
        }
    }
}
```

这种做法显得十分繁琐，且含有重复代码，更好的做法是使用哈希 map 来存放值。将 `arg` 作为 key，而闭包调用的结果作为 value，这样只需要使用 `entry` 和 `or_insert` 方法即可实现相同的功能。

```rust
struct Cacher<F>
where
    F: Fn(i32) -> i32,
{
    calc: F,
    value: HashMap<i32, i32>,
}

impl<F> Cacher<F>
where
    F: Fn(i32) -> i32,
{
    fn new(calc: F) -> Self {
        Self {
            calc,
            value: HashMap::new(),
        }
    }

    fn value(&mut self, arg: i32) -> i32 {
        *self.value.entry(arg).or_insert((self.calc)(arg))
    }
}
```

## 闭包原理

Rust 中的闭包是通过一个特殊的结构体实现的。具体来说，每个闭包都是一个结构体对象，其中包含了闭包的代码和从环境中捕获的变量。这个结构体对象实现了一个或多个 `Fn` trait，以便可以像函数一样使用它。当定义一个闭包时，编译器会根据闭包的代码和捕获的变量生成一个结构体类型，这个结构体类型实现了对应的 trait。

如以下代码定义了一个闭包 `add_x` 并调用。

```rust
let x = 10;
let add_x = |y| x + y;
println!("{}", add_x(5));
```

编译时会将这个闭包转换为类似如下的结构体类型。

```rust
struct Closure {
    x: i32,
}

impl FnOnce<(i32,)> for Closure {
    type Output = i32;
    fn call_once(self, args: (i32,)) -> Self::Output {
        self.x + args.0
    }
}

impl FnMut<(i32,)> for Closure {
    fn call_mut(&mut self, args: (i32,)) -> Self::Output {
        self.x + args.0
    }
}

impl Fn<(i32,)> for Closure {
    extern "rust-call" fn call(&self, args: (i32,)) -> Self::Output {
        self.x + args.0
    }
}
```

当闭包被调用时，实际上是通过调用结构体的方法来执行的。

# 2 错误处理

Rust 有两种错误类别：**可恢复错误**和**不可恢复错误**。前者通常代表向用户报告错误并重试操作，如未找到文件。后者通常是 Bug，如尝试访问超过数组索引的位置。

其它语言通常不区分这两类，而是采用异常处理的方式。Rust 没有异常，但有可恢复错误 `Result<T, E>` 和不可恢复错误 `panic!`。

## panic! 与不可恢复错误

当执行 `panic!` 宏时，会打印出错误信息，展开并清理栈数据，然后退出。出现这种情况的场景通常是检测到一些类型的 Bug，而程序并不清楚该如何处理。

当出现 panic 时，程序默认会进行**栈展开**。Rust 会回溯栈并清理它遇到的每一个函数的数据。另一种是直接**终止**，这会不清理数据就退出程序，程序所使用的内存由操作系统来清理。通过在 *Cargo.toml* 的 `[profile]` 部分增加 `panic = "abort"`，可在 panic 时由栈展开切换为终止。

```toml
[profile.release]
panic = "abort"
```

**文件：main.rs**

```rust
panic!("Crash here!");
```

输出包含 `panic!` 调用造成的错误信息。第一行显示了 panic 提供的信息并指明了源码中 panic 出现的位置。

```rust
thread 'main' panicked at 'Crash here!', src\main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
error: process didn't exit successfully: 
```

在这个例子中，被指明的那一行是代码的一部分，且查看这一行的话会发现 `panic!` 宏的调用。在其他情况下，`panic!` 可能会出现在代码所调用的代码中。错误信息报告的文件名和行号可能指向其它代码中的 `panic!` 宏调用，而不是此代码中最终导致 `panic!` 的那一行。

### 使用 panic! 的 backtrace

可以通过 panic 时，被调函数的 backtrace 来寻找具体出问题的地方。

```rust
let v = vec![1, 2, 3];
v[9];
```

尝试访问 vector 的第 10 个元素，越界会导致 panic。`[]` 应当返回一个元素，若传递了一个无效索引，则没有可供 Rust 返回的正确的元素。

通过设置环境变量来设置 backtrace：

```shell
# Windows Powershell
$env:RUST_BACKTRACE=1; cargo run

# Windows CMD
set RUST_BACKTRACE=1 && cargo run

# Linux
RUST_BACKTRACE=1 cargo run
```

然后就可以看到带有 backtrace 的错误信息：

```
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 9', src\main.rs:3:5
stack backtrace:
   0: std::panicking::begin_panic_handler
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a\/library\std\src\panicking.rs:498 
   1: core::panicking::panic_fmt
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a\/library\core\src\panicking.rs:116
   2: core::panicking::panic_bounds_check
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a\/library\core\src\panicking.rs:84
   3: core::slice::index::impl$2::index<i32>
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a\library\core\src\slice\index.rs:189
   4: core::slice::index::impl$0::index<i32,usize>
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a\library\core\src\slice\index.rs:15
   5: alloc::vec::impl$15::index<i32,usize,alloc::alloc::Global>
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a\library\alloc\src\vec\mod.rs:2520
   6: exp::main
             at .\src\main.rs:3
   7: core::ops::function::FnOnce::call_once<void (*)(),tuple$<> >
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a\library\core\src\ops\function.rs:227
```

在 Debug 下才能获取带有这些信息的 backtrace，其中第 6 个指向了 *src/main.rs* 的第 3 行，可以根据这些回溯信息来定位错误。

## Result 与可恢复的错误

大部分错误并没有严重到需要程序完全停止执行。Rust 中有一个 `Result` 枚举，定义有 `Ok` 和 `Err` 这两个成员：

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`T` 和 `E` 是泛型类型参数，`T` 代表成功时返回的 `Ok` 成员中的数据类型，而 `E` 代表失败时返回的 `Err` 成员中的数据类型。因此可以将 `Result` 类型和标准库中为其定义的函数用于多种场景，这些情况中需要返回的成功值和失败值可能会各不相同。

```rust
use std::fs::File;

fn main() {
    let f = match File::open("hello.txt") {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}
```

这里使用 match 表达式来处理 `File::open` 所返回的值，该函数会打开一个文件，并返回一个 `Result<T, E>`。泛型参数 `T` 表示成功值的类型 `std::fs::File`，失败值 `E` 的类型是 `std::io::Error`。`Result` 枚举可以提供这些信息，成功则返回一个包含文件句柄的 `Ok` 实例，失败则返回错误信息的 `Err` 实例，如文件不存在或没有访问权限等。

### 匹配不同的错误

大部分情况下并不是任何错误都将程序 panic，而是根据错误类型来进行不同的处理方式，因此可以用 `match` 表达式匹配不同的错误。

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = match File::open("hello.txt") {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            _ => panic!("Problem opening the file: {:?}", error),
        },
    };
}
```

`File::open` 返回的 `Err` 成员中的值类型 `io::Error`，它是一个标准库中提供的结构体。这个结构体有一个返回 `io::ErrorKind` 值的 `kind` 方法可供调用。`io::ErrorKind` 是一个标准库提供的枚举，它的成员对应 `io` 操作可能导致的不同错误类型。这里只处理 `ErrorKind::NotFound`，表示文件并不存在。

内层 `match` 中检查的条件是 `error.kind()` 的返回值是否为 `ErrorKind`的 `NotFound` 成员。如果是，则尝试通过 `File::create` 创建文件。但创建文件也可能会失败，因此还需要再增加一个内层 `match`。当文件不能被打开，会打印出一个不同的错误信息。外层 `match` 的最后一个分支保持不变，这样对任何除了文件不存在的错误会使程序 panic。

### unwrap 和 expect

频繁的使用 `match` 会显得十分冗长而繁琐。`Result<T, E>` 类型定义了很多辅助方法来处理各种情况。其中之一叫做 `unwrap`，若 `Result` 值是成员 `Ok`，`unwrap` 会返回 `Ok` 中的值。若 `Result` 是成员 `Err`，`unwrap` 会直接调用 `panic!`。

```rust
let f = File::open("hello.txt").unwrap();
```

发生错误时 `unwrap` 会直接导致 panic，且没有额外的错误信息。此时可以使用 `expect`，它的行为与 `unwrap`，但可以提供额外的信息。

```rust
let f = File::open("hello.txt").expect("Failed to open hello.txt");
```

>   当使用 unwrap 或 expect 时，就相当于不管发生什么类型的错误，都只会发生 panic，而不是根据错误类型来进行处理。

### 传播错误

当一个函数可能会发生错误时，除了在这个函数中处理外，还可以选择让调用者来处理，称为**传播错误**。这样能更好的控制代码调用，因为调用者可能比被调用者拥有更多信息或逻辑来决定应该如何处理错误。

要传播错误，可以将错误返回：

```rust
use std::fs::File;
use std::io::{self, Read};

fn main() {
    let s = read_content("hello.txt").unwrap();
    println!("{}", s);
}

fn read_content(path: &str) -> Result<String, io::Error> {
    let mut f = match File::open(path) {
        Ok(file) => file,
        Err(error) => return Err(error),
    };

    let mut s = String::new();
    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}
```

该函数返回一个 `Result<String, io::Error>` 类型的值。若没有任何错误并成功返回，则调用者会收到一个包含 `String` 的 `Ok` 值。若遇到任何错误，则调用者会收到一个包含 `io::Error` 的 `Err` 值。`File::open` 和 `read_to_string` 都返回 `io::Error` 类型的错误值。

接着使用 `match` 处理 `File::open` 返回的 `Result`。如果错误，则返回 `Err` 实例。`read_to_string` 方法也返回一个 `Result`，同样使用 `match` 来处理。

### 简化传播错误

使用传播错误的模式十分常见，因此 Rust 提供了 `?`  运算符来简化。

```rust
fn read_content(path: &str) -> Result<String, io::Error> {
    let mut f = File::open(path)?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}
```

`Result` 值之后的 `?` 运算符被定义为与使用 `match` 表达式有着完全相同的处理方式。若 `Result` 的值为 `Ok`，则会返回 `Ok` 中的值而程序将继续执行。若值为 `Err`，则使用 `Err` 作为返回值从函数中提前返回。

与使用 `match` 不同的是，`?` 运算符所使用接收的错误值被传递给了 `from` 函数，它定义于标准库的 `From` trait 中，其用来将错误从一种类型转换为另一种类型。当 `?` 运算符调用 `from` 函数时，收到的错误类型被转换为**由当前函数返回类型所指定的错误类型**。这在当函数返回单个错误类型来代表所有可能失败的方式时十分有效，即使其可能会因很多种原因失败。只要每一个错误类型都实现了 `from` 函数来定义如何将自身转换为返回的错误类型，`?` 运算符会自动处理这些转换。

还可以在 `?` 之后使用链式方法调用来进一步简化代码：

```rust
fn read_content(path: &str) -> Result<String, io::Error> {
    let mut s = String::new();
    File::open(path)?.read_to_string(&mut s)?;
    Ok(s)
}
```

`File::open(path)?` 直接链式调用了 `read_to_string`。仍然需要 `read_to_string` 调用结尾的 `?`，而且当 `File::open` 和 `read_to_string` 都成功没有失败时返回包含用户名 `s` 的 `Ok` 值。

---

将文件读取到一个字符串是相当常见的操作，所以标准库提供了名为 `fs::read_to_string` 的函数，它会打开文件、新建一个 `String`、读取文件的内容，并将内容放入 `String` 并返回。

```rust
fn read_content(path: &str) -> Result<String, io::Error> {
    fs::read_to_string(path)
}
```

---

`?` 运算符只能被用于返回值与 `?` 作用的值相兼容的函数，因为 `?` 运算符被定义为从函数中提前返回一个值，如果要在 `main` 函数中使用，需要修改其返回值。`main` 函数是可执行程序的入口点和退出点，为了使程序能正常工作，可以返回的类型是有限制的，但可以返回 `Result<(), E>`。

```rust
fn main() -> Result<(), io::Error> {
    let f = File::open("hello")?;
    Ok(())
}
```

`?` 也可用于 `Option<T>` 值，同样只能在返回 `Option` 的函数中使用。在 `Option<T>` 上调用 `?` 运算符的行为与 `Result<T, E>` 类似：若值是 `None`，此时 `None` 会从函数中提前返回；若值是 `Some`，`Some` 中的值作为表达式的返回值，并继续执行。

```rust
fn plus_one(n: Option<i32>) -> Option<i32> {
    Some(n? + 1)
}
```

`?` 实际上就是 `try!` 宏的语法糖，两者都会尝试将错误类型转换为匹配返回的错误类型（前提是实现了 `From` trait），用 `match` 表达式的伪代码大致表示为：

```rust
macro try {
    match exp {
        Ok(val) => val,
        Err(err) => {
            let converted = From::from(err);
            return Err(converted);
        }
    }
}
```

>   目前 `try!` 已不常用。

