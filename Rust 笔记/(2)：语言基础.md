# 1 语言基础

## 标识符

-   由任意非空的，且非 emoji 的 Unicode 字符构成；
-   不能以数字开头，且不能为关键字；

-   当以下划线开头时，长度至少为 **2**；

-   单个 `_` 作为标识符表示**忽略**。

### 原始标识符

当和外部 FFI 进行交互时，如调用 C 库中名为 `match` 的函数。在 C 中 match 不是关键字，但在 Rust 中是关键字，因此需使用以 `r#` 开头的原始标识符。

```rust
let r#fn = "value";
r#match();
```

## 常量和变量

在 Rust 中，变量**默认是不可改变的**，但可以在变量名前加 `mut` 关键字来使其可变。当变量不可变时，一旦值被绑定一个标识符上，就不能改变这个值。

```rust
let x = 1;      // 不可变
let mut y = 3;  // 可变
```

`mut x` 是一个**模式**，可以用这种方式同时声明多个变量：

```rust
let (mut a, mut b) = (1, 2);
```

变量必须被初始化后才能使用：

```rust
let x: i32;       // 错误
println!("{x}");
```

不可变变量和常量是有区别的：

-   常量使用 `const` 关键字，且**必须注明值的类型**；
-   变量使用 `let` 关键字，可以在其前加上 `mut` 来使其可变，不能在 `const` 前加上 `mut` 来使其可变；
-   常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其它只能在运行时计算出的值；
-   常量可以在任何作用域中声明，包括全局作用域，而变量只能在函数作用域生效。

```rust
const MAX_POINTS: u32 = 10_000;
```

### 隐藏

可以定义一个与之前变量同名的新变量，而新变量会隐藏之前的变量。可以使用相同变量名称来隐藏一个变量，以及重复使用 `let` 关键字来多次隐藏。

```rust
let x = 1;
let x = x + 1;
let x = x * 2;
```

隐藏与将变量标记为 `mut` 是有区别的：当对变量重新赋值时，若没有使用 `let` 关键字，就会导致编译错误，通过使用 `let`，可以对这个值重新赋值，不过赋值后变量仍是不变的；当再次使用 `let` 时，实际上创建了一个新变量，可以改变值的类型，但复用这个名字。

函数也能够被隐藏：

```rust
fn main() {
    let sum = sum(1, 2);
    sum(3, 4);   // 错误，sum 函数在此刻不可用
}

fn sum(x: i32, y: i32) -> i32 {
    x * y
}
```

隐藏的对象只会在其作用域内起作用，当离开作用域时，外部被隐藏的项会恢复：

```rust
let v = 2;
{
    let v = 4;
    println!("{v}");   // 输出 4
}
println!("{v}");       // 输出 2
```

## 基本类型

Rust 是**静态类型**语言，编译器通常可以推断出类型。当多种类型均有可能时，必须增加**类型注解**。

```rust
let x: u32 = 10;
let y: f64 = 3.14;
```

每一个值都属于某种数据类型，Rust 有两类数据类型子集：**标量**和**复合**。

### 标量类型

标量类型代表一个单独的值。Rust 有四种基本的标量类型：**整型**、**浮点型**、**布尔类型**和**字符类型**。

#### 整型

| 长度    | 有符号 | 无符号 |
| ------- | ------ | ------ |
| 8 bit   | i8     | u8     |
| 16 bit  | i16    | u16    |
| 32 bit  | i32    | u32    |
| 64 bit  | i64    | u64    |
| 128 bit | i128   | u128   |
| arch    | isize  | usize  |

-   有符号数以**补码**形式存储；

-   `isize` 和 `usize` 类型依赖于运行程序的计算机架构。

| 数字字面值       | 例            |
| ---------------- | ------------- |
| Decimal          | `10_000`      |
| Hex              | `0xfe`        |
| Octal            | `0o77`        |
| Binary           | `0b1010_1000` |
| Byte (`u8` only) | `b'A'`        |

除 Byte 以外的所有数字字面值允许使用类型后缀，例如 `12_u8`，也允许使用 `_` 做为分隔符。

Rust 的默认数字类型默认是 `i32`。

---

对于整数溢出，当在 debug 模式编译时，Rust 检查这类问题并使程序 **panic**，即**程序因错误而退出**。

在 release 构建中，Rust 不检查溢出，而是会按照补码规则计算实际的值。

#### 浮点型

Rust 有两种原生的浮点类型，`f32` 单精度浮点数和 `f64` 双精度浮点数，遵循 [IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754) 标准，默认类型是 `f64`。

#### 算术运算

Rust 中的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取余。

```rust
let a = 1 + 11;
let b = 3 - 5.1;
let c = 3.14 * 2;
let d = 5 / 3;
let e = 10.8 / 4.4;
let f = 10 % 6;
let g = 6.6 % 2.4;
```

这些语句中的每个表达式都使用了数学运算符并计算出值，然后将值绑定到变量上。整数除法会直接**去掉小数部分**而不进行舍入。进行取余运算时，结果的**正负性只与被取余数的正负性有关**，此外还可以对浮点数进行取余运算，但是结果不一定精确。

数字还可以有方法，如将浮点型四舍五入为整数。

```rust
let n = 12.67_f32.round();  // n = 13
```

类型后缀是必需的，因为方法需要一个具体的类型。

#### 关系、逻辑和位运算

关系、逻辑和位运算的符号和方式和 C 基本相同。

#### 布尔型

布尔类型有两个可能的值：`true` 和 `false`，使用 `bool` 表示。

```rust
let x = true;
let y: bool = false;
if x == true {}
```

#### 字符类型

Rust 的 `char` 类型是语言中最原生的字符类型。

```rust
let a: char = 'a';
let b = '你';
let c = 'あ';
let d = 'Ω';
let e = '😅';
let f = '\u{102c0}';
```

`char` 由单引号指定，不同于字符串使用双引号。Rust 的 `char` 类型代表了一个 Unicode 标量值，拼音字母、中文、日文、韩文等字符，emoji 以及空白字符都是有效的 `char` 值。Unicode 标量值包含从 `U+0000` 到 `U+D7FF` 和 `U+E000`到 `U+10FFFF` 在内的值，一个 `char` 类型占据 **4** 个字节。

Unicode 中有一些字符是**零宽度字符**：它是一个字符，有 Unicode 编码，但是没有宽度。零宽度字符并不是 `''`，如 `let c = ''` 是不被允许的，因为 rust **没有空值**。

可以将字符值赋值给整型，但限制如下：

-   必须增加类型前缀 `b`；

-   只支持 `u8` 类型，即 Byte。

```rust
let n: u8 = b'A';   // 值为 65
```

### 复合类型

复合类型可以将多个值组合成一个类型。Rust 有两种原生的复合类型：**元组**和**数组**。

#### 元组类型

元组是将多个其它类型的值组合进一个复合类型的方式。列表中值的类型不一定相同，且长度固定，类型表示为 `(T, U, ..)`。

```rust
let tup: (i32, f64, u8) = (100, 2.1, 20);
```

`tup` 变量绑定到整个元组上，因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用**模式匹配**来解构元组值。

```rust
let tup = (100, 2.1, 20);
let (x, y, z) = tup;
println!("y = {y}");
```

首先创建了一个元组并绑定到 `tup` 变量上。接着使用了 `let` 和一个模式将 `tup` 分成了三个不同的变量：`x`、`y` 和 `z`，这叫做**解构**。

除了使用模式匹配解构外，还可以使用点号 `.` 后跟值的索引来直接访问。

```rust
let tup = (100, 2.1, 20);
let x = tup.0;
let y = tup.1;
let z = tup.2;
```

创建了一个元组并绑定到变量 `tup` 上，并使用索引为每个元素创建新变量，元组的第一个索引值是 0。

---

为了避免混淆，单个元素的元组需要在元素后面加一个逗号：

```rust
let t: (i32,) = (1,);
```

没有任何值的元组为 `()`，即**单元类型**类型，只有一个**单元值** 。如果表达式不返回任何其他值，则会隐式返回单元值。

```rust
let empty: () = ();
```

没有返回值的语句块，如没有定义返回值的函数，默认都会返回单元值。

```rust
fn foo() {}
let x = {};     // x = ()
let y = foo();  // y = ()
```

#### 数组类型

数组是将多个其它相同类型的值组合进一个复合类型的方式。列表中值的类型必须相同，且长度固定。

```rust
let arr: [i32; 5] = [1, 2, 3, 4, 5];
```

第一个中括号中有两部分由分号分隔的信息：第一部分是数组中每个元素的类型，第二部分表示数组长度，类型表示为 `[T; N]`。

若想创建一个每个元素都相同的数组，可以这样初始化：中括号内指定其初始值，后跟分号，再后跟数组的长度。

```rust
let arr = [0; 5];
```

数组是一整块分配在栈上的内存，可以使用索引来访问数组的元素。

```rust
let arr = [1, 2, 3, 4, 5];
let x = arr[0];
let y = arr[1];
```

当想要在栈而不是在堆上为数据分配空间时，或要确保总是有固定数量的元素时，可以使用数组。当使用索引对无效的数组元素进行访问时，Rust 会 panic。

### 字符串

## 原始字符串

以 `r` 或 `r#` 的形式来表示原始字符串，不会对字符进行转义。

```rust
let s1 = r"hello\t\nhello";
let s2 = r##"hello\t\nhello"##;
let s3 = r###"hello\t\nhello"###;
let s4 = r####"hello\t\nhello"####;
```

当使用 `r#` 的形式时，需要确保前后 `#` 的数量是一致的。

## 表达式和控制流

### if 表达式

`if` 表达式允许根据条件执行不同的代码分支。不同于其它语言，在 Rust 中，`if` 是表达式，它会返回一个值。所有 `if` 表达式的条件**必须是 `bool` 值**，以及包含一个可选的 `else` 表达式来提供一个在条件为假时应当执行的代码块，还可以将 `else if` 表达式与 `if` 和 `else` 组合来实现多重条件。

```rust
let mut x = 10;
x = if x < 3 {
    x + 1
} else if x < 6 {
    x + 2
} else {
    x + 3
};
```

由于 `if` 是一个表达式，可以把返回值绑定到一个变量上，且值的类型需要与绑定的变量类型相同。由于这是一个语句，需在最后加上一个分号。

### 循环

为了多次执行同一段代码，Rust 提供了三种循环：`loop`、`while` 和 `for`。

#### loop 循环

`loop` 关键字会重复的执行其代码块中的代码，直到遇到明确的停止循环指令，如可以在程序执行期间按 `Ctrl + C` 来终止程序，或在循环中使用 `break` 来提前跳出循环，使用 `continue` 来提前结束本次循环。

```rust
let mut x = 0;
let y = loop {
    x = x + 1;
    if x > 10 {
        break x;
    }
};
```

若在跳出循环后需要某个值可以在 `break` 后加上该值来从循环中返回值，并把值绑定到变量上，且在最后加上分号来使其成为一个语句。**只有 `loop` 能够使用 `break + 值` 的形式**。

---

若存在嵌套循环，则 `break` 和 `continue` 只能作用于最内层的循环。

可以在循环上指定一个**循环标签**，循环标签使用 `'` + `标识符` 的形式，然后配合 `break` 或 `continue` 使用，此时可以作用于外层循环。

```rust
'out: loop {
    loop {
        println!("do this");
        break 'out;
    }
    println!("Never do");    // 此行不会被执行
}
println!("do this after loop");
```

#### while 循环

`while` 关键字会根据是否满足条件来重复的执行其代码块中的代码，直到不满足条件为止或遇到明确的停止循环指令。

```rust
while x < 10 {
    x = x + 1;
    if x % 8 == 0 {
        break;
    }
}
```

`while` 也可以使用循环标签。

#### for 循环

可以使用 `while` 循环来遍历集合中的元素。

```rust
let arr: [i32; 3] = [1, 2, 3];
let mut i = 0;
while i < 3 {
    println!("{}", arr[i]);
    i = i + 1;
}
```

采用这种方式遍历集合中的元素很容易出错，若索引不正确会导致程序 panic。这也使程序更慢，因为编译器增加了运行时代码来对每次循环的每个元素进行条件检查。

---

使用 `for` 循环来遍历集合中的元素并执行相应的代码。

```rust
let arr = [1, 2, 3];
for e in arr {
    println!("{e}");
}
```

使用 `for` 循环增强了安全性，并消除了错误的索引所产生的 Bug，由于不再需要对每次循环时的每个元素进行条件检查，效率也提高了。

要循环特定次数时，可以使用 `Range`，它是标准库提供的类型，用来生成从一个范围内的所有数字的序列。通过 `start..end` 来语法来创建序列，但不包含 `end`，若要包含 `end`，可以使用 `start..=end` 语法。

`Range` 也能使用 `rev` 方法来反转。

```rust
for e in (1..4).rev() {
    println!("{e}");
}
```

通过 `rev` 来反转 `Range` 实现了倒计时的功能。

## 函数和闭包

Rust 中的函数定义以 `fn` 关键字开始并在函数名后跟一对圆括号，大括号表示函数体的开始和结尾。

使用函数名后跟圆括号来调用定义过的任意函数，定义的位置可以放在**调用之前或之后**，类型表示为 `fn(T, U, ..) -> R`。

```rust
fn main() {
    hello();
}

fn hello() {
    println!("hello, world!");
}
```

`main` 函数是程序的入口点，其中的代码会按顺序执行。

### 函数参数

函数也可以被定义为拥有参数，参数是**函数签名**的一部分。当函数拥有参数（形参）时，可以为函数提供实际的值（实参）。

```rust
fn main() {
    sum(1, 2);
}

fn sum(x: i32, y: i32) {
    println!("{}", x + y);
}
```

在函数签名中，必须声明每个参数的类型。当有多个参数时，用逗号分隔，参数的类型不一定相同。

### 函数体、语句和表达式

函数体由**一系列的语句和一个可选的结尾表达式构成**。Rust 区分语句和表达式：语句是执行一些操作但**不返回值的指令**，表达式**计算并产生一个值**。

```rust
fn main() {
    let x = 2;
}
```

使用 `let` 创建变量并绑定值是语句，函数定义是语句，整个 `main` 函数也是一个语句。语句不返回值，因此不能把 `let` 语句赋值给另一个变量。

```rust
let x = (let y = 3);    // 错误
```

语句 `let y = 3` 不返回值，所以没有可以绑定到 x 上的值。表达式会返回值，语句 `let y = 3` 中的 `3` 是一个表达式。函数调用是一个表达式，宏调用是一个表达式，创建新作用域的大括号 `{}`，也是一个表达式。

```rust
let y = {
    let x = 2;
    x + 1
};
```

大括号的内容是一个代码块，其值为整个代码块中最后一个表达式的值，它的值是 `3`，这个值作为 `let` 语句的一部分被绑定到 `y` 上。`x + 1` 表达式的结尾没有分号 `;`，若在表达式的结尾加上分号，则变成了语句。

### 函数的返回值

函数可以向调用它的代码返回值，需在箭头 `->` 后声明返回值的类型。在 Rust 中，函数的返回值等同于**函数体最后一个表达式的值**。使用 `return` 关键字和指定值，可以从函数中提前返回，但函数通常隐式的返回最后的表达式的值。

```rust
fn main() {
    println!("{}", sum(1, 2));
}

fn sum(x: i32, y: i32) -> i32 {
    // 等同于return x + y;
    x + y
}
```

### 编译期函数

可以定义在编译期计算其参数的 const 函数。其必须是纯函数，因此不能包含可变参数，也不能包含如堆分配这样的动态操作。

```rust
const fn read_header(buf: &[u8]) -> (u8, u8, u8, u8) {
    (buf[0], buf[1], buf[2], buf[3])
}

const FILE_HEADER: (u8, u8, u8, u8) = read_header(include_bytes!("test.txt"));
```

`read_header` 函数使用 `include_bytes!` 接收一个文件作为字节数组，这会在编译期读取文件。然后从中提取 4 字节，并将其作为具有 4 个元素的元组返回。 没有 const 关键字的话，这些都将在运行时完成。

## 结构体

## 定义并实例化结构体

和元组一样，结构体的每一部分可以是不同类型。但不同于元组，结构体需要命名各部分数据，因此结构体不需要依赖顺序来指定或访问实例中的值。

定义结构体，需使用 `struct` 关键字并为整个结构体提供一个名字，在大括号中定义每一部分数据的名字和类型，称为**字段**。

```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u32,
    active: bool
}

let mut user1 = User {
    email: String::from("1@e.c"),
    username: String::from("1"),
    sign_in_count: 1,
    active: true
};

let user2 = User {
    username: String::from("2"),
    active: false,
    ..user1
};

user1.email = String::from("1.1@e.c");
println!("{}, {}", user1.active, user1.username);
println!("{}, {}", user2.sign_in_count, user2.email);
```

定义了结构体后，通过为每个字段指定具体值来创建这个结构体的实例。创建一个实例需要以结构体的名字开头，接着在大括号中使用 `key: value` 的形式提供字段，其中 `key` 是字段的名字，`value` 是需要存储在字段中的数据值。实例中字段的顺序不需要和在结构体中声明的顺序一致。

从结构体中获取某个特定的值，可以使用点号 `.`。若只想获取用户的邮箱地址，可以用 `user1.email`。要修改实例的某个字段，则整个实例必须是可变的，Rust 不允许只将某个字段标记为可变。要更改结构体中的值，若结构体的实例是可变的，可以使用点号并为对应的字段赋值。

使用旧实例的大部分值但改变其部分值来创建一个新的结构体实例可以通过**结构体更新语法**来实现。使用结构体更新语法，可以通过更少的代码来达到相同的效果。`..` 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。**由于这些值来自其它实例中的字段，若其它实例中的这些字段不是 `Copy` trait，发生 `move` 时会导致此实例出现错误，或此实例先发生 `move` 会导致其它实例发生错误。**

---

同其他任何表达式一样，可以在函数体的最后一个表达式中构造一个结构体的新实例，来隐式地返回这个实例。

```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u32,
    active: bool
}

fn main() {
    let user1 = build_user(String::from("1"), String::from("1@e.c"));
    println!("{}, {}", user1.username, user1.email);
}

fn build_user(username: String, email: String) -> User {
    User {
        username: username,
        email: email,
        sign_in_count: 1,
        active: true
    }
}
```

因为参数名与字段名都完全相同，可以使用**字段初始化简写语法**来重写 `build_user` 函数。

```rust
fn build_user(username: String, email: String) -> User {
    User {
        username,
        email,
        sign_in_count: 1,
        active: true
    }
}
```

若函数参数名与字段名不相同，则不能简写。

## 元组结构体

元组结构体是没有具体的字段名，只有字段的类型。当给整个元组取一个名字，并使元组成为与其他元组不同的类型时，可以使用元组结构体。

定义元组结构体，以 `struct` 关键字和结构体名开头并后跟元组中的类型。

```rust
struct RGBA(u8, u8, u8, u8);
struct IPADDR(u8, u8, u8, u8);
let color = RGBA(0, 255, 255, 0);
let ip = IPADDR(192, 168, 0, 1);
```

`color` 和 `ip` 值的类型不同，因为它们是不同的元组结构体的实例。定义的每一个结构体有其自己的类型，即使结构体中的字段有着相同的类型。一个获取 `RGBA` 类型参数的函数不能接受 `IPADDR` 作为参数，即便这两个类型都由四个 `u8` 值组成。元组结构体实例类似于元组：可以将其解构为单独的部分，也可以使用 `.` 后跟索引来访问单独的值。

一个没有任何字段的结构体被称为**类单元结构体**，常在某个类型上实现 trait 但不需要在类型中存储数据的时候使用。

```rust
struct Foo1;
struct Foo2();
struct Foo3{}
```

## 结构体数据的所有权

在 `User` 结构体的定义中，使用了自身拥有所有权的 `String` 类型而不是 `&str` 字符串 slice 类型。结构体拥有它所有的数据，因此只要整个结构体是有效的其数据也是有效的。

可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上生命周期。它确保结构体引用的数据有效性跟结构体本身保持一致，若尝试在结构体中存储一个引用而不指定生命周期将是无效的。

```rust
struct User {
    username: &str,
    email: &str,
    sign_in_count: u32,
    active: bool
}

fn main() {
    let user1 = User {
        email: "1@e.c",
        username: "1",
        active: true,
        sign_in_count: 1
    };
}
```

编译器会报错，因为需要生命周期标识符：

```
username: &str,
          ^ expected `lifetime parameter`
error[E0106]: missing lifetime specifier
email: &str,
       ^ expected lifetime parameter
```

此外，由于结构体本身并不是属于标量类型，因此是没有实现 `Copy` trait 的。当不使用引用时，结构体变量的所有权会转移。

```rust
struct SomeStruct;

fn main() {
    let s = SomeStruct;
    let s1 = s;    // s 被移动到 s1
}
```

## 使用结构体

以下程序将计算长方形面积。

```rust
fn main() {
    let width = 2;
    let height = 3;
    println!("{}", area(width, height));
}

fn area(width: u32, height: u32) -> u32 {
    width * height
}
```

长度和宽度本应该是相关联的，但 `area` 函数却有两个参数，程序本身却没有表现出关联性。可以将长度和宽度通过元组组合在一起。

```rust
fn main() {
    let s = (2, 3);
    println!("{}", area(s));
}

fn area(wh: (u32, u32)) -> u32 {
    wh.0 * wh.1
}
```

元组增加了一些结构性，现在只需传一个参数。但元组并没有给出元素的名称，所以不得不使用索引来获取元组的每一部分，这样很容易混淆这些值而造成错误。通过结构体为数据命名来为其赋予意义，可以将元组转换成一个有整体名称而且每个部分也有对应名字的数据类型。

```rust
struct Rect {
    width: u32,
    height: u32
}

fn main() {
    let rect = Rect { width: 2, height: 3 };
    println!("{}", area(&rect));
}

fn area(rect: &Rect) -> u32 {
    rect.width * rect.height
}
```

`area` 函数现在被定义为接收 `Rect` 类型的不可变借用的参数，这样 `main` 函数就可以保持 `rect` 的所有权并继续使用它。`area` 函数访问 `Rect` 实例的 `width` 和 `height` 字段。`area` 的函数签名表示使用 `Rect` 的 `width` 和 `height` 字段，这表明宽高是相互联系的，并为这些值提供了描述性的名称而不是使用元组的索引值 `0` 和 `1` 。

## 通过派生 trait 增加实用功能

若能要在调试程序时打印出 `Rect` 实例来查看其所有字段的值，正常方法使用 `println!` 宏是不行的。

```rust
println!("{}", rect);   // 错误
```

编译器会输出以下信息：

```
help: the trait `std::fmt::Display` is not implemented for `Rect`
note: in format strings you may be able to use `{:?}` (or `{:#?}` for pretty-print) instead
```

`println!` 宏能处理很多类型的格式，不过，`{}` 默认告诉 `println!` 使用被称为 `Display` 的格式：意在提供给直接终端用户查看的输出。大部分基本类型都默认实现了 `Display`，不过对于结构体，`println!` 并没有提供一个 `Display` 实现。

编译器输出需要使用 `{:?}` 或 `{:#?}`：

```rust
println!("{:?}", rect);
```

在 `{}` 中加入 `:?` 指示符告诉 `println!` 要使用叫做 `Debug` 的输出格式。`Debug` 是一个 trait，它允许以一种对开发者有帮助的方式打印结构体，以方便调试代码时能看到它的值。

但这样做编译器依然会报错：

```
help: the trait `std::fmt::Debug` is not implemented for `Rect`
note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`
```

Rust 确实包含了打印出调试信息的功能，不过必须为结构体显式选择这个功能，为此需要在结构体定义之前添加 `#[derive(Debug)]` 注解。

```rust
#[derive(Debug)]
struct Rect {
    width: u32,
    height: u32
}
```

这时程序会出现以下输出：

```
Rect { width: 2, height: 3 }
```

它显示这个实例的所有字段，但若有一个更大的结构体时，需要有更易读一点的输出格式，为此可以使用 `{:#?}`。

```rust
println!("{:#?}", rect);
```

现在的输出格式会变成这样：

```
Rect {
    width: 2,
    height: 3,
}
```

---

另一种使用 `Debug` 格式打印数值的方法是使用 `dbg!` 宏。`dbg!` 宏接收一个表达式的所有权，打印出代码中调用宏时所在的文件和行号，以及该表达式的结果值，并返回该值的所有权。

>   `dbg!` 宏会打印到 `stderr`，而 `println!` 会打印到 `stdout`。

```rust
let rect = Rect {
    width: dbg!(2),
    height: 3,
};
dbg!(&rect);
dbg!(area(&rect));
```

```
[src\main.rs:9] 2 = 2
[src\main.rs:12] &rect = Rect {
   width: 2,
   height: 3,
}
[src\main.rs:13] area(&rect) = 6
```

因为 `dbg!` 返回表达式值的所有权，所以 `width` 字段将获得相同的值。而 `dbg!` 不需要获得所有权，因此传递一个 `rect` 的引用。

## 方法语法

`area` 函数是非常特殊的，它只用于计算矩形面积。这个行为应该与 `Rect` 结构体再结合得更紧密一些，因为它不能用于其他类型。

方法与函数类似：使用 `fn` 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数不同的是，它在结构体（枚举、trait）的上下文中被定义，且第一个参数总是 `self`，它代表调用该方法的实例。

### 定义方法

```rust
struct Rect {
    width: u32,
    height: u32
}

impl Rect {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect = Rect { width: 2, height: 3 };
    println!("{}", rect.area());
}
```

为了使函数定义于 `Rect` 的上下文中，定义了一个 `impl` 块。将计算面积的函数移动到 `impl` 中，并将签名中的第一个参数和函数体中其他地方的对应参数改成 `self`，然后在先前 `main` 中调用 `area` 函数并传递 `rect` 作为参数的地方，改成使用**方法语法**在 `Rect` 实例上调用 `area` 方法。方法语法获取一个实例并加上一个点号，后跟方法名、圆括号以及任何参数。

在 `area` 的签名中，使用 `&self` 来替代 `rect: &Rect`，因为该方法位于 `impl Rect` 上下文中，所以 Rust 知道 `self` 的类型是 `Rect`，但仍然需要在 `self` 前面加上 `&`。

`&self` 实际上是 `self: &Self` 的缩写。在一个 `impl` 块中，`Self` 类型是 `impl` 块的类型的别名。方法的第一个参数必须有一个名为 `self` 的`Self` 类型的参数，因此以下例子是等价的：

```rust
fn area(&self) {}
fn area(self: &Rect) {}
fn area(self: &Self) {}
```

>   只要第一个参数名为 self，就代表了实例本身。

---

方法可以选择获取 `self` 的所有权、不可变或可变地借用 `self`。选择 `&self` 的理由是并不获取其所有权，只需能够读取结构体中的数据，而不用写入。若想要在方法中修改调用方法的实例，需要将第一个参数改为 `&mut self`。

通过仅仅使用 `self` 作为第一个参数来使方法获取实例的所有权是很少见的，这种技术通常用在当方法将 `self` 转换成别的实例的时候，这时可以防止调用者在转换之后继续使用原始的实例。

使用方法替代函数，除了可使用方法语法和不需要在每个函数签名中重复 `self` 的类型之外，其主要好处在于组织性。将某个类型实例能做的所有事情都一起放入 `impl` 块中，而不是在库中到处寻找 `Rect` 的功能。

---

字段与方法的名字可以相同：

```rust
fn width(&self) -> u32 { self.width } 
```

编译器可以判断出其对应的功能，当使用 `object.width` 时，为使用字段，当使用 `object.width()` 是，为使用方法，这种一般用于获取字段的值，即有些语言中的 `get` 方法。

### 多个参数和 impl 块

方法可以拥有多个参数或者多个 `impl` 块，当有多个参数时，第一个参数必须是 `self`、`&mut self` 或 `self`。

```rust
#[derive(Debug)]
struct Point {
    x: u32,
    y: u32
}

impl Point {
    fn dot(&self, other: &Point) -> u32 {
        self.x * other.x + self.y * other.y
    }
}

impl Point {
    fn add(&self, other: &Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y
        }
    }
}
```

不过若多个 `impl` 是同一个结构体的方法，可以合并到同一个 `impl` 块中。

```rust
impl Point {
    fn dot(&self, other: &Point) -> u32 {
        self.x * other.x + self.y * other.y
    }

    fn add(&self, other: &Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y
        }
    }
}
```

### 自动引用和解引用

在 C / C++ 语言中，有两个不同的运算符来调用方法：`.` 直接在对象上调用方法，而 `->` 在一个对象的指针上调用方法，这时需要先解引用指针。如 `object` 是一个指针，那么 `object->method()` 等同于 `(*object).method()`。

Rust 并没有一个与 `->` 等效的运算符，但有**自动引用和解引用**。方法调用是 Rust 中少数几个拥有这种行为的地方。

当使用 `object.method()` 调用方法时，Rust 会自动为 `object` 添加 `&`、`&mut` 或 `*` 以使 `object` 与方法签名匹配。

```rust
let p1 = Point { x: 2, y: 3 };
let p2 = Point { x: 3, y: 4 };
println!("{}", p1.dot(&p2));
println!("{:#?}", (&p1).add(&p2));
```

两个 `println!` 宏中的 `p1`、`(&p1)` 实际上是等价的。这种自动引用的行为之所以有效，是因为方法明确的接收 `&self` 类型。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是 `&self`、`&mut self` 或 `self`。

### 关联函数

`impl` 块的另一个的功能是：允许在 `impl` 块中定义**不**以 `self` 作为参数的函数，这被称为**关联函数**，因为它与结构体相关联。关联函数仍是函数而不是方法，因为它**并不作用于一个结构体的实例， 而是作用于类型**，如 `String::from` 就是关联函数。关联还是可以看作是类型的方法而不是实例的方法，在有些语言中被称为**静态方法**。

关联函数经常被用作构造函数，以返回一个结构体新实例。

```rust
#[derive(Debug)]
struct Point {
    x: u32,
    y: u32
}

impl Point {
    fn dot(&self, other: &Point) -> u32 {
        self.x * other.x + self.y * other.y
    }
    
    fn new(x: u32, y: u32) -> Self {
        Point { x, y }
    }
}

fn main() {
    let p1 = Point::new(2, 3);
    let p2 = Point::new(3, 6);
    println!("{}", p1.dot(&p2));
    println!("{:#?}", (&p1).dot(&p2));
}
```

使用结构体名和 `::` 语法来调用这个关联函数。这个方法位于结构体的命名空间中，`::` 语法用于关联函数和模块创建的命名空间。

# 2 枚举和模式匹配

枚举允许通过列举可能的成员来定义一个类型。

## 定义枚举

目前被广泛使用的两个主要 IP 标准：IPv4 和 IPv6。程序可能会遇到的所有可能的 IP 地址类型：可以枚举出所有可能的值。enum 中的所有值都属于同一种类型，也就是 enum 的名称所表示的类型。

通过在代码中定义一个 `IpKind` 枚举来列出可能的 IP 地址类型，`V4` 和 `V6`，这被称为枚举的**成员**。

```rust
enum IpKind {
    V4,
    V6
}
```

枚举成员拥有隐式的从 0 开始的整数值，且可以通过 `as` 来进行类型转换，也可以显式指定值：

```rust
// 隐式值，从 0 开始
enum Num {
    Zero,
    One,
    Two
}

// 显式值
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff
}

fn main() {
    println!("Zero is {}", Number::Zero as i32);
    println!("One is {}", Number::One as i32);

    println!("Roses are #{:06x}", Color::Red as i32);
    println!("Violets are #{:06x}", Color::Blue as i32);
}
```



### 枚举值

创建 `IpKind` 两个不同成员的实例。

```rust
let ipv4: IpKind = IpKind::V4;
let ipv6 = IpKind::V6;
```

枚举的成员位于其标识符的**命名空间**中，并使用两个冒号 `::` 分隔。

可以定义一个函数来获取任何 `IpKind`。

```rust
fn route(ip_type: IpKind) {}
```

然后使用成员调用该函数。

```rust
let ipv4 = IpKind::V4;
route(ipv4);
route(IpKind::V6);
```

还可以配合结构体来处理 IP 地址数据。

```rust
enum IpKind {
    V4,
    V6
}

struct IpAddr {
    kind: IpKind,
    address: String
}

let home = IpAddr {
    kind: IpKind::V4,
    address: String::from("127.0.0.1")
};

let loopback = IpAddr {
    kind: IpKind::V6,
    address: String::from("::1")
};
```

使用枚举并将数据直接放进每一个枚举成员而不是将枚举作为结构体的一部分。`IpAddr` 枚举的新定义表明了 `V4` 和 `V6` 成员都关联了 `String` 值。

```rust
enum IpKind {
    V4(String),
    V6(String)
}

let home = IpKind::V4(String::from("127.0.0.1"));
let loopback = IpKind::V6(String::from("::1"));
```

直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体。**这样定义的枚举成员的名字也变成了一个构建枚举实例的构造函数**，即 `IpAddr::V4()` 是一个获取 `String` 参数并返回 `IpKind` 类型实例的函数调用。作为定义枚举的结果，这些构造函数会自动被定义。

用枚举替代结构体还可以使每个成员可以处理不同类型和数量的数据。若想要将 `V4` 地址存储为四个 `u8` 值而 `V6` 地址仍然表现为一个 `String`，这样就不能使用结构体。

```rust
enum IpKind {
    V4(u8, u8, u8, u8),
    V6(String)
}

let home = IpKind::V4(127, 0, 0, 1);
let loopback = IpKind::V6(String::from("::1"));
```

可以将任意类型的数据放入枚举成员中：字符串、数字类型、结构体和枚举等。

枚举成员还可以为多种类型。

```rust
enum Message {
    Quit,
    Move { x: u32, y: u32 },
    Write(String),
    Color(u8, u8, u8)
}
```

这个枚举有四个含有不同类型的成员：

-   `Quit` 没有关联任何数据；
-   `Move` 包含一个匿名结构体；
-   `Write` 包含一个 `String；`
-   `Color` 包含三个 `u8`。

使用结构体也可以定义但不够简洁。

```rust
struct QuitMessage;                   // 类单元结构体
struct MoveMessage { x: u32, y: u32 }  
struct WriteMessage(String);          // 元组结构体
struct ColorMessage(u8, u8, u8);      // 元组结构体
```

枚举也可以像使用 `impl` 来为结构体定义方法那样，在枚举上定义方法或关联函数。

```rust
impl IpAddr {
	fn localhost_v4() -> IpAddr {
		IpAddr::V4(127, 0, 0, 1)
	}

	fn info(&self) {
		println!("{:?}", self);
	}
}

let ip = IpAddr::localhost_v4();
ip.info();
```

使用 `self` 来获取调用方法的值。

### Option 枚举

`Option` 是标准库定义的另一个枚举。

空值是一个值，它代表没有值。在有空值的语言中，变量总是这两种状态之一：空值和非空值。空值的问题在于当尝试像非空值那样使用空值，会出现某种形式的错误。

**Rust 没有空值**，不过它拥有一个可以编码存在或不存在概念的枚举。这个枚举是 `Option<T>`，它定义于标准库中。

```rust
enum Option<T> {
    Some(T),
    None
}
```

`Option<T>` 枚举是被包含在了 **prelude** 之中，不需要将其显式引入作用域。它的成员也不需要 `Option::` 前缀，可直接使用 `Some` 和 `None`。

`<T>` 语法是代表它是一个泛型类型参数，意味着 `Option` 枚举的 `Some` 成员可以包含任意类型的数据。

```rust
let some_number = Some(5);
let some_string = Some("a string");
let absent_number: Option<i32> = None;
```

若使用 `None` 而不是 `Some`，需要告诉 Rust `Option<T>` 是什么类型的，因为编译器只通过 `None` 值无法推断出 `Some` 成员保存的值的类型。

当有一个 `Some` 值时，就知道存在一个值，而这个值保存在 `Some` 中。当有个 `None` 值时，它跟空值具有类似的含义。

---

因为 `Option<T>` 和 `T` 是不同的类型，编译器不允许像一个肯定有效的值那样使用 `Option<T>`。如这段代码不能编译，因为它尝试将 `Option<i8>` 与 `i8` 相加：

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);
let sum = x + y;    // 错误
```

Rust 不知道该如何将 `Option<i8>` 与 `i8` 相加，因为它们的类型不同。当在 Rust 中拥有一个像 `i8` 这样类型的值时，编译器确保它总是有一个有效的值，可以直接使用而无需做空值检查。只有当使用 `Option<i8>`（或者任何用到的类型）的时候需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。

在对 `Option<T>` 进行 `T` 的运算之前必须将其转换为 `T`，因此哪怕类型相同，`Option<T>` 之间也是不能直接运算。

```rust
Some(1) + Some(2);  // 错误
```

通常这能捕获到空值最常见的问题之一：假设某值不为空但实际上为空的情况。Rust 通过限制空值的泛滥以增强 Rust 代码的安全性。

## match 控制流运算符

`match` 为 Rust 中极为强大的控制流运算符，它允许将一个值与一系列的模式相比较并根据相匹配的模式执行相应代码。模式可由字面值、变量、通配符和许多其他内容构成。Rust 确保所有可能的情况都能得到处理。

```rust
enum Size {
   S,
   M,
   L,
   X
}

fn size_value(size: Size) -> u32 {
    match size {
        Size::S => 1,
        Size::M => 2,
        Size::L => 3,
        Size::X => {
            println!("X!");
            4
        }
    }
}
```

`match` 关键字后跟一个表达式，在这里是 `size` 的值。和 `if` 的区别是：`if` 表达式必须为布尔值，而 `match` 可以是任意类型。

接下来是 `match` 的分支。一个分支有两个部分：**模式**和**代码**。第一个分支的模式是值 `Size::S` 而之后的 `=>` 运算符将模式和将要运行的代码分开。每一个分支之间使用逗号分隔。

可以拥有任意多的分支，当 `match` 表达式执行时，它将结果值按顺序与每一个分支的模式相比较。若模式匹配了这个值，这个模式相关联的代码将被执行，并结束匹配；若模式并不匹配这个值，将继续执行下一个分支。

每个分支相关联的代码是一个表达式，而表达式的结果将作为整个 `match` 表达式的返回值，每个分支返回值类型都必须相同。

分支代码较短的话通常不使用大括号。若想要在分支中运行多行代码，可以使用大括号，大括号内最后一个表达式的值作为这条分支的值。

### 绑定值的模式

匹配分支的还可以绑定匹配的模式的部分值。

```rust
enum Size {
   S,
   M,
   L,
   X(Special)
}

enum Special {
    X,
    XL,
    XXL,
    XXXL
}

fn size_value(size: Size) -> u32 {
    match size {
        Size::S => 1,
        Size::M => 2,
        Size::L => 3,
        Size::X(state) => {
            match state {
                Special::X => 4,
                Special::XL => 5,
                Special::XXL => 6,
                Special::XXXL => 7
            }
        }
    }
}
```

在这些匹配表达式中，匹配 `Size:X` 成员的分支的模式中增加了一个叫做 `state` 的变量。当匹配到此分支时，继续通过 `match` 来匹配 `state` 的值，`state` 最终将绑定到 `Special` 枚举中的某个成员所对应的值。

### 匹配的所有权

如下代码不能通过编译：

```rust
let s = Some(String::from("hello"));
match s {
    Some(v) => println!("{v}"),
    None => println!("Nothing"),
}
println!("{:?}", s);    // 错误，s 中的值已经移动到 v
```

由于在进行匹配时，`Some(v)` 中的 `v` 会获得 `s` 中 `String` 的所有权，`s` 中的一部分被移动了，因此在之后 `s` 就不能继续使用整体，要在后续也能够使用，需要在匹配时获取一个引用，或者只使用没有被移动的部分。

#### 部分移动

可以移动一个变量的一部分，称为**部分移动**，这表示变量的某些部分将被移动，而其他部分将保留。在这种情况下，之后的代码不能使用变量的整体，但可以使用没有移动的部分。

通过 `ref` 关键字可以获得解构后的引用而不获取所有权：

```rust
struct Person {
    first_name: String,
    last_name: String,
}

let p = Person {
    fname: String::from("AAA"),
    lname: String::from("BBB"),
};

let Person {
    ref fname,  // 解构成一个引用
    lname,
} = p;

println!("{}", p.first_name);  // 正确
println!("{}", p.last_name);   // 错误
```

类似的使用 `ref mut` 获得一个可变引用：

```rust
let mut s = Some(5);
match s {
    Some(ref mut v) => *v += 1,
    _ => (),
}
println!("{:?}", s);
```

`ref` 通常用在要匹配的对象没有所有权的时候：

```rust
fn main() {
    let s = Some(String::from("hi"));
    print_s(&s);
}

fn print_s(s: &Option<String>) {
    match *s {
        Some(ref v) => println!("{}", v),
        None => println!("Nothing"),
    }
}
```

`print_s` 函数接收一个引用 `&T`，因此并没有这个参数的所有权，当对其进行解引用后，匹配中的类型变为 `T`，但不能对引用的对象获得所有权，因此必须对 `v` 使用 `ref` 修饰，否则无法通过编译。

>   `ref` 和 `&` 都在模式匹配中使用，但是前者不是模式的一部分，而后者是模式的一部分。`ref` 仅表示获得值的一个引用，而不获取所有权。

### 匹配 Option\<T\>

可以像处理枚举那样使用 `match` 处理 `Option<T>`。

```rust
fn main() {
    let x = plus_one(Some(5));
    let y = plus_one(None);
    println!("{:?}", x);
    println!("{:?}", y);
}

fn plus_one(x: Option<u32>) -> Option<u32> {
    match x {
        Some(i) => Some(i + 1),
        None => None
    }
}
```

该函数获取一个 `Option<u32>`，若其中有值，则加 1；若其中没有值，则返回 `None`。

### 匹配是穷尽的

```rust
match x {
    Some(i) => Some(i + 1)    // 错误
}
```

由于没有处理 `None` 的情况，所以不能通过编译。

Rust 中的**匹配是穷尽的**：必须穷举到最后的可能性来使代码有效。特别在使用 `Option<T>` 时，为了防止忘记明确的处理 `None` 的情况，这样可以避免使用实际上为空的值。

### 通配符

Rust 提供了一个模式用于不想列举出所有可能值的场景：使用 `_` 通配符。

```rust
let x = Some(1);
match x {
    Some(i) => Some(i + 1),
    _ => None
};
```

`_` 模式会匹配所有没有指定的可能的值，通常将其放置于其他分支之后。

```rust
let x = 1;
match x {
    1 => println!("one"),
    _ => ()
};
```

`()` 是单元值，所以 `_` 的情况什么也不会发生。

## if let 控制流

若只匹配一种情况，为了满足 `match` 表达式穷尽性的要求，必须在处理完这唯一的成员后使用 `_` 通配符。

`if let` 语法用来处理只匹配一个模式的值而忽略其他模式的情况。

```rust
let x = Some(1);
if let Some(3) = x {
    println!("{:?}", x);
}
else {
    println!("Others");
};
```

`if let` 获取通过 `=` 分隔的一个模式和一个表达式。它的工作方式与 `match` 相同，这里的表达式对应 `match` 而模式则对应第一个分支。使用 `if let` 可以编写更少的代码，但会失去 `match` 强制要求的穷尽性检查。

还可以在 `if let` 中包含一个 `else`，`else` 块中的代码与 `match` 表达式中的 `_` 分支块中的代码相同，这样的 `match` 表达式就等同于 `if let` 和 `else`。

由于 `if let` 本身也是一个表达式，因此可以返回值。当作为返回值使用时，必须保证隐含的 `else` 和返回的类型是相同的，或者显示指定 `else` 的返回值，某则默认的返回值为 `()`。

```rust
let x = Some(5);
let y = if let Some(i) = x {
    Some(i + 1)
} else {
    None
};
```

# 1 闭包

## 什么是闭包

**闭包**是可以保存进变量、作为参数传递给其他函数或作为返回值的**匿名函数**。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。

## 函数重复调用

```rust
fn calc(x: i32) -> i32 {
    x + 1
}

fn run(n: i32) {
    if n < 10 {
        println!("{}", calc(n));
        println!("{}", calc(n));
    } else if n < 20 {
        println!("{}", calc(n));
    } else if n < 30 && n % 3 == 0 {
        println!("{}", calc(n));
    } else {
        println!("Do nothing");
    }
}
```

`calc` 函数用来模拟一些十分耗时的运算，这里简单返回参数值加一。`run` 函数用来模拟根据不同情况执行实际的运算。可以看到，这里有多处调用了 `calc` 函数。第一个 if 块调用了 2 次，第二个和第三个分别调用了 1 次，最后一个没有调用。

这里有两处问题：

-   第一个 if 块做了 2 次调用，但实际只需要 1 次；
-   多个 if 块中都进行了相同的调用，可以简化。

### 重构函数

首先可以将函数调用的返回值保存到一个变量中，之后直接传递变量值即可，如下：

```rust
fn run(n: i32) {
    let result = calc(n);
// --snip--
}
```

但这里还有一个问题，若 `n` 的值一开始就满足最后一个 if 块，那么就会做一次不必要的计算，而且若某个函数调用所传递的参数有所改变，那么变量保存的值则不能通用。

理想情况是，若参数相同，那么所需要的函数只需要调用一次，且只会在真正使用的时候才执行计算，这时候可以使用闭包。

## 定义闭包

闭包就是一个匿名函数，可以保存在变量中，这里可以将 `calc` 函数改写为闭包的形式：

```rust
fn run(n: i32) {
    let calc = |x| x + 1;
// --snip--
}
```

闭包的定义以一对竖线 `||` 开始，在竖线中指定闭包的参数，若有多个参数，则用逗号分隔，如 `|param1, param2|`。

参数之后是存放闭包体的大括号，若闭包体只有一行则大括号可以省略。大括号之后闭包的结尾，需要用于 `let` 语句的分号。因为闭包体的最后一行没有分号，所以闭包体最后一行的值作为调用闭包时的返回值。

```rust
let foo = |param| {
    println!("{}", param);
    param + 1
};
```

>   `let` 语句表示 `calc` 包含一个匿名函数的**定义**，而不是**返回值**。

定义了闭包之后，就可以像函数那样调用值。

```rust
calc(1);
foo(2);
```

## 闭包类型推断和注解

闭包不用像函数那样在参数和返回值上注明类型。函数中需要类型注解是因为需要作为接口给外部调用，因此需要严格定义。但闭包是在局部范围内使用，不用命名或作为接口。

闭包通常很短，只关联小范围的上下文。在这些有限制的上下文中，编译器可推断出参数和返回值的类型。

但也可以显式标注出类型：

```rust
|param1: i32, param2: i32| -> i32 {}
```

闭包语法和函数语法十分类似，除了使用竖线而不是括号以及几个可选的语法之外：

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

第一行展示了一个函数定义，而第二行展示了一个完整标注的闭包定义。第三行闭包定义中省略了类型注解，而第四行闭包体只有一行，因此去掉了可选的大括号。这些都是有效的闭包定义，并在调用时产生相同的行为。

>   当省略类型标注时，必须在上下文中给出能够让编译器推断出类型的信息。

---

闭包定义会为每个参数和返回值推断一个具体类型：

```rust
let c = |x| x;
let s = example_closure(String::from("hello"));
let n = example_closure(5);    // 报错
```

第一次使用时，已经推断出闭包的类型，因此第二次使用不同的参数类型就会报错。

---

每个定义的闭包都是唯一的类型，即使签名相同：

```rust
let c1 = |x: i32| -> i32 {x + 1};
let c2 = |x: i32| -> i32 {x + 1};
```

这两个闭包虽然签名相同，但类型是不同的。

## Fn trait

闭包周围的作用域被定义为其所处的**环境**，因此闭包除了能够作为内联匿名函数来使用外，和函数有一个最大的区别：**可以捕获环境中的值**。

```rust
fn main() {
    let x = 3;
    let equal_to_x = |n| n == x;
    assert!(equal_to_x(3));
}
```

即使 `x` 并不是 `equal_to_x` 闭包的一个参数，也被允许使用变量 `x`，因为它与 `equal_to_x` 定义于相同的作用域。

函数则不行，这样做将无法通过编译：

```rust
// 错误
fn main() {
    let x = 3;
    fn equal_to_x(n: i32) -> bool {
        n == x
    }
    assert!(equal_to_x(3));
}
```

---

当闭包从环境中捕获一个值，闭包会在闭包体中储存这个值，这会产生额外的内存开销，而函数不允许捕获环境，因此定义和使用函数也就没有这些额外开销。

闭包可以通过三种方式捕获其环境，对应函数的三种获取参数的方式：

-   获取所有权；

-   可变借用；

-   不可变借用。

这三种捕获值的方式对应三个 `Fn` trait：

-   `std::ops::FnOnce` 从环境获取值的所有权，因此该类闭包只能使用一次；
-   `std::ops::FnMut` 从环境获取值的可变的借用，因此可以改变其环境的值；
-   `std::ops::Fn` 从环境获取值的不可变的借用。

当定义一个闭包时，编译器会根据其如何使用环境中的值来推断如何引用环境的值：

-   由于所有闭包都可以被至少调用一次，因此所有闭包都实现了 `FnOnce` ；
-   没有获取被捕获值的所有权的闭包都实现了 `FnMut` ；
-   没有对被捕获值进行可变访问的闭包都实现了 `Fn` 。 

实际上，这三种闭包 trait 的限制程度依次增大，因为一个 `FnOnce` 闭包还可以接受 `&mut T` 和 `&T`，而一个 `Fn` 闭包则只能接受 `&T`。编译器会在满足使用需求的前提下尽量以限制最多的方式捕获。

---

`Fn` 系列 trait 由标准库提供，所有的闭包都自动实现了 `FnOnce`、`FnMut` 或 `Fn` 中的一个。

>   函数也都实现了这三个 `Fn` trait，若不需要捕获环境中的值，则可以使用实现了 `Fn` trait 的闭包，或者直接使用函数。

上面的代码中，由于 `equal_to_x` 闭包不可变的借用了 `x`，所以 `equal_to_x` 具有 `Fn` trait。

---

```rust
let mut s = String::from("hello");
let mut add_suffix = || s.push_str(" world");
println!("{s}");  // 错误
add_suffix();
```

`add_suffix` 这个闭包可变的借用了 `s`，因此具有 `FnMut` trait，且需要加上 `mut` 关键字。

这里由于 `s` 已经被闭包可变的借用了，因此 `println!` 会报错，因为它会不可变的借用。

---

若需要强制闭包获取其捕获值的所有权，可以使用 `move` 关键字，这个技巧通常用在将闭包传递给新线程以便将数据移动到新线程中时。

```rust
let s = String::from("hello");
let equal_to_s = move |n| s == n;
println!("{}", s);    // 此处 s 已失效
assert!(equal_to_s(String::from("hello")));
```

>   简单类型由于实现了 `Copy` trait，就算使用了 `move` 关键字，闭包获取的也只是值的拷贝，因此需要使用像 `vector`、`String` 这样的类型。

---

```rust
let f = |_| ();
let s = String::from("hello");
f(s);
```

这里，由于 `f` 没有捕获环境的值，因此 `f` 具有 `Fn` trait，但是其参数会获取所有权，在闭包运行结束后，就 `s` 被立刻回收，因此该闭包相当于 `drop` 函数的作用。

## 闭包作为返回值

Rust 需要在编译期知道返回类型的大小，而匿名的闭包的类型是未知的，因此只有使用 `impl Trait` 才能返回一个闭包，返回闭包的有效 trait 是：`FnOnce`、`FnMut` 和 `Fn`。

此外，还必须使用 `move` 关键字，因为在离开函数作用域时，任何通过引用捕获的值都被丢弃。

```rust
fn ret_fnonce() -> impl FnOnce() {
    move || println!("FnOnce")
}

fn ret_fnmut() -> impl FnMut() {
    move || println!("FnMut")
}

fn ret_fn() -> impl Fn() {
    move || println!("Fn")
}

fn main() {
    let f_once = ret_fnonce();
    let mut f_mut = ret_fnmut();  // FnMut 必须加上 mut 关键字
    let f = ret_fn();
    f_once();
    f_mut();
    f();
}
```

## 带有泛型和 Fn trait 的闭包

回到 `run` 函数：

```rust
fn run(n: i32) {
    let calc = |x| x + 1;

    if n < 10 {
        println!("{}", calc(n));
        println!("{}", calc(n));
    } else if n < 20 {
        println!("{}", calc(n + 1));
    } else if n < 30 && n % 3 == 0 {
        println!("{}", calc(n + 1));
    } else {
        println!("Do nothing");
    }
}
```

将原来的 `calc` 函数定义成了一个闭包，然后再调用它，但这里第一个 if 块重复调用了两次，后面的 if 块分别调用了一次，且由于参数不同，因此不能简单的在开头使用变量来保存返回值。

### 惰性求值

可以定义一个存放闭包和调用闭包结果的结构体。该结构体只会在需要结果时执行闭包，并缓存结果值，之后的代码就可以直接使用该值，这种模式被称为**惰性求值**。

为了让结构体存放闭包，需要指定闭包的类型。由于每一个闭包都是一个唯一的类型，因此需要将闭包放在泛型中，并使用 trait bound 来约束闭包的签名。

```rust
struct Cacher<F>
where
    F: Fn(i32) -> i32,
{
    calc: F,
    value: Option<i32>,
}
```

这里创建了一个 `Cacher` 结构体，包含用来存放闭包的泛型字段 `calc` 和缓存值 `value`。`F` 的 trait bound 指定了 `F` 是一个使用 `Fn` 的闭包。任何储存到 `Cacher` 实例的 `calc` 字段的闭包必须有一个 `i32` 参数，且必须返回一个 `i32`。

字段 `value` 是 `Option<i32>` 类型的。在执行闭包前，`value` 为 `None`，这时使用 `Cacher` 的实现来请求闭包的结果，会执行闭包并将结果储存在 `value` 字段的 `Some` 成员中。当再次请求闭包的结果时，由于 `value` 字段不是 `None`，因此不执行闭包，而是返回存放在 `Some` 成员中的结果。

然后对 `Cacher` 进行实现：

```rust
impl<F> Cacher<F>
where
    F: Fn(i32) -> i32,
{
    fn new(calc: F) -> Self {
        Self { calc, value: None }
    }

    fn value(&mut self, arg: i32) -> i32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.calc)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
```

`Cacher::new` 函数获取一个闭包作为参数，类型为泛型参数 `F`，定义于 `impl` 块上下文中并与 `Cacher` 结构体有着相同的 trait bound。`Cacher::new` 返回一个在 `calc` 字段中存放了指定闭包和在 `value` 字段中存放了 `None` 值的 `Cacher` 实例，因为此时还未执行闭包。

当需要闭包的执行结果时，不同于直接调用闭包，而是调用 `value` 方法。这个方法会检查 `self.value` 是否已经有了一个 `Some` 的结果值，若存在，则返回 `Some` 中的值而不是再次执行闭包。

若 `self.value` 是 `None`，则会调用 `self.calc` 中存储的闭包，并将结果保存到 `self.value` 同时返回结果值。

然后就可以在 `run` 函数中定义并使用：

```rust
fn run(n: i32) {
    let mut closure_cache = Cacher::new(|x| x + 1);

    if n < 10 {
        println!("{}", closure_cache.value(n));
        println!("{}", closure_cache.value(n));
    } else if n < 20 {
        println!("{}", closure_cache.value(n + 1));
    } else if n < 30 && n % 3 == 0 {
        println!("{}", closure_cache.value(n + 1));
    } else {
        println!("Do nothing");
    }
}
```

不同于直接将闭包保存进变量，而是保存一个 `Cacher` 实例来存放闭包，接着可以在多个地方调用，但实际计算只会执行一次。

### Cacher 实现的限制

`Cacher` 实例对于 `value` 方法的任何 `arg` 参数的值都会返回相同的值：

```rust
let mut closure_cache = Cacher::new(|x| x);
// 都打印 1
println!("{}", closure_cache.value(1));
println!("{}", closure_cache.value(2));
println!("{}", closure_cache.value(3));
```

第一次调用后，由于 `Cacher` 实例将 `Some(1)` 保存进 `self.value`。在这之后无论传递什么参数调用 `value`，总是会返回 1。

---

可以通过再增加一个 `arg` 字段用来存放之前传递的参数，若再次调用的参数和之前的一致，则直接返回 `value` 字段的值，否则再次调用闭包，并将参数和结果保存。

```rust
struct Cacher<F>
where
    F: Fn(i32) -> i32,
{
    calc: F,
    value: Option<i32>,
    arg: Option<i32>,
}

impl<F> Cacher<F>
where
    F: Fn(i32) -> i32,
{
    fn new(calc: F) -> Self {
        Self {
            calc,
            value: None,
            arg: None,
        }
    }

    fn value(&mut self, arg: i32) -> i32 {
        match self.value {
            Some(v) => match self.arg {
                Some(a) => {
                    if a == arg {
                        v
                    } else {
                        let v = (self.calc)(arg);
                        self.value = Some(v);
                        self.arg = Some(arg);
                        v
                    }
                }
                None => v,
            },
            None => {
                let v = (self.calc)(arg);
                self.value = Some(v);
                self.arg = Some(arg);
                v
            }
        }
    }
}
```

这种做法显得十分繁琐，且含有重复代码，更好的做法是使用哈希 map 来存放值。将 `arg` 作为 key，而闭包调用的结果作为 value，这样只需要使用 `entry` 和 `or_insert` 方法即可实现相同的功能。

```rust
struct Cacher<F>
where
    F: Fn(i32) -> i32,
{
    calc: F,
    value: HashMap<i32, i32>,
}

impl<F> Cacher<F>
where
    F: Fn(i32) -> i32,
{
    fn new(calc: F) -> Self {
        Self {
            calc,
            value: HashMap::new(),
        }
    }

    fn value(&mut self, arg: i32) -> i32 {
        *self.value.entry(arg).or_insert((self.calc)(arg))
    }
}
```

## 闭包原理

Rust 中的闭包是通过一个特殊的结构体实现的。具体来说，每个闭包都是一个结构体对象，其中包含了闭包的代码和从环境中捕获的变量。这个结构体对象实现了一个或多个 `Fn` trait，以便可以像函数一样使用它。当定义一个闭包时，编译器会根据闭包的代码和捕获的变量生成一个结构体类型，这个结构体类型实现了对应的 trait。

如以下代码定义了一个闭包 `add_x` 并调用。

```rust
let x = 10;
let add_x = |y| x + y;
println!("{}", add_x(5));
```

编译时会将这个闭包转换为类似如下的结构体类型。

```rust
struct Closure {
    x: i32,
}

impl FnOnce<(i32,)> for Closure {
    type Output = i32;
    fn call_once(self, args: (i32,)) -> Self::Output {
        self.x + args.0
    }
}

impl FnMut<(i32,)> for Closure {
    fn call_mut(&mut self, args: (i32,)) -> Self::Output {
        self.x + args.0
    }
}

impl Fn<(i32,)> for Closure {
    extern "rust-call" fn call(&self, args: (i32,)) -> Self::Output {
        self.x + args.0
    }
}
```

当闭包被调用时，实际上是通过调用结构体的方法来执行的。

# 2 错误处理

Rust 有两种错误类别：**可恢复错误**和**不可恢复错误**。前者通常代表向用户报告错误并重试操作，如未找到文件。后者通常是 Bug，如尝试访问超过数组索引的位置。

其它语言通常不区分这两类，而是采用异常处理的方式。Rust 没有异常，但有可恢复错误 `Result<T, E>` 和不可恢复错误 `panic!`。

## panic! 与不可恢复错误

当执行 `panic!` 宏时，会打印出错误信息，展开并清理栈数据，然后退出。出现这种情况的场景通常是检测到一些类型的 Bug，而程序并不清楚该如何处理。

当出现 panic 时，程序默认会进行**栈展开**。Rust 会回溯栈并清理它遇到的每一个函数的数据。另一种是直接**终止**，这会不清理数据就退出程序，程序所使用的内存由操作系统来清理。通过在 *Cargo.toml* 的 `[profile]` 部分增加 `panic = "abort"`，可在 panic 时由栈展开切换为终止。

```toml
[profile.release]
panic = "abort"
```

**文件：main.rs**

```rust
panic!("Crash here!");
```

输出包含 `panic!` 调用造成的错误信息。第一行显示了 panic 提供的信息并指明了源码中 panic 出现的位置。

```rust
thread 'main' panicked at 'Crash here!', src\main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
error: process didn't exit successfully: 
```

在这个例子中，被指明的那一行是代码的一部分，且查看这一行的话会发现 `panic!` 宏的调用。在其他情况下，`panic!` 可能会出现在代码所调用的代码中。错误信息报告的文件名和行号可能指向其它代码中的 `panic!` 宏调用，而不是此代码中最终导致 `panic!` 的那一行。

### 使用 panic! 的 backtrace

可以通过 panic 时，被调函数的 backtrace 来寻找具体出问题的地方。

```rust
let v = vec![1, 2, 3];
v[9];
```

尝试访问 vector 的第 10 个元素，越界会导致 panic。`[]` 应当返回一个元素，若传递了一个无效索引，则没有可供 Rust 返回的正确的元素。

通过设置环境变量来设置 backtrace：

```shell
# Windows Powershell
$env:RUST_BACKTRACE=1; cargo run

# Windows CMD
set RUST_BACKTRACE=1 && cargo run

# Linux
RUST_BACKTRACE=1 cargo run
```

然后就可以看到带有 backtrace 的错误信息：

```
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 9', src\main.rs:3:5
stack backtrace:
   0: std::panicking::begin_panic_handler
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a\/library\std\src\panicking.rs:498 
   1: core::panicking::panic_fmt
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a\/library\core\src\panicking.rs:116
   2: core::panicking::panic_bounds_check
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a\/library\core\src\panicking.rs:84
   3: core::slice::index::impl$2::index<i32>
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a\library\core\src\slice\index.rs:189
   4: core::slice::index::impl$0::index<i32,usize>
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a\library\core\src\slice\index.rs:15
   5: alloc::vec::impl$15::index<i32,usize,alloc::alloc::Global>
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a\library\alloc\src\vec\mod.rs:2520
   6: exp::main
             at .\src\main.rs:3
   7: core::ops::function::FnOnce::call_once<void (*)(),tuple$<> >
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a\library\core\src\ops\function.rs:227
```

在 Debug 下才能获取带有这些信息的 backtrace，其中第 6 个指向了 *src/main.rs* 的第 3 行，可以根据这些回溯信息来定位错误。

## Result 与可恢复的错误

大部分错误并没有严重到需要程序完全停止执行。Rust 中有一个 `Result` 枚举，定义有 `Ok` 和 `Err` 这两个成员：

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`T` 和 `E` 是泛型类型参数，`T` 代表成功时返回的 `Ok` 成员中的数据类型，而 `E` 代表失败时返回的 `Err` 成员中的数据类型。因此可以将 `Result` 类型和标准库中为其定义的函数用于多种场景，这些情况中需要返回的成功值和失败值可能会各不相同。

```rust
use std::fs::File;

fn main() {
    let f = match File::open("hello.txt") {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}
```

这里使用 match 表达式来处理 `File::open` 所返回的值，该函数会打开一个文件，并返回一个 `Result<T, E>`。泛型参数 `T` 表示成功值的类型 `std::fs::File`，失败值 `E` 的类型是 `std::io::Error`。`Result` 枚举可以提供这些信息，成功则返回一个包含文件句柄的 `Ok` 实例，失败则返回错误信息的 `Err` 实例，如文件不存在或没有访问权限等。

### 匹配不同的错误

大部分情况下并不是任何错误都将程序 panic，而是根据错误类型来进行不同的处理方式，因此可以用 `match` 表达式匹配不同的错误。

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = match File::open("hello.txt") {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            _ => panic!("Problem opening the file: {:?}", error),
        },
    };
}
```

`File::open` 返回的 `Err` 成员中的值类型 `io::Error`，它是一个标准库中提供的结构体。这个结构体有一个返回 `io::ErrorKind` 值的 `kind` 方法可供调用。`io::ErrorKind` 是一个标准库提供的枚举，它的成员对应 `io` 操作可能导致的不同错误类型。这里只处理 `ErrorKind::NotFound`，表示文件并不存在。

内层 `match` 中检查的条件是 `error.kind()` 的返回值是否为 `ErrorKind`的 `NotFound` 成员。如果是，则尝试通过 `File::create` 创建文件。但创建文件也可能会失败，因此还需要再增加一个内层 `match`。当文件不能被打开，会打印出一个不同的错误信息。外层 `match` 的最后一个分支保持不变，这样对任何除了文件不存在的错误会使程序 panic。

### unwrap 和 expect

频繁的使用 `match` 会显得十分冗长而繁琐。`Result<T, E>` 类型定义了很多辅助方法来处理各种情况。其中之一叫做 `unwrap`，若 `Result` 值是成员 `Ok`，`unwrap` 会返回 `Ok` 中的值。若 `Result` 是成员 `Err`，`unwrap` 会直接调用 `panic!`。

```rust
let f = File::open("hello.txt").unwrap();
```

发生错误时 `unwrap` 会直接导致 panic，且没有额外的错误信息。此时可以使用 `expect`，它的行为与 `unwrap`，但可以提供额外的信息。

```rust
let f = File::open("hello.txt").expect("Failed to open hello.txt");
```

>   当使用 unwrap 或 expect 时，就相当于不管发生什么类型的错误，都只会发生 panic，而不是根据错误类型来进行处理。

### 传播错误

当一个函数可能会发生错误时，除了在这个函数中处理外，还可以选择让调用者来处理，称为**传播错误**。这样能更好的控制代码调用，因为调用者可能比被调用者拥有更多信息或逻辑来决定应该如何处理错误。

要传播错误，可以将错误返回：

```rust
use std::fs::File;
use std::io::{self, Read};

fn main() {
    let s = read_content("hello.txt").unwrap();
    println!("{}", s);
}

fn read_content(path: &str) -> Result<String, io::Error> {
    let mut f = match File::open(path) {
        Ok(file) => file,
        Err(error) => return Err(error),
    };

    let mut s = String::new();
    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}
```

该函数返回一个 `Result<String, io::Error>` 类型的值。若没有任何错误并成功返回，则调用者会收到一个包含 `String` 的 `Ok` 值。若遇到任何错误，则调用者会收到一个包含 `io::Error` 的 `Err` 值。`File::open` 和 `read_to_string` 都返回 `io::Error` 类型的错误值。

接着使用 `match` 处理 `File::open` 返回的 `Result`。如果错误，则返回 `Err` 实例。`read_to_string` 方法也返回一个 `Result`，同样使用 `match` 来处理。

### 简化传播错误

使用传播错误的模式十分常见，因此 Rust 提供了 `?`  运算符来简化。

```rust
fn read_content(path: &str) -> Result<String, io::Error> {
    let mut f = File::open(path)?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}
```

`Result` 值之后的 `?` 运算符被定义为与使用 `match` 表达式有着完全相同的处理方式。若 `Result` 的值为 `Ok`，则会返回 `Ok` 中的值而程序将继续执行。若值为 `Err`，则使用 `Err` 作为返回值从函数中提前返回。

与使用 `match` 不同的是，`?` 运算符所使用接收的错误值被传递给了 `from` 函数，它定义于标准库的 `From` trait 中，其用来将错误从一种类型转换为另一种类型。当 `?` 运算符调用 `from` 函数时，收到的错误类型被转换为**由当前函数返回类型所指定的错误类型**。这在当函数返回单个错误类型来代表所有可能失败的方式时十分有效，即使其可能会因很多种原因失败。只要每一个错误类型都实现了 `from` 函数来定义如何将自身转换为返回的错误类型，`?` 运算符会自动处理这些转换。

还可以在 `?` 之后使用链式方法调用来进一步简化代码：

```rust
fn read_content(path: &str) -> Result<String, io::Error> {
    let mut s = String::new();
    File::open(path)?.read_to_string(&mut s)?;
    Ok(s)
}
```

`File::open(path)?` 直接链式调用了 `read_to_string`。仍然需要 `read_to_string` 调用结尾的 `?`，而且当 `File::open` 和 `read_to_string` 都成功没有失败时返回包含用户名 `s` 的 `Ok` 值。

---

将文件读取到一个字符串是相当常见的操作，所以标准库提供了名为 `fs::read_to_string` 的函数，它会打开文件、新建一个 `String`、读取文件的内容，并将内容放入 `String` 并返回。

```rust
fn read_content(path: &str) -> Result<String, io::Error> {
    fs::read_to_string(path)
}
```

---

`?` 运算符只能被用于返回值与 `?` 作用的值相兼容的函数，因为 `?` 运算符被定义为从函数中提前返回一个值，如果要在 `main` 函数中使用，需要修改其返回值。`main` 函数是可执行程序的入口点和退出点，为了使程序能正常工作，可以返回的类型是有限制的，但可以返回 `Result<(), E>`。

```rust
fn main() -> Result<(), io::Error> {
    let f = File::open("hello")?;
    Ok(())
}
```

`?` 也可用于 `Option<T>` 值，同样只能在返回 `Option` 的函数中使用。在 `Option<T>` 上调用 `?` 运算符的行为与 `Result<T, E>` 类似：若值是 `None`，此时 `None` 会从函数中提前返回；若值是 `Some`，`Some` 中的值作为表达式的返回值，并继续执行。

```rust
fn plus_one(n: Option<i32>) -> Option<i32> {
    Some(n? + 1)
}
```

`?` 实际上就是 `try!` 宏的语法糖，两者都会尝试将错误类型转换为匹配返回的错误类型（前提是实现了 `From` trait），用 `match` 表达式的伪代码大致表示为：

```rust
macro try {
    match exp {
        Ok(val) => val,
        Err(err) => {
            let converted = From::from(err);
            return Err(converted);
        }
    }
}
```

>   目前 `try!` 已不常用。

