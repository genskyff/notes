第1章 入门指南
  安装
    在Linux或macOS环境中安装Rust
    在Windows环境中安装Rust
    更新与卸载
    常见问题
    本地文档
  Hello, World!
    创建一个文件夹
    编写并运行一个Rust程序
    对这个程序的剖析
    编译与运行是两个不同的步骤
  Hello, Cargo!
    使用Cargo创建一个项目
    使用Cargo构建和运行项目
    以Release模式进行构建
    学会习惯Cargo
  总结
第2章 编写一个猜数游戏
  创建一个新的项目
  处理一次猜测
    使用变量来存储值
    使用Result类型来处理可能失败的情况
    通过println! 中的占位符输出对应的值
    尝试运行代码
  生成一个保密数字
    借助包来获得更多功能
    生成一个随机数
  比较猜测数字与保密数字
  使用循环来实现多次猜测
    在猜测成功时优雅地退出
    处理非法输入
  总结
第3章 通用编程概念
  变量与可变性
    变量与常量之间的不同
    隐藏
  数据类型
    标量类型
    复合类型
  函数
    函数参数
    函数体中的语句和表达式
    函数的返回值
  注释
  控制流
    if表达式
    使用循环重复执行代码
  总结
第4章 认识所有权
  什么是所有权
    所有权规则
    变量作用域
    String类型
    内存与分配
    所有权与函数
    返回值与作用域
  引用与借用
    可变引用
    悬垂引用
    引用的规则
  切片
    字符串切片
    其他类型的切片
  总结
第5章 使用结构体来组织相关联的数据
  定义并实例化结构体
    在变量名与字段名相同时使用简化版的字段初始化方法
    使用结构体更新语法根据其他实例创建新实例
    使用不需要对字段命名的元组结构体来创建不同的类型
    没有任何字段的空结构体
  一个使用结构体的示例程序
    使用元组来重构代码
    使用结构体来重构代码：增加有意义的描述信息
    通过派生trait增加实用功能
  方法
    定义方法
    带有更多参数的方法
    关联函数
    多个impl块
  总结
第6章 枚举与模式匹配
  定义枚举
    枚举值
    Option枚举及其在空值处理方面的优势
  控制流运算符match
    绑定值的模式
    匹配Option<T>
    匹配必须穷举所有的可能
    _通配符
  简单控制流if let
  总结
第7章 使用包、单元包及模块来管理日渐复杂的项目
  包与单元包
  通过定义模块来控制作用域及私有性
  用于在模块树中指明条目的路径
    使用pub关键字来暴露路径
    使用super关键字开始构造相对路径
    将结构体或枚举声明为公共的
  用use关键字将路径导入作用域
    创建use路径时的惯用模式
    使用as关键字来提供新的名称
    使用pub use重导出名称
    使用外部包
    使用嵌套的路径来清理众多use语句
    通配符
  将模块拆分为不同的文件
  总结
第8章 通用集合类型
  使用动态数组存储多个值
    创建动态数组
    更新动态数组
    销毁动态数组时也会销毁其中的元素
    读取动态数组中的元素
    遍历动态数组中的值
    使用枚举来存储多个类型的值
  使用字符串存储UTF-8编码的文本
    字符串是什么
    创建一个新的字符串
    更新字符串
    字符串索引
    字符串切片
    遍历字符串的方法
    字符串的确没那么简单
  在哈希映射中存储键值对
    创建一个新的哈希映射
    哈希映射与所有权
    访问哈希映射中的值
    更新哈希映射
    哈希函数
  总结
第9章 错误处理
  不可恢复错误与panic!
    使用panic!产生的回溯信息
  可恢复错误与Result
    匹配不同的错误
    失败时触发panic的快捷方式：unwrap和expect
    传播错误
  要不要使用panic!
    示例、原型和测试
    当你比编译器拥有更多信息时
    错误处理的指导原则
    创建自定义类型来进行有效性验证
  总结
第10章 泛型、trait与生命周期
  通过将代码提取为函数来减少重复工作
  泛型数据类型
    在函数定义中
    在结构体定义中
    在枚举定义中
    在方法定义中
    泛型代码的性能问题
  trait：定义共享行为
    定义trait
    为类型实现trait
    默认实现
    使用trait作为参数
    返回实现了trait的类型
    使用trait约束来修复largest函数
    使用trait约束来有条件地实现方法
  使用生命周期保证引用的有效性
    使用生命周期来避免悬垂引用
    借用检查器
    函数中的泛型生命周期
    生命周期标注语法
    函数签名中的生命周期标注
    深入理解生命周期
    结构体定义中的生命周期标注
    生命周期省略
    方法定义中的生命周期标注
    静态生命周期
  同时使用泛型参数、trait约束与生命周期
  总结
第11章 编写自动化测试
  如何编写测试
    测试函数的构成
    使用assert!宏检查结果
    使用assert_eq!宏和assert_ne!宏判断相等性
    添加自定义的错误提示信息
    使用should_panic检查panic
    使用Result<T, E>编写测试
  控制测试的运行方式
    并行或串行地进行测试
    显示函数输出
    只运行部分特定名称的测试
    通过显式指定来忽略某些测试
  测试的组织结构
    单元测试
    集成测试
  总结
第12章 I/O项目：编写一个命令行程序
  接收命令行参数
    读取参数值
    将参数值存入变量
  读取文件
  重构代码以增强模块化程度和错误处理能力
    二进制项目的关注点分离
    修复错误处理逻辑
    从main中分离逻辑
    将代码分离为独立的代码包
  使用测试驱动开发来编写库功能
    编写一个会失败的测试
    编写可以通过测试的代码
  处理环境变量
    为不区分大小写的search函数编写一个会失败的测试
    实现search_case_insensitive函数
  将错误提示信息打印到标准错误而不是标准输出
    确认错误被写到了哪里
    将错误提示信息打印到标准错误
  总结
第13章 函数式语言特性：迭代器与闭包
  闭包：能够捕获环境的匿名函数
    使用闭包来创建抽象化的程序行为
    闭包的类型推断和类型标注
    使用泛型参数和Fn trait来存储闭包
    Cacher实现的局限性
    使用闭包捕获上下文环境
  使用迭代器处理元素序列
    Iterator trait和next方法
    消耗迭代器的方法
    生成其他迭代器的方法
    使用闭包捕获环境
    使用Iterator trait来创建自定义迭代器
  改进I/O项目
    使用迭代器代替clone
    使用迭代器适配器让代码更加清晰
  比较循环和迭代器的性能
  总结
第14章 进一步认识Cargo及crates.io
  使用发布配置来定制构建
  将包发布到crates.io上
    编写有用的文档注释
    使用pub use来导出合适的公共API
    创建crates.io账户
    为包添加元数据
    发布到crates.io
    发布已有包的新版本
    使用cargo yank命令从cargo.io上移除版本
  Cargo工作空间
    创建工作空间
    在工作空间中创建第二个包
  使用cargo install从crates.io上安装可执行程序
  使用自定义命令扩展Cargo的功能
  总结
第15章 智能指针
  使用Box<T>在堆上分配数据
    使用Box<T>在堆上存储数据
    使用装箱定义递归类型
  通过Deref trait将智能指针视作常规引用
    使用解引用运算符跳转到指针指向的值
    把Box<T>当成引用来操作
    定义我们自己的智能指针
    通过实现Deref trait来将类型视作引用
    函数和方法的隐式解引用转换
    解引用转换与可变性
  借助Drop trait在清理时运行代码
    使用std::mem::drop提前丢弃值
  基于引用计数的智能指针Rc<T>
    使用Rc<T>共享数据
    克隆Rc<T>会增加引用计数
  RefCell<T>和内部可变性模式
    使用RefCell<T>在运行时检查借用规则
    内部可变性：可变地借用一个不可变的值
    将Rc<T>和RefCell<T>结合使用来实现一个拥有多重所有权的可变数据
  循环引用会造成内存泄漏
    创建循环引用
    使用Weak<T>代替Rc<T>来避免循环引用
  总结
第16章 无畏并发
  使用线程同时运行代码
    使用spawn创建新线程
    使用join句柄等待所有线程结束
    在线程中使用move闭包
  使用消息传递在线程间转移数据
    通道和所有权转移
    发送多个值并观察接收者的等待过程
    通过克隆发送者创建多个生产者
  共享状态的并发
    互斥体一次只允许一个线程访问数据
    RefCell<T>/Rc<T>和Mutex<T>/Arc<T>之间的相似性
  使用Sync trait和Send trait对并发进行扩展
    允许线程间转移所有权的Send trait
    允许多线程同时访问的Sync trait
    手动实现Send和Sync是不安全的
  总结
第17章 Rust的面向对象编程特性
  面向对象语言的特性
    对象包含数据和行为
    封装实现细节
    作为类型系统和代码共享机制的继承
  使用trait对象来存储不同类型的值
    为共有行为定义一个trait
    实现trait
    trait对象会执行动态派发
    trait对象必须保证对象安全
  实现一种面向对象的设计模式
    定义Post并新建一个处于草稿状态下的新实例
    存储文章内容的文本
    确保草稿的可读内容为空
    请求审批文章并改变其状态
    添加approve方法来改变content的行为
    状态模式的权衡取舍
  总结
第18章 模式匹配
  所有可以使用模式的场合
    match分支
    if let条件表达式
    while let条件循环
    for循环
    let语句
    函数的参数
  可失败性：模式是否会匹配失败
  模式语法
    匹配字面量
    匹配命名变量
    多重模式
    使用...来匹配值区间
    使用解构来分解值
    忽略模式中的值
    使用匹配守卫添加额外条件
    @绑定
  总结
第19章 高级特性
  不安全Rust
    不安全超能力
    解引用裸指针
    调用不安全函数或方法
    访问或修改一个可变静态变量
    实现不安全trait
    使用不安全代码的时机
  高级trait
    在trait的定义中使用关联类型指定占位类型
    默认泛型参数和运算符重载
    用于消除歧义的完全限定语法：调用相同名称的方法
    用于在trait中附带另外一个trait功能的超trait
    使用newtype模式在外部类型上实现外部trait
  高级类型
    使用newtype模式实现类型安全与抽象
    使用类型别名创建同义类型
    永不返回的Never类型
    动态大小类型和Sized trait
  高级函数与闭包
    函数指针
    返回闭包
  宏
    宏与函数之间的差别
    用于通用元编程的macro_rules!声明宏
    基于属性创建代码的过程宏
    如何编写一个自定义derive宏
    属性宏
    函数宏
  总结
第20章 最后的项目：构建多线程Web服务器
  构建单线程Web服务器
    监听TCP连接
    读取请求
    仔细观察HTTP请求
    编写响应
    返回真正的HTML
    验证请求有效性并选择性地响应
    少许重构
  把单线程服务器修改为多线程服务器
    在现有的服务器实现中模拟一个慢请求
    使用线程池改进吞吐量
  优雅地停机与清理
    为ThreadPool实现Drop trait
    通知线程停止监听任务
  总结
附录A 关键字
  当前正在使用的关键字
  将来可能会使用的保留关键字
  原始标识符
附录B 运算符和符号
  运算符
  非运算符符号
附录C 可派生trait
  面向程序员格式化输出的Debug
  用于相等性比较的PartialEq和Eq
  使用PartialOrd和Ord进行次序比较
  使用Clone和Copy复制值
  用于将值映射到另外一个长度固定的值的Hash
  用于提供默认值的Default
附录D 有用的开发工具
  使用rustfmt自动格式化代码
  使用rustfix修复代码
  使用Clippy完成更多的代码分析
  使用Rust语言服务器来集成IDE
附录E 版本
封底
扉页
内容简介
版权页
译者序
序
前言
致谢
关于技术审校者
目录
第1章 入门指南
  安装
    在Linux或macOS环境中安装Rust
    在Windows环境中安装Rust
    更新与卸载
    常见问题
    本地文档
  Hello, World!
    创建一个文件夹
    编写并运行一个Rust程序
    对这个程序的剖析
    编译与运行是两个不同的步骤
  Hello, Cargo!
    使用Cargo创建一个项目
    使用Cargo构建和运行项目
    以Release模式进行构建
    学会习惯Cargo
  总结
第2章 编写一个猜数游戏
  创建一个新的项目
  处理一次猜测
    使用变量来存储值
    使用Result类型来处理可能失败的情况
    通过println! 中的占位符输出对应的值
    尝试运行代码
  生成一个保密数字
    借助包来获得更多功能
    生成一个随机数
  比较猜测数字与保密数字
  使用循环来实现多次猜测
    在猜测成功时优雅地退出
    处理非法输入
  总结
第3章 通用编程概念
  变量与可变性
    变量与常量之间的不同
    隐藏
  数据类型
    标量类型
    复合类型
  函数
    函数参数
    函数体中的语句和表达式
    函数的返回值
  注释
  控制流
    if表达式
    使用循环重复执行代码
  总结
第4章 认识所有权
  什么是所有权
    所有权规则
    变量作用域
    String类型
    内存与分配
    所有权与函数
    返回值与作用域
  引用与借用
    可变引用
    悬垂引用
    引用的规则
  切片
    字符串切片
    其他类型的切片
  总结
第5章 使用结构体来组织相关联的数据
  定义并实例化结构体
    在变量名与字段名相同时使用简化版的字段初始化方法
    使用结构体更新语法根据其他实例创建新实例
    使用不需要对字段命名的元组结构体来创建不同的类型
    没有任何字段的空结构体
  一个使用结构体的示例程序
    使用元组来重构代码
    使用结构体来重构代码：增加有意义的描述信息
    通过派生trait增加实用功能
  方法
    定义方法
    带有更多参数的方法
    关联函数
    多个impl块
  总结
第6章 枚举与模式匹配
  定义枚举
    枚举值
    Option枚举及其在空值处理方面的优势
  控制流运算符match
    绑定值的模式
    匹配Option<T>
    匹配必须穷举所有的可能
    _通配符
  简单控制流if let
  总结
第7章 使用包、单元包及模块来管理日渐复杂的项目
  包与单元包
  通过定义模块来控制作用域及私有性
  用于在模块树中指明条目的路径
    使用pub关键字来暴露路径
    使用super关键字开始构造相对路径
    将结构体或枚举声明为公共的
  用use关键字将路径导入作用域
    创建use路径时的惯用模式
    使用as关键字来提供新的名称
    使用pub use重导出名称
    使用外部包
    使用嵌套的路径来清理众多use语句
    通配符
  将模块拆分为不同的文件
  总结
第8章 通用集合类型
  使用动态数组存储多个值
    创建动态数组
    更新动态数组
    销毁动态数组时也会销毁其中的元素
    读取动态数组中的元素
    遍历动态数组中的值
    使用枚举来存储多个类型的值
  使用字符串存储UTF-8编码的文本
    字符串是什么
    创建一个新的字符串
    更新字符串
    字符串索引
    字符串切片
    遍历字符串的方法
    字符串的确没那么简单
  在哈希映射中存储键值对
    创建一个新的哈希映射
    哈希映射与所有权
    访问哈希映射中的值
    更新哈希映射
    哈希函数
  总结
第9章 错误处理
  不可恢复错误与panic!
    使用panic!产生的回溯信息
  可恢复错误与Result
    匹配不同的错误
    失败时触发panic的快捷方式：unwrap和expect
    传播错误
  要不要使用panic!
    示例、原型和测试
    当你比编译器拥有更多信息时
    错误处理的指导原则
    创建自定义类型来进行有效性验证
  总结
第10章 泛型、trait与生命周期
  通过将代码提取为函数来减少重复工作
  泛型数据类型
    在函数定义中
    在结构体定义中
    在枚举定义中
    在方法定义中
    泛型代码的性能问题
  trait：定义共享行为
    定义trait
    为类型实现trait
    默认实现
    使用trait作为参数
    返回实现了trait的类型
    使用trait约束来修复largest函数
    使用trait约束来有条件地实现方法
  使用生命周期保证引用的有效性
    使用生命周期来避免悬垂引用
    借用检查器
    函数中的泛型生命周期
    生命周期标注语法
    函数签名中的生命周期标注
    深入理解生命周期
    结构体定义中的生命周期标注
    生命周期省略
    方法定义中的生命周期标注
    静态生命周期
  同时使用泛型参数、trait约束与生命周期
  总结
第11章 编写自动化测试
  如何编写测试
    测试函数的构成
    使用assert!宏检查结果
    使用assert_eq!宏和assert_ne!宏判断相等性
    添加自定义的错误提示信息
    使用should_panic检查panic
    使用Result<T, E>编写测试
  控制测试的运行方式
    并行或串行地进行测试
    显示函数输出
    只运行部分特定名称的测试
    通过显式指定来忽略某些测试
  测试的组织结构
    单元测试
    集成测试
  总结
第12章 I/O项目：编写一个命令行程序
  接收命令行参数
    读取参数值
    将参数值存入变量
  读取文件
  重构代码以增强模块化程度和错误处理能力
    二进制项目的关注点分离
    修复错误处理逻辑
    从main中分离逻辑
    将代码分离为独立的代码包
  使用测试驱动开发来编写库功能
    编写一个会失败的测试
    编写可以通过测试的代码
  处理环境变量
    为不区分大小写的search函数编写一个会失败的测试
    实现search_case_insensitive函数
  将错误提示信息打印到标准错误而不是标准输出
    确认错误被写到了哪里
    将错误提示信息打印到标准错误
  总结
第13章 函数式语言特性：迭代器与闭包
  闭包：能够捕获环境的匿名函数
    使用闭包来创建抽象化的程序行为
    闭包的类型推断和类型标注
    使用泛型参数和Fn trait来存储闭包
    Cacher实现的局限性
    使用闭包捕获上下文环境
  使用迭代器处理元素序列
    Iterator trait和next方法
    消耗迭代器的方法
    生成其他迭代器的方法
    使用闭包捕获环境
    使用Iterator trait来创建自定义迭代器
  改进I/O项目
    使用迭代器代替clone
    使用迭代器适配器让代码更加清晰
  比较循环和迭代器的性能
  总结
第14章 进一步认识Cargo及crates.io
  使用发布配置来定制构建
  将包发布到crates.io上
    编写有用的文档注释
    使用pub use来导出合适的公共API
    创建crates.io账户
    为包添加元数据
    发布到crates.io
    发布已有包的新版本
    使用cargo yank命令从cargo.io上移除版本
  Cargo工作空间
    创建工作空间
    在工作空间中创建第二个包
  使用cargo install从crates.io上安装可执行程序
  使用自定义命令扩展Cargo的功能
  总结
第15章 智能指针
  使用Box<T>在堆上分配数据
    使用Box<T>在堆上存储数据
    使用装箱定义递归类型
  通过Deref trait将智能指针视作常规引用
    使用解引用运算符跳转到指针指向的值
    把Box<T>当成引用来操作
    定义我们自己的智能指针
    通过实现Deref trait来将类型视作引用
    函数和方法的隐式解引用转换
    解引用转换与可变性
  借助Drop trait在清理时运行代码
    使用std::mem::drop提前丢弃值
  基于引用计数的智能指针Rc<T>
    使用Rc<T>共享数据
    克隆Rc<T>会增加引用计数
  RefCell<T>和内部可变性模式
    使用RefCell<T>在运行时检查借用规则
    内部可变性：可变地借用一个不可变的值
    将Rc<T>和RefCell<T>结合使用来实现一个拥有多重所有权的可变数据
  循环引用会造成内存泄漏
    创建循环引用
    使用Weak<T>代替Rc<T>来避免循环引用
  总结
第16章 无畏并发
  使用线程同时运行代码
    使用spawn创建新线程
    使用join句柄等待所有线程结束
    在线程中使用move闭包
  使用消息传递在线程间转移数据
    通道和所有权转移
    发送多个值并观察接收者的等待过程
    通过克隆发送者创建多个生产者
  共享状态的并发
    互斥体一次只允许一个线程访问数据
    RefCell<T>/Rc<T>和Mutex<T>/Arc<T>之间的相似性
  使用Sync trait和Send trait对并发进行扩展
    允许线程间转移所有权的Send trait
    允许多线程同时访问的Sync trait
    手动实现Send和Sync是不安全的
  总结
第17章 Rust的面向对象编程特性
  面向对象语言的特性
    对象包含数据和行为
    封装实现细节
    作为类型系统和代码共享机制的继承
  使用trait对象来存储不同类型的值
    为共有行为定义一个trait
    实现trait
    trait对象会执行动态派发
    trait对象必须保证对象安全
  实现一种面向对象的设计模式
    定义Post并新建一个处于草稿状态下的新实例
    存储文章内容的文本
    确保草稿的可读内容为空
    请求审批文章并改变其状态
    添加approve方法来改变content的行为
    状态模式的权衡取舍
  总结
第18章 模式匹配
  所有可以使用模式的场合
    match分支
    if let条件表达式
    while let条件循环
    for循环
    let语句
    函数的参数
  可失败性：模式是否会匹配失败
  模式语法
    匹配字面量
    匹配命名变量
    多重模式
    使用...来匹配值区间
    使用解构来分解值
    忽略模式中的值
    使用匹配守卫添加额外条件
    @绑定
  总结
第19章 高级特性
  不安全Rust
    不安全超能力
    解引用裸指针
    调用不安全函数或方法
    访问或修改一个可变静态变量
    实现不安全trait
    使用不安全代码的时机
  高级trait
    在trait的定义中使用关联类型指定占位类型
    默认泛型参数和运算符重载
    用于消除歧义的完全限定语法：调用相同名称的方法
    用于在trait中附带另外一个trait功能的超trait
    使用newtype模式在外部类型上实现外部trait
  高级类型
    使用newtype模式实现类型安全与抽象
    使用类型别名创建同义类型
    永不返回的Never类型
    动态大小类型和Sized trait
  高级函数与闭包
    函数指针
    返回闭包
  宏
    宏与函数之间的差别
    用于通用元编程的macro_rules!声明宏
    基于属性创建代码的过程宏
    如何编写一个自定义derive宏
    属性宏
    函数宏
  总结