第1章   Rust入门
  1.1 Rust是什么，以及为何需要关注它
  1.2 安装Rust工具链
    rustup.rs
  1.3 Rust简介
    1.3.1  基元类型
    1.3.2  变量声明和不可变性
    1.3.3  函数
    1.3.4  闭包
    1.3.5  字符串
    1.3.6  条件和判断
    1.3.7  match表达式
    1.3.8  循环
    1.3.9  自定义数据类型
    1.3.10  类型上的函数和方法
    1.3.11  module、import和use语句
    1.3.12  集合
    1.3.13  迭代器
  1.4  改进字符计数器
  1.5 小结
第2章   使用Cargo管理项目
  2.1  软件包管理器
  2.2 模块
    2.2.1  嵌套模块
    2.2.2  将文件用作模块
    2.2.3  将目录用作模块
  2.3 Cargo和程序库
    2.3.1  新建一个Cargo 项目
    2.3.2  Cargo 与依赖项
    2.3.3  使用Cargo 执行测试
    2.3.4  使用Cargo 运行示例
    2.3.5  Cargo 工作区
  2.4 Cargo工具扩展
    2.4.1  子命令和Cargo 安装
    2.4.2  使用clippy 格式化代码
    2.4.3  Cargo.toml 清单文件简介
  2.5 搭建Rust开发环境
  2.6 使用Cargo构建imgtool程序
  2.7 小结
第3章   测试、文档化和基准评估
  3.1  测试的目的
  3.2  组织测试
    测试原语
  3.3  单元测试
    3.3.1  第一个单元测试
    3.3.2  运行测试
    3.3.3  隔离测试代码
    3.3.4  故障测试
    3.3.5  忽略测试
  3.4  集成测试
    3.4.1  第一个集成测试
    3.4.2  共享通用代码
  3.5 文档
    3.5.1  编写文档
    3.5.2  生成和查看文档
    3.5.3  托管文档
    3.5.4  文档属性
    3.5.5  文档化测试
  3.6 基准
    3.6.1  内置的微观基准工具
    3.6.2  稳定版Rust上的基准测试
  3.7  编写和测试软件包——逻辑门模拟器
  3.8  CI集成测试与Travis CI
  3.9 小结
第4章   类型、泛型和特征
  4.1  类型系统及其重要性
  4.2 泛型
    4.2.1  创建泛型#
    4.2.2  泛型实现
    4.2.3  泛型应用
  4.3  用特征抽象行为
    4.3.1  特征
    4.3.2  特征的多种形式
  4.4  使用包含泛型的特征——特征区间
    4.4.1  类型上的特征区间
    4.4.2  泛型函数和impl 代码块上的特征区间
    4.4.3  使用“+”将特征组合为区间
    4.4.4  特征区间与impl 特征语法
  4.5  标准库特征简介
  4.6  使用特征对象实现真正的多态性
    4.6.1  分发
    4.6.2  特征对象
  4.7 小结
第5章   内存管理和安全性
  5.1  程序和内存
  5.2  程序如何使用内存
  5.3  内存管理及其分类
  5.4  内存分配简介
    5.4.1  堆栈
    5.4.2  堆
  5.5  内存管理的缺陷
  5.6 内存安全性
  5.7 内存安全三原则
    5.7.1 所有权
      作用域简介
      移动和复制语义
    5.7.2 通过特征复制类型
      所有权的应用
      闭包中的所有权
    5.7.3 借用
      借用规则
      借用实践
        函数中的借用
        匹配中的借用
        从函数返回引用
    5.7.4 基于借用规则的方法类型
    5.7.5 生命周期
      生命周期参数
      生命周期省略规则
      自定义类型中的生命周期
      impl 代码块中的生命周期
      多个生命周期
      生命周期子类型
      在泛型上声明生命周期区间
  5.8 Rust 中的指针类型
    5.8.1 引用——安全的指针
    5.8.2 原始指针
    5.8.3 智能指针
    5.8.4 引用计数的智能指针
    5.8.5 内部可变性的应用
  5.9 小结
第6章    异常处理
  6.1  异常处理简介
  6.2  可恢复的异常
    6.2.1  Option
    6.2.2  Result
  6.3  Option/Result的组合
    6.3.1  常见的组合器
    6.3.2  组合器应用
    6.3.3  Option和Result类型之间的转换
  6.4  及早返回和运算符“？”
  6.5  不可恢复的异常
    人机友好的灾难性故障
  6.6  自定义错误和 Error特征
  6.7 小结
第7章   高级概念
  7.1  类型系统简介
    7.1.1  代码块和表达式
    7.1.2  let语句
    7.1.3  循环作为表达式
    7.1.4  数字类型中的类型清晰度和符号区分
    7.1.5  类型推断
    7.1.6  类型别名
  7.2 字符串
    7.2.1 包含所有权的字符串——String
    7.2.2 借用字符串——&str
    7.2.3 字符串切片和分块
    7.2.4 在函数中使用字符串
      所以再强调一遍：如果你需要将一个字符串传递给你的函数，那么请使用字符串切片&str
    7.2.5 字符串拼接
    7.2.6 &str 和 String 的应用场景
      尽可能使用带有&str 类型的 API
  7.3 全局值
    7.3.1 常量
    7.3.2 静态值
      具有固定的内存位置
    7.3.3 编译期函数——const fn
    7.3.4 通过 lazy_static!宏将静态值动态化
  7.4 迭代器
    实现自定义迭代器
  7.5 高级类型
    7.5.1 不定长类型
    7.5.2 函数类型
    7.5.3 never 类型“!”和函数分发
    7.5.4 联合
    7.5.5 Cow
  7.6 高级特征
    7.6.1 Sized 和?Sized
    7.6.2 Borrow 和 AsRef
    7.6.3 ToOwned
    7.6.4 From 和 Into
    7.6.5 特征对象和对象安全性
    7.6.6 通用函数调用语法
    7.6.7 特征规则
  7.7 闭包进阶
    7.7.1 Fn 闭包
    7.7.2 FnMut 闭包
    7.7.3 FnOnce 闭包
  7.8 结构体、枚举和特征中的常量
  7.9  模块、路径和导入
    7.9.1  导入
    7.9.2  再次导出
    7.9.3  隐私性
  7.10  高级匹配模式和守护
    7.10.1  匹配守护
    7.10.2  高级let构造
  7.11 强制类型转换
    可以将类型的引用类型转换为它的特征对象
    变形transmute
  7.12 类型与内存
    7.12.1 内存对齐
    7.12.2 std::mem 模块
  7.13 使用 serde 进行序列化和反序列化
  7.14 小结
第8章   并发
  8.1 程序执行模型
  8.2 并发
    8.2.1 并发方法
      以内核为基础
      用户级别
    8.2.2 缺陷
      条件竞争
      数据竞争
      内存不安全性和未定义的行为
      死锁
  8.3 Rust 中的并发
    8.3.1 线程基础
    8.3.2 自定义线程
    8.3.3 访问线程中的数据
  8.4 线程的并发模型
    8.4.1 状态共享模型
      修改线程中的共享数据
    8.4.2 互斥
    8.4.3 通过 Arc 和 Mutex 实现共享可变性
    8.4.4 通过消息传递进行通信
  8.5 Rust中的线程安全
    8.5.1  什么是线程安全
    8.5.2  线程安全的特征
    8.5.3  Send
    8.5.4  Sync
  8.6 使用actor模型实现并发
  8.7  其他程序库
  8.8 小结
第9章   宏与元编程
  9.1  什么是元编程？
  9.2 Rust宏的应用场景
  9.3 Rust中的宏及其类型
    宏的类型
  9.4 使用macro_rules!创建宏
  9.5  标准库中的内置宏
  9.6 macro_rules!宏的标记类型
  9.7  宏中的重复
  9.8  宏的高级应用——为 HashMap的初始化编写DSL
  9.9  宏用例——编写测试
  9.10 练习
  9.11  过程宏
  9.12  派生宏
  9.13  调试宏程序
  9.14  常用的过程宏软件包
  9.15 小结
第10章   不安全的Rust和外部函数接口
  10.1  安全与不安全
    10.1.1  不安全的函数和代码块
    10.1.2  不安全的特征和实现
  10.2 在Rust中调用C代码
  10.3 通过C语言调用Rust代码
  10.4 在Rust使用外部C/C++程序库
  10.5 使用PyO3构造原生Python扩展
  10.6 在Rust中为Node.js创建原生扩展
  10.7 小结
第11章   日志
  11.1  日志记录及其重要性
  11.2  日志记录框架的需求
  11.3  日志记录框架及其特性
  11.4  日志记录方法
    11.4.1  非结构化日志记录
    11.4.2  结构化日志记录
  11.5 Rust中的日志记录
    11.5.1  log  ——为Rust日志记录提供外观
    11.5.2  env_logger
    11.5.3  log4rs
    11.5.4  使用slog 进行结构化日志记录
  11.6 小结
第12章   Rust与网络编程
  12.1  网络编程简介
  12.2  同步网络 I/O
    构建同步Redis服务器
  12.3  异步网络 I/O
    12.3.1  Rust中的异步抽象
    12.3.2  构建异步的Redis服务器
  12.4 小结
第13章   用Rust构建Web应用程序
  13.1 Rust中的Web应用
  13.2 用hyper进行HTTP通信
    13.2.1  hyper服务器端API——构建一个短网址服务
    13.2.2  作为客户端的hyper——构建一个URL短网址客户端
    13.2.3  Web框架
  13.3 actix-web基础知识
  13.4 使用actix-web构建一个书签API
  13.5 小结
第14章   Rust与数据库
  14.1  数据持久性的重要性
  14.2 SQLite
  14.3 PostgreSQL
  14.4 r2d2连接池
  14.5 Postgres和diesel ORM
  14.6 小结
第15章   Rust与WebAssembly
  15.1  什么是 WebAssmbly
  15.2 WebAssembly的设计目标
  15.3 WebAssembly入门
    15.3.1  在线尝试
    15.3.2  生成WebAssembly 的方法
  15.4 Rust和WebAssembly
    15.4.1  wasm-bindgen
    15.4.2  其他WebAssembly 项目
  15.5 小结
第16章   Rust与桌面应用
  16.1 GUI开发简介
  16.2 GTK+框架
  16.3 通过gtk-rs构建一个新闻类桌面应用程序
  16.4 练习
  16.5  其他新兴的 UI框架
  16.6 小结
第17章   调试
  17.1  调试简介
    17.1.1  调试器基础
    17.1.2  调试的先决条件
    17.1.3  配置GDB
    17.1.4  一个示例程序——buggie
    17.1.5  GDB基础知识
    17.1.6  在Visual Studio Code中集成GDB
  17.2  rr调试器简介
  17.3 小结
扉页
版权声明 
内容提要
作者简介
审稿人简介
前言
资源与支持
目录
第1章   Rust入门
  1.1 Rust是什么，以及为何需要关注它
  1.2 安装Rust工具链
    rustup.rs
  1.3 Rust简介
    1.3.1  基元类型
    1.3.2  变量声明和不可变性
    1.3.3  函数
    1.3.4  闭包
    1.3.5  字符串
    1.3.6  条件和判断
    1.3.7  match表达式
    1.3.8  循环
    1.3.9  自定义数据类型
    1.3.10  类型上的函数和方法
    1.3.11  module、import和use语句
    1.3.12  集合
    1.3.13  迭代器
  1.4  改进字符计数器
  1.5 小结
第2章   使用Cargo管理项目
  2.1  软件包管理器
  2.2 模块
    2.2.1  嵌套模块
    2.2.2  将文件用作模块
    2.2.3  将目录用作模块
  2.3 Cargo和程序库
    2.3.1  新建一个Cargo 项目
    2.3.2  Cargo 与依赖项
    2.3.3  使用Cargo 执行测试
    2.3.4  使用Cargo 运行示例
    2.3.5  Cargo 工作区
  2.4 Cargo工具扩展
    2.4.1  子命令和Cargo 安装
    2.4.2  使用clippy 格式化代码
    2.4.3  Cargo.toml 清单文件简介
  2.5 搭建Rust开发环境
  2.6 使用Cargo构建imgtool程序
  2.7 小结
第3章   测试、文档化和基准评估
  3.1  测试的目的
  3.2  组织测试
    测试原语
  3.3  单元测试
    3.3.1  第一个单元测试
    3.3.2  运行测试
    3.3.3  隔离测试代码
    3.3.4  故障测试
    3.3.5  忽略测试
  3.4  集成测试
    3.4.1  第一个集成测试
    3.4.2  共享通用代码
  3.5 文档
    3.5.1  编写文档
    3.5.2  生成和查看文档
    3.5.3  托管文档
    3.5.4  文档属性
    3.5.5  文档化测试
  3.6 基准
    3.6.1  内置的微观基准工具
    3.6.2  稳定版Rust上的基准测试
  3.7  编写和测试软件包——逻辑门模拟器
  3.8  CI集成测试与Travis CI
  3.9 小结
第4章   类型、泛型和特征
  4.1  类型系统及其重要性
  4.2 泛型
    4.2.1  创建泛型#
    4.2.2  泛型实现
    4.2.3  泛型应用
  4.3  用特征抽象行为
    4.3.1  特征
    4.3.2  特征的多种形式
  4.4  使用包含泛型的特征——特征区间
    4.4.1  类型上的特征区间
    4.4.2  泛型函数和impl 代码块上的特征区间
    4.4.3  使用“+”将特征组合为区间
    4.4.4  特征区间与impl 特征语法
  4.5  标准库特征简介
  4.6  使用特征对象实现真正的多态性
    4.6.1  分发
    4.6.2  特征对象
  4.7 小结
第5章   内存管理和安全性
  5.1  程序和内存
  5.2  程序如何使用内存
  5.3  内存管理及其分类
  5.4  内存分配简介
    5.4.1  堆栈
    5.4.2  堆
  5.5  内存管理的缺陷
  5.6 内存安全性
  5.7 内存安全三原则
    5.7.1 所有权
      作用域简介
      移动和复制语义
    5.7.2 通过特征复制类型
      所有权的应用
      闭包中的所有权
    5.7.3 借用
      借用规则
      借用实践
        函数中的借用
        匹配中的借用
        从函数返回引用
    5.7.4 基于借用规则的方法类型
    5.7.5 生命周期
      生命周期参数
      生命周期省略规则
      自定义类型中的生命周期
      impl 代码块中的生命周期
      多个生命周期
      生命周期子类型
      在泛型上声明生命周期区间
  5.8 Rust 中的指针类型
    5.8.1 引用——安全的指针
    5.8.2 原始指针
    5.8.3 智能指针
    5.8.4 引用计数的智能指针
    5.8.5 内部可变性的应用
  5.9 小结
第6章    异常处理
  6.1  异常处理简介
  6.2  可恢复的异常
    6.2.1  Option
    6.2.2  Result
  6.3  Option/Result的组合
    6.3.1  常见的组合器
    6.3.2  组合器应用
    6.3.3  Option和Result类型之间的转换
  6.4  及早返回和运算符“？”
  6.5  不可恢复的异常
    人机友好的灾难性故障
  6.6  自定义错误和 Error特征
  6.7 小结
第7章   高级概念
  7.1  类型系统简介
    7.1.1  代码块和表达式
    7.1.2  let语句
    7.1.3  循环作为表达式
    7.1.4  数字类型中的类型清晰度和符号区分
    7.1.5  类型推断
    7.1.6  类型别名
  7.2 字符串
    7.2.1 包含所有权的字符串——String
    7.2.2 借用字符串——&str
    7.2.3 字符串切片和分块
    7.2.4 在函数中使用字符串
      所以再强调一遍：如果你需要将一个字符串传递给你的函数，那么请使用字符串切片&str
    7.2.5 字符串拼接
    7.2.6 &str 和 String 的应用场景
      尽可能使用带有&str 类型的 API
  7.3 全局值
    7.3.1 常量
    7.3.2 静态值
      具有固定的内存位置
    7.3.3 编译期函数——const fn
    7.3.4 通过 lazy_static!宏将静态值动态化
  7.4 迭代器
    实现自定义迭代器
  7.5 高级类型
    7.5.1 不定长类型
    7.5.2 函数类型
    7.5.3 never 类型“!”和函数分发
    7.5.4 联合
    7.5.5 Cow
  7.6 高级特征
    7.6.1 Sized 和?Sized
    7.6.2 Borrow 和 AsRef
    7.6.3 ToOwned
    7.6.4 From 和 Into
    7.6.5 特征对象和对象安全性
    7.6.6 通用函数调用语法
    7.6.7 特征规则
  7.7 闭包进阶
    7.7.1 Fn 闭包
    7.7.2 FnMut 闭包
    7.7.3 FnOnce 闭包
  7.8 结构体、枚举和特征中的常量
  7.9  模块、路径和导入
    7.9.1  导入
    7.9.2  再次导出
    7.9.3  隐私性
  7.10  高级匹配模式和守护
    7.10.1  匹配守护
    7.10.2  高级let构造
  7.11 强制类型转换
    可以将类型的引用类型转换为它的特征对象
    变形transmute
  7.12 类型与内存
    7.12.1 内存对齐
    7.12.2 std::mem 模块
  7.13 使用 serde 进行序列化和反序列化
  7.14 小结
第8章   并发
  8.1 程序执行模型
  8.2 并发
    8.2.1 并发方法
      以内核为基础
      用户级别
    8.2.2 缺陷
      条件竞争
      数据竞争
      内存不安全性和未定义的行为
      死锁
  8.3 Rust 中的并发
    8.3.1 线程基础
    8.3.2 自定义线程
    8.3.3 访问线程中的数据
  8.4 线程的并发模型
    8.4.1 状态共享模型
      修改线程中的共享数据
    8.4.2 互斥
    8.4.3 通过 Arc 和 Mutex 实现共享可变性
    8.4.4 通过消息传递进行通信
  8.5 Rust中的线程安全
    8.5.1  什么是线程安全
    8.5.2  线程安全的特征
    8.5.3  Send
    8.5.4  Sync
  8.6 使用actor模型实现并发
  8.7  其他程序库
  8.8 小结
第9章   宏与元编程
  9.1  什么是元编程？
  9.2 Rust宏的应用场景
  9.3 Rust中的宏及其类型
    宏的类型
  9.4 使用macro_rules!创建宏
  9.5  标准库中的内置宏
  9.6 macro_rules!宏的标记类型
  9.7  宏中的重复
  9.8  宏的高级应用——为 HashMap的初始化编写DSL
  9.9  宏用例——编写测试
  9.10 练习
  9.11  过程宏
  9.12  派生宏
  9.13  调试宏程序
  9.14  常用的过程宏软件包
  9.15 小结
第10章   不安全的Rust和外部函数接口
  10.1  安全与不安全
    10.1.1  不安全的函数和代码块
    10.1.2  不安全的特征和实现
  10.2 在Rust中调用C代码
  10.3 通过C语言调用Rust代码
  10.4 在Rust使用外部C/C++程序库
  10.5 使用PyO3构造原生Python扩展
  10.6 在Rust中为Node.js创建原生扩展
  10.7 小结
第11章   日志
  11.1  日志记录及其重要性
  11.2  日志记录框架的需求
  11.3  日志记录框架及其特性
  11.4  日志记录方法
    11.4.1  非结构化日志记录
    11.4.2  结构化日志记录
  11.5 Rust中的日志记录
    11.5.1  log  ——为Rust日志记录提供外观
    11.5.2  env_logger
    11.5.3  log4rs
    11.5.4  使用slog 进行结构化日志记录
  11.6 小结
第12章   Rust与网络编程
  12.1  网络编程简介
  12.2  同步网络 I/O
    构建同步Redis服务器
  12.3  异步网络 I/O
    12.3.1  Rust中的异步抽象
    12.3.2  构建异步的Redis服务器
  12.4 小结
第13章   用Rust构建Web应用程序
  13.1 Rust中的Web应用
  13.2 用hyper进行HTTP通信
    13.2.1  hyper服务器端API——构建一个短网址服务
    13.2.2  作为客户端的hyper——构建一个URL短网址客户端
    13.2.3  Web框架
  13.3 actix-web基础知识
  13.4 使用actix-web构建一个书签API
  13.5 小结
第14章   Rust与数据库
  14.1  数据持久性的重要性
  14.2 SQLite
  14.3 PostgreSQL
  14.4 r2d2连接池
  14.5 Postgres和diesel ORM
  14.6 小结
第15章   Rust与WebAssembly
  15.1  什么是 WebAssmbly
  15.2 WebAssembly的设计目标
  15.3 WebAssembly入门
    15.3.1  在线尝试
    15.3.2  生成WebAssembly 的方法
  15.4 Rust和WebAssembly
    15.4.1  wasm-bindgen
    15.4.2  其他WebAssembly 项目
  15.5 小结
第16章   Rust与桌面应用
  16.1 GUI开发简介
  16.2 GTK+框架
  16.3 通过gtk-rs构建一个新闻类桌面应用程序
  16.4 练习
  16.5  其他新兴的 UI框架
  16.6 小结
第17章   调试
  17.1  调试简介
    17.1.1  调试器基础
    17.1.2  调试的先决条件
    17.1.3  配置GDB
    17.1.4  一个示例程序——buggie
    17.1.5  GDB基础知识
    17.1.6  在Visual Studio Code中集成GDB
  17.2  rr调试器简介
  17.3 小结