第4章   类型、泛型和特征
  4.1  类型系统及其重要性
  4.2 泛型
    4.2.1  创建泛型#
    4.2.2  泛型实现
    4.2.3  泛型应用
  4.3  用特征抽象行为
    4.3.1  特征
    4.3.2  特征的多种形式
  4.4  使用包含泛型的特征——特征区间
    4.4.1  类型上的特征区间
    4.4.2  泛型函数和impl 代码块上的特征区间
    4.4.3  使用“+”将特征组合为区间
    4.4.4  特征区间与impl 特征语法
  4.5  标准库特征简介
  4.6  使用特征对象实现真正的多态性
    4.6.1  分发
    4.6.2  特征对象
  4.7 小结
第5章   内存管理和安全性
  **5**.1  程序和内存**
  **5.2  程序如何使用内存**
  **5.3  内存管理及其分类**
  **5.4  内存分配简介**
    **5.4.1  堆栈**
    **5.4.2  堆**
  **5.5  内存管理的缺陷**
  **5.6 内存安全性**
  **5.7 内存安全三原则**
    **5.7.1 所有权**
      **作用域简介**
      **移动和复制语义**
    **5.7.2 通过特征复制类型**
      **所有权的应用**
      **闭包中的所有权**
    **5.7.3 借用**
      **借用规则**
      **借用实践**
        **函数中的借用**
        **匹配中的借用**
        **从函数返回引用**
    **5.7.4 基于借用规则的方法类型**
    5.7.5 生命周期
      生命周期参数
      生命周期省略规则
      自定义类型中的生命周期
      impl 代码块中的生命周期
      多个生命周期
      生命周期子类型
      在泛型上声明生命周期区间
  5.8 Rust 中的指针类型
    5.8.1 引用——安全的指针
    5.8.2 原始指针
    5.8.3 智能指针
    5.8.4 引用计数的智能指针
    5.8.5 内部可变性的应用
  5.9 小结
**第6章    异常处理**
  **6.1  异常处理简介**
  **6.2  可恢复的异常**
    **6.2.1  Option**
    **6.2.2  Result**
  **6.3  Option/Result的组合**
    **6.3.1  常见的组合器**
    **6.3.2  组合器应用**
    **6.3.3  Option和Result类型之间的转换**
  **6.4  及早返回和运算符“？”**
  **6.5  不可恢复的异常**
    **人机友好的灾难性故障**
  **6.6  自定义错误和 Error特征**
 **6.7 小结**
第7章   高级概念
  **7.1  类型系统简介**
    **7.1.1  代码块和表达式**
    **7.1.2  let语句**
    **7.1.3  循环作为表达式**
    **7.1.4  数字类型中的类型清晰度和符号区分**
    **7.1.5  类型推断**
    **7.1.6  类型别名**
  **7.2 字符串**
    **7.2.1 包含所有权的字符串——String**
    **7.2.2 借用字符串——&str**
    **7.2.3 字符串切片和分块**
    **7.2.4 在函数中使用字符串**
      **所以再强调一遍：如果你需要将一个字符串传递给你的函数，那么请使用字符串切片&str**
    **7.2.5 字符串拼接**
    **7.2.6 &str 和 String 的应用场景**
      **尽可能使用带有&str 类型的 API**
  **7.3 全局值**
    **7.3.1 常量**
    **7.3.2 静态值**
      **具有固定的内存位置**
    **7.3.3 编译期函数——const fn**
    **7.3.4 通过 lazy_static!宏将静态值动态化**
  7.4 迭代器
    实现自定义迭代器
  7.5 高级类型
    **7.**5.1 不定长类型**
    **7.5.2 函数类型**
    **7.5.3 never 类型“!”和函数分发**
    **7.5.4 联合**
    7.5.5 Cow
  7.6 高级特征
    **7.6.1 Sized 和?Sized**
    7.6.2 Borrow 和 AsRef
    7.6.3 ToOwned
    7.6.4 From 和 Into
    7.6.5 特征对象和对象安全性
    7.6.6 通用函数调用语法
    7.6.7 特征规则
  **7.**7 闭包进阶**
    **7.7.1 Fn 闭包**
    **7.7.2 FnMut 闭包**
    **7.7.3 FnOnce 闭包**
  **7.8 结构体、枚举和特征中的常量**
  **7.9  模块、路径和导入**
    **7.9.1  导入**
    **7.9.2  再次导出**
    **7.9.3  隐私性**
  **7.10  高级匹配模式和守护**
    **7.10.1  匹配守护**
    **7.10.2  高级let构造**
  7.11 强制类型转换
    可以将类型的引用类型转换为它的特征对象
    变形transmute
  **7.12 类型与内存**
    **7.12.1 内存对齐**
    **7.12.2 std::mem 模块**
  **7.13 使用 serde 进行序列化和反序列化**
  **7.14 小结**
第8章   并发
  8.1 程序执行模型
  8.2 并发
    8.2.1 并发方法
      以内核为基础
      用户级别
    8.2.2 缺陷
      条件竞争
      数据竞争
      内存不安全性和未定义的行为
      死锁
  8.3 Rust 中的并发
    8.3.1 线程基础
    8.3.2 自定义线程
    8.3.3 访问线程中的数据
  8.4 线程的并发模型
    8.4.1 状态共享模型
      修改线程中的共享数据
    8.4.2 互斥
    8.4.3 通过 Arc 和 Mutex 实现共享可变性
    8.4.4 通过消息传递进行通信
  8.5 Rust中的线程安全
    8.5.1  什么是线程安全
    8.5.2  线程安全的特征
    8.5.3  Send
    8.5.4  Sync
  8.6 使用actor模型实现并发
  8.7  其他程序库
  8.8 小结
第9章   宏与元编程
  9.1  什么是元编程？
  9.2 Rust宏的应用场景
  9.3 Rust中的宏及其类型
    宏的类型
  9.4 使用macro_rules!创建宏
  9.5  标准库中的内置宏
  9.6 macro_rules!宏的标记类型
  9.7  宏中的重复
  9.8  宏的高级应用——为 HashMap的初始化编写DSL
  9.9  宏用例——编写测试
  9.10 练习
  9.11  过程宏
  9.12  派生宏
  9.13  调试宏程序
  9.14  常用的过程宏软件包
  9.15 小结
第10章   不安全的Rust和外部函数接口
  10.1  安全与不安全
    10.1.1  不安全的函数和代码块
    10.1.2  不安全的特征和实现
  10.2 在Rust中调用C代码
  10.3 通过C语言调用Rust代码
  10.4 在Rust使用外部C/C++程序库
  10.5 使用PyO3构造原生Python扩展
  10.6 在Rust中为Node.js创建原生扩展
  10.7 小结