>   本系列文章使用的 Rust 的 Edition 为 `2021`。
>
>   主要参考：
>
>   -   [《Rust 程序设计语言》](https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html)
>   -   [《通过例子学 Rust》](https://rustwiki.org/zh-CN/rust-by-example/)
>   -   [《Rust 语言圣经》](https://course.rs/about-book.html)
>   -   [The Rust Standard Library](https://doc.rust-lang.org/std/index.html#the-rust-standard-library)
>

# 1 安装 Rust

## 在 Windows 上安装

前往 [下载页面]( https://www.rust-lang.org/tools/install) 按照提示安装。

## 在 Linux / macOS 上安装

```shell
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```

## 使用 rustup

`rustup` 是一个管理 Rust 版本和相关工具的命令行工具。

```shell
# 查看 rust 编译器版本
rustc -V

# 查看 rustup 版本
rustup -V

# 更新 rust
rustup update

# 更新 rustup
rustup self update

# 卸载 rust 和 rustup
rustup self uninstall

# 本地文档
rustup doc
```

>   关于 rustup 的更多信息，可参考 [The rustup book](https://rust-lang.github.io/rustup/)。

# 2 第一个程序

## 源程序

**文件：main.rs**

```rust
fn main() {
    println!("hello, world!");
}
```

### 使用 rustc 编译

```shell
rustc main.rs
```

>   关于 rustc 的更多信息，可参考 [The rustc book](https://doc.rust-lang.org/rustc/index.html)。

## 使用 Cargo 构建项目

Cargo 是 Rust 的构建系统和包管理器。

### 创建项目

```shell
# 查看版本
cargo -V

# 创建项目
cargo new hello --bin
```

此命令创建了一个名为 *hello* 的目录并将其初始化为 Git 仓库，同时在其中创建项目文件，`--bin` 表示该项目为可执行文件，可省略。

初次创建完毕后，此目录通常包含：

- 一个 *Cargo.toml* 文件；
- 一个 *src* 目录，以及位于其中的 *main.rs* 文件；
- 一个 *.gitignore* 文件。

若在一个已经存在的 Git 仓库中运行 `cargo new`，则这些 Git 文件不会生成，但可以使用 `cargo new --vcs=git` 来依然生成这些 Git 文件。还可以使用 `cargo init` 将一个目录初始化为 Rust 项目。

---

**文件：Cargo.toml**

```toml
[package]
name = "hello"
version = "0.1.0"
edition = "2021"

[dependencies]
```

-   `toml` 是 Cargo 配置文件的格式；
-   `[package]` 是一个标题片段，用来配置一个包。其中设置了 Cargo 编译程序所需的配置，如包名称、包版本和 Rust 版本；
-   `[dependencies]` 是项目依赖的片段，在 Rust 中，所依赖的代码包被称为 **crates**。Cargo 从 **registry** 上获取所有包的最新版本信息，这是一份来自 [Crates.io](https://crates.io/) 的数据拷贝。此外还可以运行 `cargo doc --open` 命令来构建所有本地依赖提供的文档；
-   *main.rs* 为 Cargo 自动生成的程序。

Cargo 期望源文件存放在 *src* 目录中，根目录只存放 README、LICENSE、配置文件和其它与代码无关的文件。

### 构建和运行

```shell
# 构建 debug 版本
cargo build

# 构建 release 版本
cargo build --release

# 构建并运行
cargo run

# 检查
cargo check

# 显式更新依赖
cargo update
```

在项目的目录下，`build` 命令会在 *target/debug* 目录下生成可执行文件。

首次运行此命令时，也会在项目的根目录创建一个新文件：*Cargo.lock*。这个文件记录项目依赖的实际版本，即使用指定的依赖版本，除非手动指定了新的依赖版本。

`update` 命令会忽略 Cargo.lock 文件，并计算出所有符合 Cargo.toml 声明的最新版本，若成功了，则会把新版本写入 Cargo.lock 文件中。

Cargo 默认只会寻找最大的**语义化版本**，若原指定版本为 `0.8.5`，实际上这是 `^0.8.5` 的缩写，表示至少为 `0.8.5` 但小于 `0.9.0` 的版本，以确保 API 兼容。若想要使用这之外的版本，则必须手动在 Cargo.toml 文件中指定新版本。

```toml
[dependencies]
xxx = "0.9.0"
```

下一次构建时，Cargo 会从 registry 更新可用的 crates，并根据指定的版本重新计算。

`run` 命令会检查源文件，若没有被修改，则直接运行可执行文件，否则重新构建并运行项目。

`check` 命令来快速检查代码确保其可以通过编译，但并不产生可执行文件。

构建时使用 `--release` 选项来优化编译项目，此命令会在 *target/release* 目录下生成可执行文件。

>   关于 Cargo 的更多信息，可参考 [The Cargo Book](https://doc.rust-lang.org/cargo/)。

# 3 通用编程概念

## 标识符

-   可以是任意非空的，且非 emoji 的 Unicode 字符；
-   不能以数字开头，且不能为关键字；

-   当以下划线开头时，长度至少为 **2**；

-   单个 `_` 标识符表示**忽略**。

### 原始标识符

有时需将关键字作为标识符使用，如调用 C 语言库中名为 `match` 的函数，在 C 语言中 match 不是关键字，但是在 Rust 中是关键字，因此需使用原始标识符，以 `r#` 开头。

```rust
let r#fn = "value";
r#match();
```

## 原始字符串

在字符串前加 `r` 表示原始字符串，不会对字符进行转义。

```rust
let s = r"hello\t\nhello";
```

## 注释

使用 `//` 表示行注释，使用 `/* */` 表示块注释。

```rust
// 行注释

/*
块注释
*/
```

## 变量与可变性

在 Rust 中，变量**默认是不可改变的**，但可以在变量名前加 `mut` 关键字来使其可变。当变量不可变时，一旦值被绑定一个标识符上，就不能改变这个值。

```rust
let x = 1;      // 不可变
let mut y = 3;  // 可变
```

`mut x` 是一个**模式**，可以用这种方式同时声明多个变量：

```rust
let (mut a, mut b) = (1, 2);
```

变量必须被初始化后才能使用：

```rust
let x: i32;       // 错误
println!("{x}");
```

不可变变量和常量是有区别的：

-   常量使用 `const` 关键字，且**必须注明值的类型**；
-   变量使用 `let` 关键字，可以在其前加上 `mut` 来使其可变，不能在 `const` 前加上 `mut` 来使其可变；
-   常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其它只能在运行时计算出的值；
-   常量可以在任何作用域中声明，包括全局作用域，而变量只能在函数作用域生效。

```rust
const MAX_POINTS: u32 = 10_000;
```

## 隐藏

可以定义一个与之前变量同名的新变量，而新变量会隐藏之前的变量。可以使用相同变量名称来隐藏一个变量，以及重复使用 `let` 关键字来多次隐藏。

```rust
let x = 1;
let x = x + 1;
let x = x * 2;
```

隐藏与将变量标记为 `mut` 是有区别的：当对变量重新赋值时，若没有使用 `let` 关键字，就会导致编译错误，通过使用 `let`，可以对这个值重新赋值，不过赋值后变量仍是不变的；当再次使用 `let` 时，实际上创建了一个新变量，可以改变值的类型，但复用这个名字。

函数也能够被隐藏：

```rust
fn main() {
    let sum = sum(1, 2);
    sum(3, 4);   // 错误，sum 函数在此刻不可用
}

fn sum(x: i32, y: i32) -> i32 {
    x * y
}
```

隐藏的对象只会在其作用域内起作用，当离开作用域时，外部被隐藏的项会恢复：

```rust
let v = 2;
{
    let v = 4;
    println!("{v}");   // 输出 4
}
println!("{v}");       // 输出 2
```

## 数据类型

Rust 是**静态类型**语言，编译器通常可以推断出类型。当多种类型均有可能时，必须增加**类型注解**。

```rust
let x: u32 = 10;
let y: f64 = 3.14;
```

每一个值都属于某种数据类型，Rust 有两类数据类型子集：**标量**和**复合**。

### 标量类型

标量类型代表一个单独的值。Rust 有四种基本的标量类型：**整型**、**浮点型**、**布尔类型**和**字符类型**。

#### 整型

| 长度    | 有符号 | 无符号 |
| ------- | ------ | ------ |
| 8 bit   | i8     | u8     |
| 16 bit  | i16    | u16    |
| 32 bit  | i32    | u32    |
| 64 bit  | i64    | u64    |
| 128 bit | i128   | u128   |
| arch    | isize  | usize  |

有符号数以**补码**形式存储。

`isize` 和 `usize` 类型依赖于运行程序的计算机架构。

| 数字字面值       | 例            |
| ---------------- | ------------- |
| Decimal          | `10_000`      |
| Hex              | `0xfe`        |
| Octal            | `0o77`        |
| Binary           | `0b1010_1000` |
| Byte (`u8` only) | `b'A'`        |

除 Byte 以外的所有数字字面值允许使用类型后缀，例如 `12_u8`，也允许使用 `_` 做为分隔符。

Rust 的默认数字类型默认是 `i32`。

---

对于整数溢出，当在 debug 模式编译时，Rust 检查这类问题并使程序 **panic**，即**程序因错误而退出**。

在 release 构建中，Rust 不检查溢出，而是会按照补码规则计算实际的值。

#### 浮点型

Rust 有两种原生的浮点类型，`f32` 单精度浮点数和 `f64` 双精度浮点数，采用 IEEE 754 标准表示，默认类型是 `f64`。

#### 算术运算

Rust 中的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取余。

```rust
let a = 1 + 11;
let b = 3 - 5.1;
let c = 3.14 * 2;
let d = 5 / 3;
let e = 10.8 / 4.4;
let f = 10 % 6;
let g = 6.6 % 2.4;
```

这些语句中的每个表达式都使用了数学运算符并计算出值，然后将值绑定到变量上。整数除法会直接**去掉小数部分**而不进行舍入。进行取余运算时，结果的**正负性只与被取余数的正负性有关**，此外还可以对浮点数进行取余运算，但是结果不一定精确。

#### 关系、逻辑和位运算

关系、逻辑和位运算的符号和方式和 C 基本相同。

#### 布尔型

布尔类型有两个可能的值：`true` 和 `false`，使用 `bool` 表示。

```rust
let x = true;
let y: bool = false;
if x == true {}
```

#### 字符类型

Rust 的 `char` 类型是语言中最原生的字符类型。

```rust
let a: char = 'a';
let b = '你';
let c = 'あ';
let d = 'Ω';
let e = '😅';
let f = '\u{102c0}';
```

`char` 由单引号指定，不同于字符串使用双引号。Rust 的 `char` 类型代表了一个 Unicode 标量值，拼音字母、中文、日文、韩文等字符，emoji 以及空白字符都是有效的 `char` 值。Unicode 标量值包含从 `U+0000` 到 `U+D7FF` 和 `U+E000`到 `U+10FFFF` 在内的值，一个 `char` 类型占据 **4** 个字节。

Unicode 中有一些字符是**零宽度字符**：它是一个字符，有 Unicode 编码，但是没有宽度。零宽度字符并不是 `''`，如 `let c = ''` 是不被允许的，因为 rust **没有空值**。

可以将字符值赋值给整型，但限制如下：

-   必须增加类型前缀 `b`；

-   只支持 `u8` 类型，即 Byte。

```rust
let n: u8 = b'A';   // 值为 65
```

### 复合类型

复合类型可以将多个值组合成一个类型。Rust 有两种原生的复合类型：**元组**和**数组**。

#### 元组类型

元组是将多个其它类型的值组合进一个复合类型的方式。列表中值的类型不一定相同，且长度固定。

```rust
let tup: (i32, f64, u8) = (100, 2.1, 20);
```

`tup` 变量绑定到整个元组上，因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用**模式匹配**来解构元组值。

```rust
let tup = (100, 2.1, 20);
let (x, y, z) = tup;
println!("y = {y}");
```

首先创建了一个元组并绑定到 `tup` 变量上。接着使用了 `let` 和一个模式将 `tup` 分成了三个不同的变量：`x`、`y` 和 `z`，这叫做**解构**。

除了使用模式匹配解构外，还可以使用点号 `.` 后跟值的索引来直接访问。

```rust
let tup = (100, 2.1, 20);
let x = tup.0;
let y = tup.1;
let z = tup.2;
```

创建了一个元组并绑定到变量 `tup` 上，并使用索引为每个元素创建新变量，元组的第一个索引值是 0。

---

为了避免混淆，单个元素的元组需要在元素后面加一个逗号：

```rust
let t: (i32,) = (1,);
```

没有任何值的元组为 `()`，即**单元类型**类型，只有一个**单元值** 。如果表达式不返回任何其他值，则会隐式返回单元值。

```rust
let empty: () = ();
```

没有返回值的语句块，如没有定义返回值的函数，默认都会返回单元值。

```rust
fn foo() {}
let x = {};     // x = ()
let y = foo();  // y = ()
```

#### 数组类型

数组是将多个其它相同类型的值组合进一个复合类型的方式。列表中值的类型必须相同，且长度固定。

```rust
let arr: [i32; 5] = [1, 2, 3, 4, 5];
```

第一个中括号中有两部分由分号分隔的信息：第一部分是数组中每个元素的类型，第二部分表示数组长度。

若想创建一个每个元素都相同的数组，可以这样初始化：中括号内指定其初始值，后跟分号，再后跟数组的长度。

```rust
let arr = [0; 5];
```

数组是一整块分配在栈上的内存，可以使用索引来访问数组的元素。

```rust
let arr = [1, 2, 3, 4, 5];
let x = arr[0];
let y = arr[1];
```

当想要在栈而不是在堆上为数据分配空间时，或要确保总是有固定数量的元素时，可以使用数组。当使用索引对无效的数组元素进行访问时，Rust 会 panic。

## 函数

Rust 中的函数定义以 `fn` 关键字开始并在函数名后跟一对圆括号，大括号表示函数体的开始和结尾。

使用函数名后跟圆括号来调用定义过的任意函数，定义的位置可以放在**调用之前或之后**。

```rust
fn main() {
    hello();
}

fn hello() {
    println!("hello, world!");
}
```

`main` 函数是程序的入口点，其中的代码会按顺序执行。

### 函数参数

函数也可以被定义为拥有参数，参数是**函数签名**的一部分。当函数拥有参数（形参）时，可以为函数提供实际的值（实参）。

```rust
fn main() {
    sum(1, 2);
}

fn sum(x: i32, y: i32) {
    println!("{}", x + y);
}
```

在函数签名中，必须声明每个参数的类型。当有多个参数时，用逗号分隔，参数的类型不一定相同。

### 函数体、语句和表达式

函数体由**一系列的语句和一个可选的结尾表达式构成**。Rust 区分语句和表达式：语句是执行一些操作但**不返回值的指令**，表达式**计算并产生一个值**。

```rust
fn main() {
    let x = 2;
}
```

使用 `let` 创建变量并绑定值是语句，函数定义是语句，整个 `main` 函数也是一个语句。语句不返回值，因此不能把 `let` 语句赋值给另一个变量。

```rust
let x = (let y = 3);    // 错误
```

语句 `let y = 3` 不返回值，所以没有可以绑定到 x 上的值。表达式会返回值，语句 `let y = 3` 中的 `3` 是一个表达式。函数调用是一个表达式，宏调用是一个表达式，创建新作用域的大括号 `{}`，也是一个表达式。

```rust
let y = {
    let x = 2;
    x + 1
};
```

大括号的内容是一个代码块，其值为整个代码块中最后一个表达式的值，它的值是 `3`，这个值作为 `let` 语句的一部分被绑定到 `y` 上。`x + 1` 表达式的结尾没有分号 `;`，若在表达式的结尾加上分号，则变成了语句。

### 函数的返回值

函数可以向调用它的代码返回值，需在箭头 `->` 后声明返回值的类型。在 Rust 中，函数的返回值等同于**函数体最后一个表达式的值**。使用 `return` 关键字和指定值，可以从函数中提前返回，但函数通常隐式的返回最后的表达式的值。

```rust
fn main() {
    println!("{}", sum(1, 2));
}

fn sum(x: i32, y: i32) -> i32 {
    // 等同于return x + y;
    x + y
}
```

## 控制流

### if 表达式

`if` 表达式允许根据条件执行不同的代码分支。不同于其它语言，在 Rust 中，`if` 是表达式，它会返回一个值。所有 `if` 表达式的条件**必须是 `bool` 值**，以及包含一个可选的 `else` 表达式来提供一个在条件为假时应当执行的代码块，还可以将 `else if` 表达式与 `if` 和 `else` 组合来实现多重条件。

```rust
let mut x = 10;
x = if x < 3 {
    x + 1
} else if x < 6 {
    x + 2
} else {
    x + 3
};
```

由于 `if` 是一个表达式，可以把返回值绑定到一个变量上，且值的类型需要与绑定的变量类型相同。由于这是一个语句，需在最后加上一个分号。

### 循环

为了多次执行同一段代码，Rust 提供了三种循环：`loop`、`while` 和 `for`。

#### loop 循环

`loop` 关键字会重复的执行其代码块中的代码，直到遇到明确的停止循环指令，如可以在程序执行期间按 `Ctrl + C` 来终止程序，或在循环中使用 `break` 来提前跳出循环，使用 `continue` 来提前结束本次循环。

```rust
let mut x = 0;
let y = loop {
    x = x + 1;
    if x > 10 {
        break x;
    }
};
```

若在跳出循环后需要某个值可以在 `break` 后加上该值来从循环中返回值，并把值绑定到变量上，且在最后加上分号来使其成为一个语句。**只有 `loop` 能够使用 `break + 值` 的形式**。

---

若存在嵌套循环，则 `break` 和 `continue` 只能作用于最内层的循环。

可以在循环上指定一个**循环标签**，循环标签使用 `'` + `标识符` 的形式，然后配合 `break` 或 `continue` 使用，此时可以作用于外层循环。

```rust
'out: loop {
    loop {
        println!("do this");
        break 'out;
    }
    println!("Never do");    // 此行不会被执行
}
println!("do this after loop");
```

#### while 循环

`while` 关键字会根据是否满足条件来重复的执行其代码块中的代码，直到不满足条件为止或遇到明确的停止循环指令。

```rust
while x < 10 {
    x = x + 1;
    if x % 8 == 0 {
        break;
    }
}
```

`while` 也可以使用循环标签。

#### for 循环

可以使用 `while` 循环来遍历集合中的元素。

```rust
let arr: [i32; 3] = [1, 2, 3];
let mut i = 0;
while i < 3 {
    println!("{}", arr[i]);
    i = i + 1;
}
```

采用这种方式遍历集合中的元素很容易出错，若索引不正确会导致程序 panic。这也使程序更慢，因为编译器增加了运行时代码来对每次循环的每个元素进行条件检查。

---

使用 `for` 循环来遍历集合中的元素并执行相应的代码。

```rust
let arr = [1, 2, 3];
for e in arr {
    println!("{e}");
}
```

使用 `for` 循环增强了安全性，并消除了错误的索引所产生的 Bug，由于不再需要对每次循环时的每个元素进行条件检查，效率也提高了。

要循环特定次数时，可以使用 `Range`，它是标准库提供的类型，用来生成从一个范围内的所有数字的序列。通过 `start..end` 来语法来创建序列，但不包含 `end`，若要包含 `end`，可以使用 `start..=end` 语法。

`Range` 也能使用 `rev` 方法来反转。

```rust
for e in (1..4).rev() {
    println!("{e}");
}
```

通过 `rev` 来反转 `Range` 实现了倒计时的功能。

# 4 所有权

所有权是 Rust 最独特的功能，也是其核心功能之一，其令 Rust 无需垃圾回收即可保证内存安全。

## 什么是所有权

所有运行的程序都必须管理其使用内存的方式。一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；在另一些语言中，必须手动分配和释放内存。Rust 则通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会降低程序效率。

### 堆与栈

栈与堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以**后进先出**的方式操作数据，把数据放入栈中叫**进栈**，从栈中取出数据叫做**出栈**。当调用一个函数时，传递给函数的参数被入栈，当函数结束时，这些参数被出栈。

由于数据存取的位置总是在栈顶而不需要寻找位置，且栈中的所有数据都占用已知且固定的大小，因此对栈的操作十分高效。

在编译时大小未知或大小可能变化的数据，要改为存储在堆上。堆是缺乏组织的：当向堆放入数据时，需要请求一定大小的空间。操作系统在堆的某处找到一块足够大的空间，把它标记为已使用，并返回一个指向该地址的指针，这个过程称作**在堆上分配内存**。由于指针的大小是已知且固定的，可以将指针存储在栈上，不过当需要实际操作数据时，必须通过指针访问其指向的数据。

由于必须通过指针来访问，因此访问堆上的数据比访问栈上的数据慢。现代处理器在内存中跳转越少就越快，处理器处理的数据在彼此较近的时候效率更高，且在堆上分配空间也会消耗时间。

所有权系统正是处理并跟踪哪部分代码正在使用堆上的数据，最大程度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据以确保不会耗尽空间。

### 所有权规则

- Rust 中的每一个值都有一个**所有者**；
- 值**有且仅有一个**所有者；
- 当所有者离开作用域，这个值将被丢弃。

### 作用域

作用域是一个项在程序中有效的范围。

```rust
let s = "hello";        // s 从此处开始生效
{                       // 作用域开始
    let s2 = "World";   // s2 从此处开始生效
}                       // 作用域结束，s2 无效，但 s 依旧有效
```

当变量进入作用域时，就是有效的，并一直持续到离开作用域为止。

### String 类型

前面的数据类型都是存储在栈上的，在进入作用域时入栈，离开作用域时出栈。通常的字符串字面值是不可变的，且并不是所有字符串的值都能在编写代码时知道，因此变化的字符串不能简单的保存在栈上。

Rust 有第二种字符串类型：`String`。这个类型被分配到堆上，所以能够存储在编译时未知大小的文本。可以使用 `from` 函数基于字符串字面值来创建 `String`。

```rust
let s = String::from("hello");
```

两个冒号 `::` 是运算符，允许将特定的 `from` 函数置于 `String` 类型的命名空间下。

可以修改此类字符串：

```rust
let mut s = String::from("hello");
s.push_str(", world!");     // 在后面追加字符串
```

### 内存与分配

字符串字面值不可变而 String 类型可变的原因在于这两个类型对内存的处理方式上。

字符串字面值在编译时就知道其内容，所以文本被直接硬编码进可执行文件的 `.rodata` 区块中，因此其效率高，但也具有不可变性。

对于 `String` 类型，为了支持一个可变的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容，这意味着：

- 必须在运行时向操作系统请求内存；
- 需要一个当处理完 `String` 时将内存返回给操作系统的方法。

第一部分由 `String::from` 完成。

对于第二部分，在有垃圾回收的语言中， GC 记录并清除不再使用的内存。在没有 GC 的语言中，需要手动管理内存。若提前回收，会出现无效变量；若重复回收，会导致 Bug。这需要精确的配对每一个 `allocate` 和 `free`。

Rust 的策略是：内存在拥有它的变量离开作用域后就被自动释放。

```rust
{
    let s = String::from("hello");  // s 从此处开始生效
}                                   // s 无效
```

当变量离开作用域，Rust 将在结尾的 `}` 处自动调用一个特殊的函数 `drop` 以将内存返还给操作系统。

>   在 C++ 中，这种在生命周期结束时释放资源的模式被称作 RAII（Resource Acquisition Is Initialization，资源获取即初始化）。

### 数据交互：移动

Rust 中的多个变量可以采用一种独特的方式与同一数据交互。

```rust
let x = 5;
let y = x;
```

将 `5` 绑定到 `x`，接着生成一个值 `x` 的拷贝并绑定到 `y`。现在有了两个变量，`x` 和 `y`，都等于 `5`。因为整型的大小已知且固定，所以这两个 `5` 都被放入了栈中。

```rust
let s1 = String::from("hello");
let s2 = s1;
```

对于 String 类型，并不会完全生成一个 `s1` 的拷贝。String 类型由三部分组成：**指向字符串的指针、长度和容量**。这一组数据存储在栈上，堆上则存放字符串的内容。

![String 在内存中的表示](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202203232352837.png)

长度表示 `String` 的内容当前使用了多少字节的内存，容量是 `String` 从操作系统总共获取了多少字节的内存。

当把 `s1` 赋值给 `s2` 时，`String` 的数据被复制了，即从栈上拷贝了它的指针、长度和容量，而没有复制指针指向的堆上的数据。若 Rust 也拷贝了堆上的数据，那么在执行 `s2 = s1` 时，在堆上数据较大时会对运行时性能造成较大的影响。

![s1 和 s2 指向同一块堆内存](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202203240158188.png)

原本当变量离开作用域后，Rust 会自动调用 `drop` 函数清理内存，但两个数据指针都指向了同一位置，这就有了一个问题：当 `s1` 和 `s2` 离开作用域时，都会尝试释放相同的内存。这会产生一种叫做**二次释放**的错误，两次释放相同的内存会导致内存污染，还可能会引发潜在的安全漏洞。

为了确保内存安全，与其尝试拷贝被分配的内存，Rust 则认为 `s1` 不再有效，因此 Rust 不需要在 `s1` 离开作用域后清理任何东西。

```rust
let s1 = String::from("hello");
let s2 = s1;        // s1 失效
println!("{s1}");   // 错误
```

在把 `s1` 赋值给 `s2` 后，Rust 认为 `s1` 不再有效，所以会产生错误，因为 Rust 禁止使用无效的引用。

拷贝有两种：**浅拷贝**和**深拷贝**。只复制指针、长度和容量这些栈上的数据可以看做浅拷贝，而把栈上和堆上的数据都进行复制可以看做深拷贝。Rust 不会自动创建数据的深拷贝，因此任何**自动**的复制可以被认为对运行时性能影响较小。

上面的例子可以看作 `s1` 被移动到了 `s2` 中，这个操作被称为**移动**。

### 数据交互：克隆

若确实需要复制 `String` 中堆上的数据，而不仅仅是栈上的数据，可以调用通用函数 `clone`。

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
println!("{s1}, {s2}");
```

当调用 `clone` 时，一些特定的代码被执行因此效率会降低。

#### 只在栈上的数据：拷贝

```rust
let x = 5;
let y = x;
```

这段代码没有调用 `clone`，不过 `x` 依然有效且没有被移动到 `y` 中。

原因是像整型这样的在编译时已知大小且固定的类型被整个存储在栈上，所以拷贝值是快速的。这里没有深浅拷贝的区别，所以调用 `clone` 并不会与通常的浅拷贝有什么不同。

---

Rust 有一个叫做 `Copy` trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。若一个类型拥有 `Copy` trait，一个旧的变量在将其赋值给其它变量后仍然可用。Rust 不允许自身或其任何部分实现了 `Drop` trait 的类型使用 `Copy` trait。若对其值离开作用域时需要特殊处理的类型使用 `Copy` 注解，将会出现一个编译时错误。

通用的规则：任何简单标量值的组合是 `Copy` 的，不需要分配内存或某种形式资源的类型是 `Copy` 的。

`Copy` 类型：

- 标量类型；
- 复合类型，当且仅当其包含的类型也都是 `Copy` 的时候。如元组 `(i32, i32)` 是 `Copy` 的，但 `(i32, String)` 则不是。

>   所有的引用类型也都是 `Copy` 的，因为引用只是一个保存在栈上的指针。

### 所有权与函数

将值传递给函数在语义上与给变量赋值相似，向函数传递值可能会移动或复制。

```rust
fn main() {
    let n = 3;
    let s = String::from("hello");
    print_number(n);      // n 的值移动到函数中，但 i32 是 Copy 的，可在之后继续使用
    print_string(s);      // s 的值移动到函数中，之后不能继续使用
    println!("{n}");      // n 依旧有效
    println!("{s}");      // s 已经无效，此行代码错误
}   // n 被移出作用域，s 的值已被移走，不会有特殊操作

fn print_number(pn: i32) {
    println!("{pn}");
}   // pn 被移出作用域，不会有特殊操作

fn print_string(ps: String) {
    println!("{ps}");
}   // ps 被移出作用域并调用 drop 函数，占用的内存被释放
```

### 返回值与作用域

返回值也可以转移所有权。

```rust
fn main() {
    let s1 = ret();         // 函数将返回值移动到 s1
    let s2 = String::from("hello");
    let s3 = take_ret(s2);  // s2 的值被移动到函数中，之后不能继续使用，函数将返回值移动到 s3
}   // s1 被移出作用域，s2 的值已被移走，不会有特殊操作，s3 被移出作用域

fn ret() -> String {
    let s = String::from("hello");
    s   // 将s的值移出，返回给调用它的函数
}

fn take_ret(ts: String) -> String { // 调用它的函数的参数的值移动到 ts，ts 的作用域开始
    ts  // 将 ts 的值移出，返回给调用它的函数
}
```

变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 `drop` 函数被清理掉，**除非数据被移动为另一个变量所有**。

函数获取一个值后也会获取其所有权，若在传递给函数后还要继续使用这个值，使用函数返回值就比较麻烦，且函数处理过后的数据也同样需要时，可以通过元组来返回多个值。

```rust
fn main() {
    let s1 = String::from("hello");
    let (s1, l) = str_len(s1);   // s1 的值被移动到函数中，又通过函数返回移动到 s1 中
    println!("s1: {s1}, l: {l}");
}

fn str_len(s: String) -> (String, usize) {
    let len = s.len();
    (s, len)
}
```

## 引用和借用

### 什么是引用

以一个对象的**引用**作为参数而不是获取值的所有权，创建一个引用的行为称为**借用**。

```rust
fn main() {
    let s1 = String::from("hello");
    let len = str_len(&s1);
    println!("s1: {s1}, len: {len}");
}

fn str_len(s: &String) -> usize {   // s 是对 String 的引用
    s.len()
}   // s 离开作用域，但它并不拥有引用值的所有权，所以不会有特殊操作
```

传递 `&s1` 给函数，同时在函数定义中，获取 `&String` 而不是 `String`。`&` 符号表示引用，允许使用值但不获取其所有权。因为并不拥有这个值，当引用离开作用域时其指向的值也不会被丢弃。同理，函数签名使用 `&` 来表明参数 `s` 的类型是一个引用。

![对象的引用](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202203240005250.png)

引用和指针类似，其保存了一个地址，可以由此访问储存于该地址的数据，并且确保指向的值是有效的。

>   与 `&` 相反的操作是**解引用**，使用解引用运算符 `*`。

### 区分引用和借用

```rust
let s = String::new();
let s1 = &s;
```

这里变量 `s1` 是一个引用，它借用了来自 `s` 的值，即来自 String 类型的借用，因此 `s1` 的类型为 `&String`，不过一般情况下可以不用严格区分这两者。

### 可变引用

变量默认是不可变的，引用也一样，**默认不允许修改引用的值**。

```rust
fn main() {
    let s1 = String::from("hello");
    add_str(&s1);
}

fn add_str(s: &String) {
    s.push_str(", world!");     // 错误，引用默认不可变
}
```

将 `s1` 改为 `mut s1`，传给函数一个可变引用 `&mut s1` ，函数接受一个可变引用 `s: &mut String`。

```rust
fn main() {
    let mut s1 = String::from("hello");
    add_str(&mut s1);
}

fn add_str(s: &mut String) {
    s.push_str(", world!");
}
```

`mut` 变量可以被引用为 `&` 或 `&mut`，非 `mut` 变量只可以被引用为 `&`。

```rust
let x = 1;
let mut y = 2;
let rx = &mut x;    // 错误，非 mut 变量只能被引用为 &
let ry = &y;        // 正确，可以对 mut 变量引用为 &
```

`mut` 变量指的是该变量本身是否可变，`mut` 引用指的是所引用的值是否可变。

```rust
let x = 1;
let y = 2;
let mut rx = &x;
rx = &y;    // 改变的是变量自身
let mut z = 3;
let rz = &mut z;
*rz = 6;    // 改变的是所引用的值
```

若变量本身的类型是引用，则 `&` 和 `&mut` 是两种数据类型，因此一个 `mut` 变量的类型不能在 `&` 和 `&mut` 之间切换。

```rust
let mut x = 1;
let mut y = 2;
let mut rx = &mut x;    // rx 的类型被确定为 &mut
rx = &y;                // 错误，不能将一个 & 类型赋值给 rx
let rx = &y;            // 正确，可以通过隐藏来改变 rx 的类型
```

---

可变引用有一个很大的限制：**值在同一作用域内有且只有一个可变引用**。

```rust
let mut s = String::from("hello");
let r1 = &mut s;
let r2 = &mut s;    // 错误
```

这个限制允许可变性，不过是以一种受限制的方式允许，这个限制可以使 Rust 在编译时就避免数据竞争。

数据竞争由三个行为造成：

- 多个指针同时访问同一数据；
- 至少有一个指针被用来写入数据；
- 没有同步数据访问的机制。

---

使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能同时拥有。

```rust
let mut s = String::from("hello");
{
    let r1 = &mut s;
}   // r1 离开作用域，r2 可以拥有 s 的可变引用
let r2 = &mut s;
```

类似的规则也存在于同时使用可变与不可变引用中。**不能在拥有不可变引用的同时拥有可变引用**，**但可以拥有多个不可变引用**。

```rust
let mut s = String::from("hello");
let r1 = &s;
let r2 = &s;
let r3 = &mut s;    // 错误
```

一个引用的作用域从声明的地方开始一直持续到**最后一次使用为止**。如最后一次使用不可变引用在声明可变引用之前，或仅在最后一次使用可变引用**之后**，原始数据才可以再次可变或不可变的借用。编译器在作用域结束之前判断不再使用的引用的能力称为**非词法作用域生命周期**。

```rust
let mut s = String::from("hello");
let r1 = &s;
let r2 = &s;
println!("{r1}, {r2}");   // 最后一次使用引用，r1、r2 作用域结束
let r3 = &mut s;          // 可以使用
println!("{r3}");
```

在引用的生命周期内，被引用的变量本身不允许改变，不管是 `&` 还是 `&mut`。

```rust
let mut x = 1;
let rx = &mut x;              // 亦或是 &x
x = 2;                        // 错误，不允许 x 自身内容变化
println!("{rx}");
```

对于可变引用，总是遵循以下规则：

-   值在同一作用域内只能拥有一个可变引用；
-   不能同时拥有可变和不可变引用，但可以同时拥有多个不可变引用。



### 悬垂引用

在具有指针的语言中，通过释放内存时保留指向它的指针从而错误地生成一个悬垂指针。**悬垂指针**是其指向的内存可能已经被分配给其它所有者。Rust 确保引用永远也不会变成悬垂状态：**编译器确保数据不会在其引用之前离开作用域**。

```rust
fn main() {
    let r = dr();            // 引用指向无效的String
}

fn dr() -> &String {        // 返回一个字符串引用
    let s = String::from("hello");
    &s                      // 返回s的引用，错误
}   // s离开作用域，其内存将被释放
```

### 引用规则

- 在任意时刻，要么只能有一个可变引用，要么只能有一个或多个不可变引用；
- 引用的作用域持续到最后一次**使用**为止；
- 引用必须总是有效。

## slice 类型

**slice** 是没有所有权的数据类型，它允许引用集合中一段连续的元素序列，而不是引用整个集合。

```rust
fn find_word(s: &String) -> usize {
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }
    s.len()
}
```

该函数接收一个字符串引用，返回第一个单词的结尾字符的索引值。

第 2 行，因为需要逐个元素的检查 `String` 中的值是否为空格，需使用 `as_bytes` 方法将 `String` 转化为字节数组。

第 3 行，使用 `iter` 方法在字节数组上创建一个迭代器。`iter` 方法返回集合中的每一个元素，而 `enumerate` 包装 `iter` 的结果并返回一个元组，其中每一个元素是元组的一部分。`enumerate` 返回元组的第一个元素是索引，第二个元素是集合中元素的引用。因为 `enumerate` 方法返回一个元组，所以使用模式来解构，在 `for` 循环中，指定了一个模式，其中元组中的 `i` 是索引，而元组中的 `&item` 是单个字节。由于从 `.iter().enumerate()` 中获取了集合元素的引用，所以模式中需使用 `&`。

第 4 行，在 `for` 循环中，通过字节字面值来代表空格的字节。若找到了一个空格，则返回它的位置；否则，使用 `s.len()` 返回字符串的长度。

在 `main` 函数中调用 `find_word` 函数。

```rust
fn main() {
    let mut s = String::from("hello world");
    let n = find_str(&s);   // n 的值为 5
    s.clear();              // 清空字符串，s 的值无效，n 的值仍有效
    println!("{n}");
}
```

该程序编译时没有错误，且在调用 `s.clear()` 之后使用 `n` 也不会出错。因为 `n` 与 `s` 状态完全没有关联，所以 `n` 仍然包含值 `5`。可以尝试用值 `5` 来提取变量 `s` 的第一个单词，不过这是有 Bug 的，因为在将 `5` 保存到 `n` 后 `s` 的内容已被改变， `n` 的索引与 `s` 中的数据不再同步。若有更多从数据的某个特定状态计算而来的值，但都完全没有与这个状态相关联，索引管理将更加容易出问题。

### 字符串 slice

字符串 slice 是对 `String` 中一部分值的引用。

```rust
let s = String::from("hello world");
let s1 = &s[0..5];
let s2 = &s[6..=10];
```

使用 `start..end` 语法，`s1` 将引用整个 `String` 中索引值为 `[0..5]` 部分。它不是对整个 `String` 的引用，而是对部分 `String` 的引用。

在其内部，slice 的数据结构存储了 slice 的开始位置和长度，长度等于 `end` 减去 `start` 的值，所以 `s1` 是一个包含指向 s 第 1 个字节的指针和长度为 5 的 slice，`s2` 是一个包含指向 s 第 7 个字节的指针和长度为 5 的 slice。

![字符串 slice](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202203240457604.png)

字符串 slice 的索引必须位于有效的 UTF-8 字符边界内，若尝试从一个多字节字符的中间位置创建字符串 slice，Rust 将会 panic。

```rust
let s = String::from("你好");
let s1 = &s[0..2];   // 错误，UTF-8 中汉字占 3 个字节
let s1 = &s[0..3];   // 正确
```

对于 `..` 语法，若从索引 0 开始或到尾部结束，可以不写两个点号之前或之后的值。

```rust
let s1 = &s[..5];
let s2 = &s[6..];
let s3 = &s[..];    // 获取整个字符串 slice
```

于是可以重写 `find_word` 函数，字符串 slice 类型声明写作 `&str`：

```rust
fn find_word(s: &String) -> &str {
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    &s[..]
}
```

当调用 `first_word` 时，会返回与底层数据关联的单个值。这个值由一个 slice 开始位置的引用和 slice 中元素的数量组成。

于是在 `main` 函数中调用 `find_word` 函数：

```rust
fn main() {
    let mut s = String::from("hello world");
    let s1 = find_word(&s);
    s.clear();      // 错误
    println!("{}", s1);
}
```

根据借用规则，Rust 确保引用总是有效，且当拥有某值的不可变引用时，就不能再获取一个可变引用。因为 `clear` 需要清空 `String`，它尝试获取一个可变引用，于是会发生错误。

#### 字符串字面值就是 slice

字符串字面值被储存在二进制文件中，因此它就是一个 slice。

```rust
let s = "hello world";
```

这里 `s` 的类型是 `&str`：它是一个指向二进制文件特定位置的 slice。这也就是为什么字符串字面值是不可变的，因为 `&str` 是一个不可变引用。

#### 字符串 slice 作为参数

改进后的 `first_word` 函数签名：

```rust
fn find_word(s: &String) -> &str {
```

函数接受一个 `String` 类型的引用，但还可以把参数也改进为 `&str`：

```rust
fn find_word(s: &str) -> &str {
```

这样可以对 `String` 值和 `&str` 值使用相同的函数。若有一个字符串 slice，可以直接传递它；若有一个 `String`，则可以传递整个 `String` 的 slice。定义一个获取字符串 slice 而不是 `String` 引用的函数可使 API 更加通用且不会损失任何功能。

因此以下都是合法的：

```rust
let s = String::from("hello world");
let a_s = "second string";
let s1 = find_word(&s);
let s2 = find_word(&s[..]);
let s3 = find_word(a_s);
let s4 = find_word(&a_s[..]);
```

###  其它类型的 slice

字符串 slice 是针对字符串的，但也有更通用的 slice 类型，比如数组。

```rust
let arr = [1, 2, 3, 4, 5];
let slice = &arr[1..3];
assert_eq!(slice, &[2, 3]);
```

这个 slice 的类型是 `&[i32]`。它跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度。可以对其它所有集合使用这类 slice。

