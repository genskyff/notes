>   本系列文章使用的 Rust Edition 为 `2021`。
>
>   主要参考：
>
>   -   [Rust 程序设计语言](https://kaisery.github.io/trpl-zh-cn/)
>   -   [Rust 标准库](https://rustwiki.org/zh-CN/std/)
>   -   [Rust 参考手册](https://minstrel1977.gitee.io/rust-reference/introduction.html)

# 1 环境配置

## 安装 Rust

### Windows

前往 [官方页面](https://www.rust-lang.org/tools/install) 下载安装。

### Linux / macOS

```shell
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

### 配置文件

Rust 默认会在 *~/.rustup* 中安装工具链，在 *~/.cargo* 安装 Cargo 相关工具及第三方二进制 Crate。

*~/.rustup/settings.toml* 保存了工具链相关的配置，对于 Cargo 的构建配置，支持全局配置和特定项目的本地配置。构建时 Cargo 会在**当前目录和所有父目录**中查找配置文件， 该文件保存了 Cargo 构建相关的配置，其查找顺序按照优先级从高到低为：

-   通过命令行 `--config <key>=<value>` 选项传递的参数
-   环境变量

-   *workspace/foo/baz/.cargo/config.toml*

-   *workspace/foo/.cargo/config.toml*

-   *package/.cargo/config.toml*
-   *~/.cargo/config.toml*
-   *package/Cargo.toml*

所有配置文件的键值会被合并，重复的以优先级高的为准，相同优先级以后定义的为准。命令行直接传递的优先级最高，*config.toml* 优先级大于 *Cargo.toml*，对于 *config.toml*，嵌套越深的优先级越高。执行 Cargo 时，当前目录的子目录中的配置文件会被忽略。

>   配置文件使用 [TOML](https://toml.io/cn/v1.0.0) 格式。

## 构建工具

### rustup

**rustup** 是管理 Rust 工具链的命令行工具。

```shell
# 查看 rustup 版本
rustup -V

# 查看工具链配置
rustup show

# 检查工具链更新
rustup check

# 更新工具链
rustup update

# 更新 rustup
rustup self update

# 卸载 rust 和 rustup
rustup self uninstall

# 查看本地文档
rustup doc

# 查看工具链相关
rustup toolchain help

# 查看工具组件相关
rustup component help

# 查看编译目标相关
rustup target help

# 设置全局默认工具链
rustup default <stable|nightly>

# 设置目录和子目录的工具链
rustup override set <stable|nightly>

# 恢复当前目录和子目录为默认工具链
rustup override unset
```

>   更多关于 rustup 的信息，可参考 [The rustup book](https://rust-lang.github.io/rustup/)。

### rustc

**rustc** 是 Rust 的编译器。

```shell
# 查看 rust 版本
rustc -V

# 打印指定选项的编译器信息
rustc --print <cfg|calling-conventions|target-list|target-cpus|target-features>

# 编译时指定输出文件名
rustc <file> -o <name>

# 编译为指定类型文件（默认为 bin）
rustc <file> --crate-type <bin|lib|rlib|dylib|cdylib|staticlib|proc-macro>

# 编译时将指定目录添加到库搜索路径
rustc <file> -L <path>

# 编译时链接到指定的库（默认库类型为 dylib）
rustc <file> -l [static|dylib=]<name>

# 编译时指定 Rust 版本（默认为 2015）
rustc <file> --edition <2015|2018|2021|2024>

# 编译时输出中间文件
rustc <file> --emit <asm|llvm-ir|obj|mir>

# 编译时配置额外编译信息
rustc <file> --cfg <name>[="value"]

# 编译时配置代码生成器选项
rustc <file> -C <opt>=<value>

# 编译时优化，等同于 -C opt-level=2
rustc <file> -O
```

>   更多关于 rustc 的信息，可参考 [The rustc book](https://doc.rust-lang.org/rustc/index.html)。

### Cargo

**Cargo** 是 Rust 的构建系统和包管理器。

```shell
# 查看 cargo 版本
cargo -V

# 创建二进制项目（默认选项）
cargo new <name> --bin

# 创建库项目
cargo new <name> --lib

# 创建时指定版本控制系统（默认为 git）
cargo new <name> --vcs <none|git>

# 将目录初始化为 Rust 项目
cargo init

# 查找依赖
cargo search <name>

# 添加依赖
cargo add <name>

# 删除依赖
cargo remove <name>

# 更新依赖
cargo update <name>

# 快速检查代码（不编译）
cargo check

# release 编译（默认为 dev）
cargo build -r

# release 编译运行（默认为 dev）
cargo run -r

# 编译并将额外参数传递给 rustc
cargo rustc [opt] [-- args]

# 清空 target 目录
cargo clean
```

>   更多关于 Cargo 的信息，可参考 [The Cargo Book](https://doc.rust-lang.org/cargo/)。

通常由 Cargo 创建的项目结构为：

```
.
├── .git
├── .gitignore
├── Cargo.lock（实际依赖版本）
├── Cargo.toml（项目配置）
├── src（源代码）
│   ├── lib.rs
│   └── main.rs
└── target（构建结果）
    ├── debug
    └── release
```

此外通常还会包含：

```
.
├── benches（基准测试）
│   ├── bench1.rs
│   └── bench2.rs
├── build.rs（构建脚本）
├── examples（示例代码）
│   ├── exp1.rs
│   └── exp2.rs
└── tests（集成测试）
    ├── test1.rs
    └── test2.rs
```

*Cargo.toml* 为项目配置文件，其内容通常为：

```toml
[package]
name = "hello"
version = "0.1.0"
edition = "2021"

[dependencies]
rand = "0.8.5"
tokio = "*"

[dev-dependencies]
criterion = { version = "0.5", features = ["html_reports"] }
```

-   `[package]`：配置包的主要信息；
-   `[dependencies]`：配置 dev 和 release 模式的依赖，为语义化版本；
-   `[dev-dependencies]`：配置 dev 模式的依赖。

使用 `cargo build` 编译后，*target/debug* 通常包含：

```
./target/debug
├── build
├── deps
├── examples
├── hello.d
├── hello.exe
├── hello.pdb
└── incremental
```

-   **build**：构建脚本 *build.rs* 执行的结果；
-   **deps**：依赖和库的编译结果；
-   **examples**：示例代码 *examples* 的编译结果；
-   **hello.d**：二进制输出 *hello.exe* 的所有依赖；
-   **hello.exe**：二进制输出；
-   **hello.pdb**：包含调试信息；
-   **incremental**：包含增量编译的状态信息。

## 构建配置

在 *config.toml* 和 *Cargo.toml* 中可以配置构建相关参数来影响编译器行为。

### profile 配置

`profile` 为发布配置，默认包含四种：

-   **dev**：`cargo build/run/check/rustc` 使用；
-   **release**：`cargo build/run/check/rustc/test -r` 和 `cargo install` 使用；
-   **test**：`cargo test` 使用，基于 dev，用于单元、集成和文档测试；
-   **bench**：`cargo bench` 使用，基于 release，用于基准测试。

>   *examples* 中的示例代码默认使用 `dev` 配置。

```toml
[profile.release]
opt-level = 3
debug = false
strip = true
lto = true
panic = "abort"
```

常见配置：

-   **opt-level**：`-C opt-level` 标志，表示优化级别，级别越高编译时间越多；
    -   `0`：dev 默认值；

    -   `3`：release 默认值；

    -   `s`：优化二进制文件大小。

-   **debug**：`-C debuginfo` 标志，控制二进制文件中包含的调试信息；
    -   `false`：没有调试信息，release 默认值；

    -   `true`：包含调试信息，dev 默认值。

-   **strip**：` -C strip` 标志，控制链接器需要删除哪些信息；
    -   `false`：默认值，保留所有信息；
    -   `true`：删除调试和符号信息；

-   **lto**：控制 `-C lto` 标志的链接时优化策略，会增加编译时间和内存消耗；
    -   `false`：默认值，只对代码生成单元中的本地包进行优化，若代码生成单元数为 1 或 `opt-level` 为 0，则不进行优化；
    -   `true`：最大程度优化，但最消耗资源；
    -   `off`：禁用优化。

-   **panic**：控制 `-C panic` 标志的 panic 发生时的策略，单元、集成、文档和基准测试，以及构建脚本、过程宏只会使用 `unwind`。
    -   `unwind`：默认值，panic 后进行栈展开；
    -   `abort`：panic 后直接中止程序，由操作系统回收资源。

### 自定义 profile

除了默认的四种 profile，还可以自定义。当定义 profile 时，必须指定 `inherits` 用于说明当配置缺失时，缺失项要基于哪个 profile 配置。

```toml
[profile.my-profile]
inherits = "release"
lto = true
```

在构建时使用 `--profile` 选项来指定自定义 profile：

```shell
cargo build --profile my-profile
```

自定义 profile 的编译结果存放在 `target/` 下同名目录中。

### 构建依赖 profile

默认情况下，所有 profile 都不会应用到构建脚本、过程宏和这两者的依赖，且不会显示调试信息，但可以配置 `build-override` 来覆盖默认行为。

```toml
[profile.dev.build-override]
debug = true

[profile.release.build-override]
strip = true
```

### 特定包 profile

默认情况下，profile 会应用到所有包，但可以配置 `package.name` 来指定特定包构建时所使用的 profile。

```toml
# 指定 foo 包的配置
[profile.dev.package.foo]
opt-level = 2

# 指定除了工作区之外的依赖包的配置
[profile.dev.package."*"]
strip = true
```

如果包同时是普通依赖和构建脚本、宏的依赖，同时又配置了 `build-override`，那么会被构建两次，这会增加编译时间。

### profile 优先级

profile 的优先级从高到低为：

-   `[profile.<name>.package.<name>]`
-   `[profile.<name>.package."*"]`
-   `[profile.<name>.build-override]`
-   `[profile.<name>]`
-   默认配置

### 其它配置

除了 profile 外，还有许多其它常用配置。

```toml
[alias]
b = "build"
space_example = ["run", "--release", "--", "\"command list\""]

[build]
rustflags = ["…", "…"]

[http]
proxy = "host:port"

[registries.<name>]
index = "…"
token = "…"

[target.<cfg>]
rustflags = ["…", "…"]
```

>   更多关于可配置的选项，可参考 [Cargo 配置](https://doc.rust-lang.org/cargo/reference/config.html)。

## 构建脚本

有些包需要编译第三方非 Rust 代码，例如 C 库。其他包需要链接到 C 库，这些库可以位于系统上，也可能需要从源代码构建。其他人仍然需要功能设施，例如构建之前的代码生成（想想解析器生成器）。

Cargo 的目的并不是取代针对这些任务进行了良好优化的其他工具，但它确实通过自定义构建脚本与它们集成。将指定的文件放置`build.rs`在包的根目录中将导致 Cargo 编译该脚本并在构建包之前执行它。

```rust
// Example custom build script.
fn main() {
    // Tell Cargo that if the given file changes, to rerun this build script.
    println!("cargo:rerun-if-changed=src/hello.c");
    // Use the `cc` crate to build a C file and statically link it.
    cc::Build::new()
        .file("src/hello.c")
        .compile("hello");
}
```

构建脚本的一些示例用例是：

-   构建捆绑的 C 库。
-   在主机系统上查找 C 库。
-   从规范生成 Rust 模块。
-   执行 crate 所需的任何特定于平台的配置。

以下部分描述了构建脚本的工作原理，[示例章节](https://doc.rust-lang.org/cargo/reference/build-script-examples.html)显示了有关如何编写脚本的各种示例。

>   注意：[`package.build`清单键](https://doc.rust-lang.org/cargo/reference/manifest.html#package-build)可用于更改构建脚本的名称，或完全禁用它。

### [构建脚本的生命周期](https://doc.rust-lang.org/cargo/reference/build-scripts.html#life-cycle-of-a-build-script)

在构建包之前，Cargo 会将构建脚本编译为可执行文件（如果尚未构建）。然后它将运行该脚本，该脚本可以执行任意数量的任务。该脚本可以通过将前缀为 的特殊格式命令打印`cargo:`到 stdout 来与 Cargo 进行通信。

如果构建脚本的任何源文件或依赖项发生更改，则将重新构建构建脚本。

默认情况下，如果包中的任何文件发生更改，Cargo 将重新运行构建脚本。通常，最好使用下面的[更改检测](https://doc.rust-lang.org/cargo/reference/build-scripts.html#change-detection)`rerun-if`部分中描述的命令来缩小触发构建脚本再次运行的焦点。

一旦构建脚本成功执行完毕，包的其余部分将被编译。如果出现错误，脚本应以非零退出代码退出以停止构建，在这种情况下，构建脚本的输出将显示在终端上。

### [构建脚本的输入](https://doc.rust-lang.org/cargo/reference/build-scripts.html#inputs-to-the-build-script)

当构建脚本运行时，构建脚本有许多输入，全部以[环境变量的](https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts)形式传递。

除了环境变量之外，构建脚本的当前目录是构建脚本包的源目录。

### [构建脚本的输出](https://doc.rust-lang.org/cargo/reference/build-scripts.html#outputs-of-the-build-script)

[`OUT_DIR`构建脚本可以将任何输出文件或中间工件保存在环境变量](https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts)中指定的目录中。脚本不应修改该目录之外的任何文件。

构建脚本通过打印到标准输出来与 Cargo 进行通信。Cargo 会将以 开头的每一行解释`cargo:`为影响包编译的指令。所有其他行都将被忽略。

>   `cargo:`注意：构建脚本打印的指令顺序*可能会*`cargo`影响传递给 的 参数的顺序`rustc`。反过来，传递给链接器的参数顺序`rustc`可能会影响传递给链接器的参数顺序。因此，您需要注意构建脚本指令的顺序。例如，如果对象`foo`需要链接到库`bar`，您可能需要确保库`bar`的 [`cargo:rustc-link-lib`](https://doc.rust-lang.org/cargo/reference/build-scripts.html#rustc-link-lib)指令出现在 链接对象的指令*之后*`foo`。

在正常编译期间，脚本的输出对终端隐藏。如果您想直接在终端中查看输出，请使用该`-vv`标志将 Cargo 调用为“非常详细”。仅当运行构建脚本时才会发生这种情况。如果 Cargo 确定没有任何更改，它将不会重新运行脚本，请参阅下面的[更改检测](https://doc.rust-lang.org/cargo/reference/build-scripts.html#change-detection)以了解更多信息。

构建脚本打印到标准输出的所有行都会写入类似的文件 `target/debug/build/<pkg>/output`（精确位置可能取决于您的配置）。stderr 输出也保存在同一目录中。

以下是 Cargo 识别的指令的摘要，每一条指令的详细说明如下。

# 2 模块系统

**模块系统**是 Rust 中一系列与作用域相关的功能，其中包含：

-   **包**：Cargo 用来构建、测试和分享 Crate 的功能；
-   **Crate**：编译和链接的基本单元；
    -   一个或多个二进制 Crate 或一个库 Crate；
    -   Crate **根**描述如何构建该 Crate；
    -   *Cargo.toml* 描述如何构建这些 Crate。
-   **模块**：使用  `use` 关键字控制作用域和路径的私有性；
-   **路径**：命名结构体、枚举、函数或模块等项的方式。

## 包和 Crate

编译模型以 Crate 为中心，每次编译一个 Crate，并生成一个二进制形式的可执行或库文件。

默认情况下，使用 `cargo new` 时会创建一个包，同时也会创建一个二进制 Crate。若一个目录含有 *Cargo.toml*、*src/main.rs* 或 *src/lib.rs*，则该目录自动成为一个包。一个包必须至少有一个二进制或库 Crate，可以同时拥有，但库 Crate 最多有一个。其中 *src/main.rs* 或 *src/lib.rs* 就是与包同名的二进制或库 Crate 的根。Crate 根文件将由 Cargo 传递给 rustc 来构建。

若包带有多个二进制 Crate，需置于 *src/bin* 中，其中每个文件都需要包含一个 `main` 函数，都为一个单独的二进制 Crate，都会被编译成与文件名相同的可执行文件。此时可以不再需要 *src/main.rs*，但若存在也会被当作二进制 Crate，并编译成与 Crate 名相同的可执行文件。

```
./src
├── bin       
│   ├── foo.rs（二进制 Crate）
│   └── baz.rs（二进制 Crate）
├── lib.rs（库 Crate）
└── main.rs（二进制 Crate）
```

默认情况下，`cargo build` 会编译包含库 Crate 在内的所有 Crate，若想单独编译 *src/bin* 中的二进制 Crate，可以使用 `--bin` 选项。

```shell
cargo build --bin <crate>
```

但这种方式不能单独编译 *src/main.rs*，因为它代表整个包，因此需要使用包名。

```shell
cargo build --bin <package>
```

库 Crate 也能被单独编译。默认情况下，Cargo 使用 Crate 名、rustc 使用文件名，并加上 `lib` 前缀。

```shell
# 输出 lib<filename>.rlib
rustc --crate-type lib <filename>.rs

# 输出 lib<crate>.rlib
cargo build --lib
```

不使用 Cargo 而是使用 rustc 来编译一个单独的文件时，可以使用内部属性来设置编译期行为。

```rust
// hello.rs

// crate 名
#![crate_name = "my_lib"]

// 输出文件的类型
#![crate_type = "lib"]

pub fn hello() {
    println!("hello world!");
}
```

然后就可以直接编译：

```shell
# 输出 libmy_lib.rlib
rustc hello.rs
```

### 源文件

Rust 源文件以 UTF-8（可带 BOM）编码，二进制 Crate 文件开头可以有一行 [Shebang](https://zh.wikipedia.org/wiki/Shebang)，文件后缀为 `.rs`。

```rust
#!/usr/bin/env rustx

fn main() {
    println!("hello world!");
}
```

使用 Shebang 将源文件作为脚本由操作系统使用指定的解释器来执行。Rust 在设计上可由编译器和解释器实现，但目前仅有 rustc 这唯一的编译器实现，因此可以通过编译，但没实际效果。

>   Shebang 前不能有包括注释在内的行。

### main 函数

一个含有 `main` 函数的源文件就是一个二进制 Crate。`main` 函数不能有参数，不能对其声明任何 trait 约束或生命周期约束，且返回类型必须实现 `Termination` trait。

标准库中实现了 `Termination` trait 的类型为：

-   `()`
-   `!`
-   `ExitCode`
-   `Result<(), E> where E: Debug`
-   `Result<Infallible, E> where E: Debug`

### 使用 Crate

#### 库 Crate

可以在一个包中同时包含二进制 crate 和库 crate，如一个名为 `mypkg` 包，其中包含了 *main.rs* 和 *lib.rs*，那么这两个的 crate 名都与包名相同，但要在 main.rs 中使用库的内容，需要使用 use 关键字导入，或在路径中包含 crate 名。

**文件：lib.rs**

```rust
pub fn foo() {}
```

**文件：main.rs**

```rust
use mypkg::foo；

fn main() {
    foo();
    mypkg::foo();
}
```

#### 外部 Crate

[Crates.io](https://crates.io/) 上有很多社区成员发布的 crate，将其引入自己的项目涉及到相同的步骤：在 *Cargo.toml* 列出并通过 `use` 将其中定义的项引入包的作用域中。

标准库 `std` 对于自己的包来说也是外部 crate，但因为标准库随 Rust 语言一同分发，无需修改 *Cargo.toml* 来引入 `std`，不过需要通过 `use` 将标准库中定义的项引入项目包的作用域中来引用它们，如 `HashMap`。

```rust
use std::collections::HashMap;
```

## 模块

一个 Crate 包含一个嵌套的带作用域的模块树。这个树的顶层是一个匿名的模块（从模块内部路径的角度来看），并且一个 crate 中的任何程序项都有一个规范的模块路径来表示它在 crate 的模块树中的位置。

Rust 源文件描述了一个模块，其名称和（在当前 crate 的模块树中的）位置是从源文件外部定义的：要么通过引用源文件中的显式模块项，要么由 crate 本身的名称定义。每个源文件都是一个模块，但并非每个模块都需要自己的源文件：多个模块定义可以嵌套在同一个文件中。

### 分割模块

可以在一个文件中定义多个模块，但当模块变得更大时，将它们的定义移动到一个单独的文件中使代码更容易阅读。

有两种分割的方式，一种是创建与模块同名的文件来管理，另一种是创建与模块同名的文件夹，并在其中创建 *mod.rs* 来管理，后一种通常在 Rust Edition 2021 以前用的比较多。

>   不能在同一个项目中混用两种风格的分割方式。

#### 使用同名文件（新风格）

将 `sound` 模块移动到单独的文件 *src/sound.rs* 中，在 `mod sound` 后使用分号来告诉 Rust 在另一个与模块同名的文件中加载模块的内容。

**文件：src/main.rs**

```rust
mod sound;

fn main() {
    crate::sound::instrument::clarinet();   // 绝对路径
	sound::instrument::clarinet();          // 相对路径
}
```

**文件：src/sound.rs**

```rust
pub mod instrument {
    pub fn clarinet() {}
}
```

继续将 `instrument` 模块也提取到其自己的文件中，修改 *src/sound.rs* 只包含 `instrument` 模块的声明。

**文件：src/sound.rs**

```rust
pub mod instrument;
```

接着创建 *src/sound* 目录和 *src/sound/instrument.rs* 文件来包含 `instrument` 模块的定义。

**文件：src/sound/instrument.rs**

```rust
pub fn clarinet() {}
```

此时的文件树为：

```
src
├── main.rs
├── sound
│   └── instrument.rs
└── sound.rs
```

模块树依然保持相同，`main` 中的函数调用也无需修改继续保持有效，即使其定义存在于不同的文件中。这样随着代码增长可以将模块移动到新文件中。

#### 使用 mod.rs（旧风格）

通过在每个模块的文件夹下单独创建一个 *mod.rs* 来管理一个模块。

还是同样的方法，在 *src/main.rs* 中只包含 `sound`模块的声明，但不再创建 *src/sound.rs*，而是创建 *sound* 文件夹，并在其中创建 *mod.rs*。

**文件：src/sound/mod.rs**

```rust
pub mod instrument {
    pub fn clarinet() {}
}
```

同样再把 `instrument` 模块提取出来，此时可以跟之前一样创建 `src/sound/instrument.rs`，还可以创建 *src/sound/instrument/mod.rs*。

**文件：src/sound/mod.rs**

```rust
pub mod instrument;
```

**文件：src/sound/instrument/mod.rs**

```rust
pub fn clarinet() {}
```

此时的文件树为：

```
src
├── main.rs
└── sound
    ├── instrument
    │   └── mod.rs
    └── mod.rs
```



## 路径

路径用来引用模块树中的项。若要调用函数，需要知道其**路径**。

路径可以有两种形式：

-   **绝对路径**从 crate 根开始，以 crate 名或字面值 `crate` 开头。
-   **相对路径**从当前模块开始，以 `self`、`super` 或当前模块名开头。

绝对路径和相对路径都后跟一个或多个由双冒号 `::` 分隔的标识符。

在 `main` 函数中调用 `clarinet` 函数。

```rust
mod sound {
    mod instrument {
        fn clarinet() {}
    }
}

fn main() {
    crate::sound::instrument::clarinet();   // 绝对路径
	sound::instrument::clarinet();          // 相对路径
}
```

因为 `clarinet` 与 `main` 定义于同一 crate 中，通过 `crate` 关键字来以绝对路径的方式来调用函数。由于 `sound` 是与 `main` 函数相同模块树级别的模块，也可以通过使用其名称来以相对路径的方式来调用函数。

### 私有性边界

上面这个程序不能编译，因为 `instrument` 模块是私有的。

模块是 Rust 中的**私有性边界**。若期望函数或结构体是私有的，可以将其放入模块。

私有性规则有如下：

-   所有项（函数、方法、结构体、枚举、模块和常量）默认是私有的；
-   可以使用 `pub` 关键字使项变为公有；
-   不允许使用定义于当前模块的子模块中的私有代码；
-   允许使用任何定义于父模块或当前模块中的代码。

对于没有 `pub` 关键字的项，从当前模块向下看时是私有的，向上看时是公有的。

### pub 关键字

使用 `pub` 关键字使得项变为公有。

```rust
mod sound {
    pub mod instrument {
        fn clarinet() {}
    }
}

fn main() {
    crate::sound::instrument::clarinet();   // 绝对路径
	sound::instrument::clarinet();          // 相对路径
}
```

`instrument` 的内容仍然是私有的，使模块公有并不使其内容也是公有的。模块上的 `pub` 关键字允许其父模块 `sound` 引用它。

这个程序依然不能编译，因为 `clarinet` 函数是私有的，需在 `clarinet` 函数前增加 `pub` 关键字使其变为公有。

```rust
mod sound {
    pub mod instrument {
        pub fn clarinet() {}
    }
}
```

在绝对路径的情况下，从 crate 根开始，有一个定义于 crate 根中的 `sound` 模块，`sound` 模块不是公有的，不过因为 `main` 函数与 `sound` 定义于同一模块中，可以从 `main` 中引用 `sound`。接下来是 `instrument`，这个模块标记为 `pub`，所以可以访问 `instrument`。最后，`clarinet` 函数被标记为 `pub` 所以可以调用该函数。

在相对路径的情况下，其逻辑与绝对路径相同。不同于从 crate 根开始，路径从 `sound` 开始。`sound` 模块与 `main` 定义于同一模块，所以从 `main` 所在模块开始定义的路径是有效的。接下来因为 `instrument` 和 `clarinet` 被标记为 `pub`，路径其余的部分也是有效的，因此函数调用也是有效的。

### super 关键字

使用 `super` 关键字来构建相对路径：该路径从**父**模块而不是从当前模块开始。

```rust
mod instrument {
    fn clarinet() {
        super::breathe_in();
    }
}

fn breathe_in() {}
```

`clarinet` 函数位于 `instrument` 模块中，所以可以使用 `super` 进入 `instrument` 的父模块，也就是根 `crate`，而 `breathe_in` 在这一层级中。

使用 `super` 开头的相对路径能够更容易修改有着不同模块层级结构的代码。如将 `instrument` 模块和 `breathe_in` 函数放入 `sound` 模块中，这时只需增加 `sound` 模块即可。

```rust
mod sound {
    mod instrument {
        fn clarinet() {
            super::breathe_in();
        }
    }

    fn breathe_in() {}
}
```

使用相对路径在重新布局模块时可能只需少量的修改。

### 对结构体和枚举使用 pub

在模块中对结构体定义中使用 `pub`，可以使其变为公有，然而其字段仍是私有的。可以在每一个字段的基准上选择其是否公有。

```rust
mod info {
    pub struct User {
        pub name: String,
        id: u32
    }

    impl User {
        pub fn new(name: &str) -> User {
            User {
                name: String::from(name),
                id: 1
            }
        }
    }
}

fn main() {
    let mut u = info::User::new("root");
    u.name = String::from("admin");
    println!("{}", u.name);
    println!("{}", u.id);    // 错误
}
```

因为 `info::User` 结构体的 `name` 字段是公有的，在 `main` 中可以使用点号读写 `name` 字段，但不允许在 `main` 中使用 `id` 字段，因为其是私有的。因为 `info::User` 中有私有字段，需要提供一个公有的关联函数来构建 `User` 实例。若没有提供这一函数，就不能在 `main` 中创建 `User` 实例，因为在 `main` 中不允许设置私有字段 `id` 的值。

即使是单元结构体，也需要给字段加上 `pub` 关键字才能公有。

```rust
mod point {
    pub struct Point(pub u32, pub u32);
}
```

相反，若有一个公有枚举，则其所有成员都是公有，只需在 `enum` 关键词前加上 `pub`。

```rust
mod menu {
    pub enum Appetizer {
        Soup,
        Salad
    }
}

fn main() {
    let order1 = menu::Appetizer::Soup;
    let order2 = menu::Appetizer::Salad;
}
```

因为 `Appetizer` 枚举是公有的，可以在 `main` 中使用 `Soup` 和 `Salad` 成员。

### use 关键字

使用绝对路径或相对路径是冗长和重复的，可以使用 `use` 关键字一次性将路径引入作用域。

```rust
mod sound {
    pub mod instrument {
        pub fn clarinet() {}
    }
}

use crate::sound::instrument;

fn main() {
    instrument::clarinet();
}
```

在作用域中增加 `use` 和绝对路径类似于在文件系统中创建软连接，通过 `use` 引入作用域的路径也会检查私有性。

通过 `use` 和相对路径来将项引入作用域：

```rust
mod sound {
    pub mod instrument {
        pub fn clarinet() {}
    }
}

use self::sound::instrument;

fn main() {
    instrument::clarinet();
}
```

若调用项目的代码移动到模块树的不同位置但是定义项目的代码却没有，那么使用 `use` 指定绝对路径可以使更新更轻松。

```rust
mod sound {
    pub mod instrument {
        pub fn clarinet() {}
    }
}

mod performance_group {
    use crate::sound::instrument;

    pub fn clarinet_trio() {
        instrument::clarinet();
    }
}

fn main() {
    performance_group::clarinet_trio();
}
```

相反，若对指定了相对路径的代码做同样的修改，则需要将 `use self::sound::instrument` 变为 `use super::sound::instrument`。

###  use 路径使用习惯

对于函数，倾向于通过 `use` 指定函数的父模块接着指定父模块来调用方法：

```rust
use crate::sound::instrument;

fn main() {
    instrument::clarinet();
}
```

而不是直接使用方法：

```rust
use crate::sound::instrument::clarinet;

fn main() {
    clarinet();
}
```

这样会清楚的表明了函数不是本地定义的，同时仍最小化了指定全路径时的重复。

---

对于结构体、枚举和其它项，倾向于通过 `use` 指定项的全路径：

```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
```

在使用全路径这种指定方式时，若 `use` 语句将两个同名的项引入作用域时，将会发生错误：

```rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {}
fn function2() -> io::Result<()> {}
```

若直接指定 `use std::fmt::Result` 和 `use std::io::Result`，则作用域中会有两个 `Result` 类型，Rust 无法判断使用的是哪个 `Result`。

### as 关键字

将两个同名类型引入同一作用域时，可以通过在 `use` 后加上 `as` 来重命名引入作用域的类型。

```rust
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {}
fn function2() -> IoResult<()> {}
```

### 使用 pub use 重导出

当使用 `use` 关键字将名称导入作用域时，在新作用域中可用的名称是私有的。通过**重导出**，即结合 `pub` 和 `use`，将项引入作用域并同时使其可供其它代码引入自己的作用域。

```rust
mod sound {
    pub mod instrument {
        pub fn clarinet() {}
    }
}

mod performance_group {
    pub use crate::sound::instrument;

    pub fn clarinet_trio() {
        instrument::clarinet();
    }
}

fn main() {
    performance_group::clarinet_trio();
    performance_group::instrument::clarinet();
}
```

通过 `pub use`，`main` 函数可以通过新路径 `performance_group::instrument::clarinet` 来调用 `clarinet` 函数。若没有指定 `pub use`，`clarinet_trio` 函数可以在其作用域中调用 `instrument::clarinet`，但 `main` 则不允许使用这个新路径。

通过结合 `pub` 和重导出，可以方便的向外暴露 API。

>   关于 Rust 的 API 设计，可参考 [The Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)。

### 嵌套路径

当需要引入很多定义于相同包或相同模块的项时，为每一项单独列出一行会占用很大的空间。

```rust
use std::cmp::Ordering;
use std::io;
```

使用嵌套路径将同样的项在一行中引入。

```rust
use std::{cmp::Ordering, io};
```

对于一个完全包含在另一个路径中的路径。

```rust
use std::io;
use std::io::Write;
```

两个路径的相同部分是 `std::io`。为了在一行 `use` 语句中引入这两个路径，可以在嵌套路径中使用 `self`。

```rust
use std::io::{self, Write};
```

### glob 运算符

将一个路径下所有公有项引入作用域，可以在指定路径后跟 glob 运算符 `*`。

```rust
use std::collections::*;
```

此语句将 `std::collections` 中定义的所有公有项引入当前作用域。

## 工作空间

可以创建一个包含二进制 crate 和库 crate 的包，但随着项目越来越大，库 crate 将持续增大，这时需要将库 crate 拆分成多个 crates。对于这种情况，Cargo 提供了一个叫工作空间的功能，它可以管理多个相关的协同开发的包。

### 创建工作空间

**工作空间**是一系列共享相同 *Cargo.lock* 和 *target* 目录的包。设有一个库 crate，包含两个功能：一个 `add_one` 函数，一个 `add_two` 函数，将这两个功能分别放到两个库 crates 中，然后二进制 crate 利用库中的功能完成业务逻辑。这时就可以把这两个库 crates 和二进制 crate 这三个 crates 放到同一个工作空间下。

首先创建一个 *demo* 目录，这是最外层的目录，用来当作工作空间：

```shell
mkdir demo
cd demo
```

然后在 *demo* 下通过 `cargo new` 创建三个 crates：

-   *add_one* 和 *add_two* 为库 crate；
-   *adder* 为二进制 crate，用来调用库 crate 中的功能。

为了使 *demo* 被 Cargo 识别为工作空间，而不是单纯用来存放包的目录，需要在其中创建 *Cargo.toml* 文件。这个 *Cargo.toml* 文件配置了整个工作空间，且不包含 `[package]` 或其它通过 `cargo new` 创建的包中的元信息，而是以 `[workspace]` 项作为开始，并通过指定需要包含的 crates 的路径来为工作空间增加成员。

```toml
[workspace]
members = [
    "adder",
    "add_one",
    "add_two"
]
```

这时的文件目录树为：

```
demo（工作空间，构建前）
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── add_two
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
└── adder
    ├── Cargo.toml
    └── src
        └── main.rs
```

### 工作空间的依赖关系

现在就可以运行 `cargo build` 来构建整个项目，和一般构建不同，它会在 *demo* 即工作空间的根目录下生成 *target* 目录，而不是在每个 crate 目录下都生成。即使进入各 crate 目录运行构建也是如此。因为工作空间中的 crates 被看作是一个整体，它们之间相互依赖，没有必要在每个 crate 中都生成。

```
demo（工作空间，构建后）
├── Cargo.lock
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
├── add_two
│   ├── Cargo.toml
│   └── src
├── adder
│   ├── Cargo.toml
│   └── src
└── target
```

可以看到，所有 crates 还都共享同一个 *Cargo.lock*，这确保了所有的 crates 都使用完全相同版本的依赖且相互兼容。如在 *add_one/Cargo.toml* 和 *add_two/Cargo.toml* 中都增加外部的 `rand` crate，则 Cargo 会将其都解析为同一版本并将这些依赖信息记录到唯一的 *Cargo.lock* 中。

**文件：Cargo.lock**

```toml
[[package]]
name = "add_one"
version = "0.1.0"
dependencies = [
 "rand",
]

[[package]]
name = "add_two"
version = "0.1.0"
dependencies = [
 "rand",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]
```

可以看到，*add_one* 和 *add_two* 的都依赖了 `rand`，但 `[dependencies]` 下都只记录了依赖名，没有记录版本信息，因为它们都依赖同一个版本，若依赖不同的版本，则会有多个 `rand` 的版本信息。

```toml
[[package]]
name = "add_one"
version = "0.1.0"
dependencies = [
 "rand 0.7.3",
]

[[package]]
name = "add_two"
version = "0.1.0"
dependencies = [
 "rand 0.6.5",
]

[[package]]
name = "rand"
version = "0.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d71dacdc3c88c1fde3885a3be3fbab9f35724e6ce99467f7d9c5026132184ca"
dependencies = [
 "autocfg 0.1.8",
 "libc",
 "rand_chacha 0.1.1",
 "rand_core 0.4.2",
 "rand_hc 0.1.0",
 "rand_isaac",
 "rand_jitter",
 "rand_os",
 "rand_pcg",
 "rand_xorshift",
 "winapi",
]

[[package]]
name = "rand"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03"
dependencies = [
 "getrandom",
 "libc",
 "rand_chacha 0.2.2",
 "rand_core 0.5.1",
 "rand_hc 0.2.0",
]
```

---

构建时 Cargo 并不假定工作空间中的 crate 之间会相互依赖，所以需要在各 crate 的 *Cargo.toml* 中明确标明依赖关系。

设 *adder* 会依赖 *add_one* 和 *add_two*：

**文件：adder/Cargo.toml**

```toml
[dependencies]
add_one = { path = "../add_one" }
add_two = { path = "../add_two" }
```

接下来在库 crate 中添加功能：

**文件：add_one/src/lib.rs**

```rust
pub fn add_one(n: i32) -> i32 {
    n + 1
}
```

**文件：add_two/src/lib.rs**

```rust
pub fn add_two(n: i32) -> i32 {
    n + 2
}
```

然后在 *adder* 中调用：

```rust
use add_one;
use add_two;

fn main() {
    let one = add_one::add_one(1);
    let result = add_two::add_two(one);
    assert_eq!(4, result);
}
```

这时可以使用 `cargo build` 来构建整个项目了。由于目前工作空间只包含一个二进制 crate，所以可以直接使用 `cargo run` 来运行，但若包含多个二进制 crate，就需要使用 `-p` 参数来指定到底运行哪个二进制carte。

设又新增了 *adder_2* 这个二进制 crate，在根 *Cargo.toml* 中添加该成员，然后指定参数运行：

```shell
cargo run -p adder_2
```

# 3 属性

每个源文件包含任意个由程序项定义组成的代码序列，且这些源文件都可选地从应用于其内部模块的任意数量的属性开始，大部分这些属性都会会影响编译器行为。匿名的 crate 根模块可附带一些应用于整个 crate 的属性。

`no_main`属性

可在 crate 层级使用 *`no_main`属性*来禁止对可执行二进制文件发布 `main` symbol，即禁止当前 crate 的 main 函数的执行。当链接的其他对象定义了 `main`函数时，这很有用。

`crate_name`属性

可在 crate 层级应用 *`crate_name`属性*，并通过使用 *MetaNameValueStr*元项属性句法来指定 crate 的名称。

```rust
#![crate_name = "mycrate"]
```

crate 名称不能为空，且只能包含 [Unicode字母数字]或字符 `_` (U+005F)。

### 条件编译



### 测试



### 诊断



### 派生



### 代码生成



### 极限值



### 类型系统



## 文档



## Crates.io

