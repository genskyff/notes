>   本系列文章使用的 Rust Edition 为 `2021`。
>
>   主要参考：
>
>   -   [Rust 程序设计语言](https://kaisery.github.io/trpl-zh-cn/)
>   -   [Rust 标准库](https://rustwiki.org/zh-CN/std/)
>   -   [Rust 参考手册](https://minstrel1977.gitee.io/rust-reference/introduction.html)

# 1 环境配置

## 安装

### Windows

前往 [官方页面](https://www.rust-lang.org/tools/install) 下载安装。

### Linux / macOS

```shell
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

## 构建

### rustup

**rustup** 是管理 Rust 工具链的命令行工具。

```shell
# 查看 rustup 版本
rustup -V

# 查看工具链配置
rustup show

# 检查工具链更新
rustup check

# 更新工具链
rustup update

# 更新 rustup
rustup self update

# 卸载 rust 和 rustup
rustup self uninstall

# 查看本地文档
rustup doc

# 查看工具链相关
rustup toolchain help

# 查看工具组件相关
rustup component help

# 查看编译目标相关
rustup target help

# 设置全局默认工具链
rustup default <stable|nightly>

# 设置目录和子目录的工具链
rustup override set <stable|nightly>

# 恢复当前目录和子目录为默认工具链
rustup override unset
```

>   更多关于 rustup 的信息，可参考 [The rustup book](https://rust-lang.github.io/rustup/)。

### rustc

**rustc** 是 Rust 的编译器。

```shell
# 查看 rust 版本
rustc -V

# 打印指定选项的编译器信息
rustc --print [cfg|calling-conventions|target-list|target-cpus|target-features]

# 输出编译错误的详细解释
rustc <file> --explain

# 编译时指定输出文件名
rustc <file> -o <name>

# 编译为指定类型文件（默认为 bin）
rustc <file> --crate-type <bin|lib|rlib|dylib|cdylib|staticlib|proc-macro>

# 编译时将指定目录添加到库搜索路径
rustc <file> -L <path>

# 编译时链接到指定的库（默认库类型为 dylib）
rustc <file> -l [static|dylib=]<name>

# 编译时指定 Rust 版本（默认为 2015）
rustc <file> --edition <2015|2018|2021|2024>

# 编译时输出中间文件
rustc <file> --emit <asm|llvm-ir|obj|mir>

# 编译时配置额外编译信息
rustc <file> --cfg <name>[="value"]

# 编译时配置代码生成器选项
rustc <file> -C <opt=value>

# 编译时优化，等同于 -C opt-level=2
rustc <file> -O

# 编译时包含调试信息，等同于 -C debuginfo=2
rustc <file> -g
```

>   更多关于 rustc 的信息，可参考 [The rustc book](https://doc.rust-lang.org/rustc/index.html)。

### Cargo

**Cargo** 是 Rust 的构建系统和包管理器。

```shell
# 查看 cargo 版本
cargo -V

# 创建二进制项目（默认选项）
cargo new <name> --bin

# 创建库项目
cargo new <name> --lib

# 创建时指定版本控制系统（默认为 git）
cargo new <name> --vcs <none|git>

# 将目录初始化为 Rust 项目
cargo init

# 查找依赖
cargo search <name>

# 添加依赖
cargo add <name>

# 删除依赖
cargo remove <name>

# 更新依赖
cargo update <name>

# 快速检查代码（不编译）
cargo check

# 以 release 模式编译（默认为 dev）
cargo build -r

# 以 release 模式编译运行（默认为 dev）
cargo run -r

# 清空 target 目录
cargo clean
```

>   更多关于 Cargo 的信息，可参考 [The Cargo Book](https://doc.rust-lang.org/cargo/)。

通常由 Cargo 创建的项目结构为：

```
.
├── .git
├── .gitignore
├── Cargo.lock（实际依赖版本）
├── Cargo.toml（项目配置）
├── src（源代码）
│   ├── lib.rs
│   └── main.rs
└── target（构建结果）
    ├── debug
    └── release
```

此外通常还会包含：

```
.
├── benches（基准测试）
│   ├── bench1.rs
│   └── bench2.rs
├── build.rs（构建脚本）
├── examples（示例代码）
│   ├── exp1.rs
│   └── exp2.rs
└── tests（集成测试）
    ├── test1.rs
    └── test2.rs
```

*Cargo.toml* 为项目配置文件，其内容通常为：

```toml
[package]
name = "hello"
version = "0.1.0"
edition = "2021"

[dependencies]
rand = "0.8.5"
tokio = "*"

[dev-dependencies]
criterion = { version = "0.5", features = ["html_reports"] }
```

-   `[package]`：配置包的主要信息；
-   `[dependencies]`：配置 dev 和 release 模式的依赖，为语义化版本；
-   `[dev-dependencies]`：配置 dev 模式的依赖。

>   更多关于 TOML 的信息，可参考 [TOML](https://toml.io/cn/v1.0.0)。

使用 `cargo build` 编译后，*target/debug* 通常包含：

```
./target/debug
├── build
├── deps
├── examples
├── hello.d
├── hello.exe
├── hello.pdb
└── incremental
```

-   **build**：构建脚本 *build.rs* 执行的结果；
-   **deps**：依赖和库的编译结果；
-   **examples**：示例代码 *examples* 的编译结果；
-   **hello.d**：二进制输出 *hello.exe* 的所有依赖；
-   **hello.exe**：二进制输出；
-   **hello.pdb**：包含调试的状态信息；
-   **incremental**：包含增量编译的状态信息。

# 2 模块系统

**模块系统**是 Rust 中一系列与作用域相关的功能，其中包含：

-   **包**：Cargo 用来构建、测试和分享 Crate 的功能；
-   **Crate**：编译和链接的基本单元；
    -   一个或多个二进制 Crate 或一个库 Crate；
    -   Crate **根**描述如何构建该 Crate；
    -   *Cargo.toml* 描述如何构建这些 Crate。
-   **Mod**：使用  `use` 关键字控制作用域和路径的私有性；
-   **路径**：命名结构体、枚举、函数或模块等项的方式。

## 包和 Crate

编译模型以 Crate 为中心，每次编译一个 Crate，并生成一个二进制形式的可执行或库文件。

默认情况下，使用 `cargo new` 时会创建一个包，同时也会创建一个二进制 Crate。若一个目录含有 *Cargo.toml*、*src/main.rs* 或 *src/lib.rs*，则该目录自动成为一个包。一个包必须至少有一个二进制或库 Crate，可以同时拥有，但库 Crate 最多有一个。其中 *src/main.rs* 或 *src/lib.rs* 就是与包同名的二进制或库 Crate 的根。Crate 根文件将由 Cargo 传递给 rustc 来构建。

若包带有多个二进制 Crate，需置于 *src/bin* 中，其中每个文件都需要包含一个 `main` 函数，都为一个单独的二进制 Crate，都会被编译成与文件名相同的可执行文件。此时可以不再需要 *src/main.rs*，但若存在也会被当作二进制 Crate，并编译成与 Crate 名相同的可执行文件。

```
./src
├── bin       
│   ├── foo.rs（二进制 Crate）
│   └── bar.rs（二进制 Crate）
├── lib.rs（库 Crate）
└── main.rs（二进制 Crate）
```

默认情况下，`cargo build` 会编译包含库 Crate 在内的所有 Crate，若想单独编译 *src/bin* 中的二进制 Crate，可以使用 `--bin` 选项。

```bash
cargo build --bin foo
```

但这种方式不能单独编译 *src/main.rs*，因为它代表整个包，因此需要使用包名。

```bash
cargo build --bin <package>
```

库 Crate 也能被单独编译。默认情况下，Cargo 使用 Crate 名、rustc 使用文件名，并加上 `lib` 前缀。

```bash
# 输出 lib<filename>.rlib
rustc --crate-type lib <filename>.rs

# 输出 lib<crate>.rlib
cargo build --lib
```

使用 rustc 来编译一个单独的文件时，可以使用内部属性设置编译期行为。

```rust
// hello.rs

// crate 名
#![crate_name = "my_lib"]

// 输出文件的类型
#![crate_type = "lib"]

pub fn hello() {
    println!("hello world!");
}
```

然后就可以直接编译：

```shell
# 输出 libmy_lib.rlib
rustc hello.rs
```

### 源文件

Rust 源文件以 UTF-8（可带 BOM）编码，二进制 Crate 文件开头可以有一行 [Shebang](https://zh.wikipedia.org/wiki/Shebang)，文件后缀为 `.rs`。

```rust
#!/usr/bin/env rustx

fn main() {
    println!("hello world!");
}
```

使用 Shebang 将源文件作为脚本由操作系统使用指定的解释器来执行。Rust 在设计上可由编译器和解释器实现，但目前仅有 rustc 这唯一的编译器实现，因此可以通过编译，但没实际效果。

>   Shebang 前不能有包括注释在内的行。

### main 函数

一个含有 `main` 函数的源文件就是一个二进制 Crate。`main` 函数不能有参数，不能对其声明任何 trait 约束或生命周期约束，且返回类型必须实现 `Termination` trait。

标准库中，实现了 `Termination` trait 的类型为：

-   `()`
-   `!`
-   `ExitCode`
-   `Result<(), E> where E: Debug`
-   `Result<Infallible, E> where E: Debug`

## 模块

一个 Crate 包含一个嵌套的带作用域的模块树。这个树的顶层是一个匿名的模块（从模块内部路径的角度来看），并且一个 crate 中的任何程序项都有一个规范的模块路径来表示它在 crate 的模块树中的位置。

Rust 源文件描述了一个模块，其名称和（在当前 crate 的模块树中的）位置是从源文件外部定义的：要么通过引用源文件中的显式[模块(*Module*)](https://minstrel1977.gitee.io/rust-reference/items/modules.html)项，要么由 crate 本身的名称定义。每个源文件都是一个模块，但并非每个模块都需要自己的源文件：多个[模块定义](https://minstrel1977.gitee.io/rust-reference/items/modules.html)可以嵌套在同一个文件中。

## 属性

每个源文件包含任意个由程序项定义组成的代码序列，且这些源文件都可选地从应用于其内部模块的任意数量的[属性](https://minstrel1977.gitee.io/rust-reference/attributes.html)开始，大部分这些属性都会会影响编译器行为。匿名的 crate 根模块可附带一些应用于整个 crate 的属性。

### [`no_main`属性](https://minstrel1977.gitee.io/rust-reference/crates-and-source-files.html#no_main属性)

可在 crate 层级使用 *`no_main`[属性](https://minstrel1977.gitee.io/rust-reference/attributes.html)*来禁止对可执行二进制文件发布 `main` symbol，即禁止当前 crate 的 main 函数的执行。当链接的其他对象定义了 `main`函数时，这很有用。

## [`crate_name`属性](https://minstrel1977.gitee.io/rust-reference/crates-and-source-files.html#crate_name属性)

可在 crate 层级应用 *`crate_name`[属性](https://minstrel1977.gitee.io/rust-reference/attributes.html)*，并通过使用 [*MetaNameValueStr*](https://minstrel1977.gitee.io/rust-reference/attributes.html#meta-item-attribute-syntax)元项属性句法来指定 crate 的名称。

```rust
#![crate_name = "mycrate"]
```

crate 名称不能为空，且只能包含 [Unicode字母数字]或字符 `_` (U+005F)。

### 条件编译



### 测试



### 诊断



### 派生



### 代码生成



### 极限值



### 类型系统



## 文档



## Crates.io

