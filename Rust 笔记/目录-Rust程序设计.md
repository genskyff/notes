**第 1 章 为什么是Rust**
  **类型安全**
**第 2 章 Rust初体验**
  **2.1 下载和安装Rust**
  **2.2 一个简单的函数**
  **2.3 编写和运行单元测试**
  **2.4 处理命令行参数**
  **2.5 一个简单的Web服务器**
  **2.6 并发**
    **2.6.1 到底什么是曼德布洛特集合**
    **2.6.2 解析成对的命令行参数**
    **2.6.3 像素到复数的映射**
    **2.6.4 绘制集合**
    **2.6.5 写出图像文件**
    **2.6.6 并发的曼德布洛特程序**
    **2.6.7 运行曼德布洛特绘图器**
    **2.6.8 安全无形**
第 3 章 基本类型
  3.1 机器类型
    3.1.1 整数类型
    3.1.2 浮点类型
    3.1.3 布尔类型
    3.1.4 字符类型
  3.2 元组
  3.3 指针类型
    3.3.1 引用
    3.3.2 Box
    3.3.3 原始指针
  3.4 数组、向量和切片
    3.4.1 数组
    3.4.2 向量
    3.4.3 逐个元素地构建向量
    3.4.4 切片
  3.5 字符串类型
    3.5.1 字符串字面量
    3.5.2 字节字符串
    3.5.3 字符串在内存中的表示
    3.5.4 字符串
    3.5.5 使用字符串
    3.5.6 其他类似字符串的类型
  3.6 更多类型
第 4 章 所有权
  4.1 所有权
  4.2 转移
    4.2.1 更多转移操作
    4.2.2 转移与控制流
    4.2.3 转移与索引内容
  4.3 Copy类型：转移的例外
  4.4 Rc和Arc：共享所有权
第 5 章 引用
  5.1 引用作为值
    5.1.1 Rust引用与C++引用
    5.1.2 给引用赋值
    5.1.3 引用的引用
    5.1.4 比较引用
    5.1.5 引用永远不为空
    5.1.6 借用对任意表达式的引用
    5.1.7 对切片和特型对象的引用
  5.2 引用安全
    5.2.1 借用局部变量
    5.2.2 接收引用作为参数
    5.2.3 将引用作为参数传递
    5.2.4 返回引用
    5.2.5 结构体包含引用
    5.2.6 不同的生命期参数
    5.2.7 省略生命期参数
  5.3 共享与修改
  5.4 征服对象之海
第 6 章 表达式
  6.1 表达式语言
  6.2 块与分号
  6.3 声明
  6.4 if与match
    if let
  6.5 循环
  6.6 return表达式
  6.7 为什么Rust有循环
  6.8 函数与方法调用
  6.9 字段与元素
  6.10 引用操作符
  6.11 算术、位、比较和逻辑操作符
  6.12 赋值
  6.13 类型转换
  6.14 闭包
  6.15 优先级与关联性
  6.16 展望
第 7 章 错误处理
  7.1 诧异
    7.1.1 展开栈
    7.1.2 中止进程
  7.2 结果
    7.2.1 捕获错误
    7.2.2 结果类型别名
    7.2.3 打印错误
    7.2.4 传播错误
    7.2.5 处理多种错误类型
    7.2.6 处理“不会发生”的错误
    7.2.7 忽略错误
    7.2.8 在main()中处理错误
    7.2.9 声明自定义错误类型
    7.2.10 为什么是结果
**第 8 章 包和模块**
  **8.1 包**
    **构建分析**
  **8.2 模块**
    **8.2.1 把模块写在单独的文件中**
    **8.2.2 路径和导入**
    **8.2.3 标准前置模块**
    **8.2.4 特性项，Rust的基础**
  **8.3 将程序作为库发布**
  **8.4 src/bin目录**
  **8.5 属性**
  **8.6 测试和文档**
    **8.6.1 集成测试**
    **8.6.2 文档**
    **8.6.3 文档测试**
  **8.7 指定依赖**
    **8.7.1 版本**
    **8.7.2 Cargo.lock**
  **8.8 把包发布到crates.io**
  **8.9 工作空间**
 **8.10 还有惊喜**
第 9 章 结构体
  9.1 命名字段结构体
  9.2 类元组结构体
  9.3 类基元结构体
  9.4 结构体布局
  9.5 通过impl定义方法
  9.6 泛型结构体
  9.7 带生命期参数的结构体
  9.8 为结构体类型派生共有特型
  9.9 内部修改能力
第 10 章 枚举与模式
  10.1 枚举
    10.1.1 包含数据的枚举
    10.1.2 枚举的内存布局
    10.1.3 使用枚举的富数据结构
    10.1.4 泛型枚举
  10.2 模式
    10.2.1 模式中的字面量、变量和通配符
    10.2.2 元组与结构体模式
    10.2.3 引用模式
    10.2.4 匹配多种可能性
    10.2.5 模式护具
    10.2.6 @模式
    10.2.7 在哪里使用模式
    10.2.8 填充二叉树
  10.3 设计的考量
第 11 章 特型与泛型
  11.1 使用特型
    11.1.1 特型目标
    11.1.2 特型目标布局
    11.1.3 泛型函数
    11.1.4 使用哪一个
  11.2 定义和实现特型
    11.2.1 默认方法
    11.2.2 特型与其他人的类型
    11.2.3 特型中的Self
    11.2.4 子特型
    11.2.5 静态方法
  11.3 完全限定方法调用
  11.4 定义类型关系的特型
    11.4.1 关联类型（或迭代器工作原理）
    11.4.2 泛型特型（或操作符重载的原理）
    11.4.3 伴型特型（或rand::random()工作原理）
  11.5 逆向工程绑定
  11.6 小结
第 12 章 操作符重载
  12.1 算术与位操作符
    12.1.1 一元操作符
    12.1.2 二元操作符
    12.1.3 复合赋值操作符
  12.2 相等测试
  12.3 顺序比较
  12.4 Index与IndexMut
  12.5 其他操作符
第 13 章 实用特型
  13.1 Drop
  13.2 Sized
  13.3 Clone
  13.4 Copy
  13.5 Deref与DerefMut
  13.6 Default
  13.7 AsRef与AsMut
  13.8 Borrow与BorrowMut
  13.9 From与Into
  13.10 ToOwned
  13.11 Borrow与ToOwned实例：谦逊的奶牛（Cow）
第 14 章 闭包
  14.1 捕获变量
    14.1.1 借用值的闭包
    14.1.2 盗用值的闭包
  14.2 函数与闭包类型
  14.3 闭包的性能
  14.4 闭包和安全
    14.4.1 杀值的闭包
  14.4.2 FnOnce
    14.4.3 FnMut
  14.5 回调
  14.6 有效使用闭包
第 15 章 迭代器
  15.1 Iterator和IntoIterator特型
  15.2 创建迭代器
    15.2.1 iter和iter_mut方法
    15.2.2 IntoIterator实现
    15.2.3 drain方法
    15.2.4 其他迭代器源
  15.3 迭代器适配器
    15.3.1 map和filter
    15.3.2 filter_map和flat_map
    15.3.3 scan
    15.3.4 take和take_while
    15.3.5 skip和skip_while
    15.3.6 peekable
    15.3.7 fuse
    15.3.8 可逆迭代器与rev
    15.3.9 inspect
    15.3.10 chain
    15.3.11 enumerate
    15.3.12 zip
    15.3.13 by_ref
    15.3.14 cloned
    15.3.15 cycle
  15.4 消费迭代器
    15.4.1 简单累计：count、sum和product
    15.4.2 max和min
    15.4.3 max_by和min_by
    15.4.4 max_by_key和min_by_key
    15.4.5 比较项序列
    15.4.6 any和all
    15.4.7 position、rposition和ExactSizeIterator
    15.4.8 fold
    15.4.9 nth
    15.4.10 last
    15.4.11 find
    15.4.12 构建集合：collect和FromIterator
    15.4.13 Extend特型
    15.4.14 partition
  15.5 实现自己的迭代器
第 16 章 集合
  16.1 概述
  16.2 Vec<T>
    16.2.1 访问元素
    16.2.2 迭代
    16.2.3 增长和收缩向量
    16.2.4 连接
    16.2.5 拆分
    16.2.6 交换
    16.2.7 排序和搜索
    16.2.8 比较切片
    16.2.9 随机元素
    16.2.10 Rust排除无效错误
  16.3 VecDeque<T>
  16.4 LinkedList<T>
  16.5 BinaryHeap<T>
  16.6 HashMap<K, V>和BTreeMap<K, V>
    16.6.1 条目
    16.6.2 映射迭代
  16.7 HashSet<T>和BTreeSet<T>
    16.7.1 集迭代
    16.7.2 相等的值不相同
    16.7.3 整集操作
  16.8 散列
    使用自定义散列算法
  16.9 标准集合之外
第 17 章 字符串与文本
  17.1 Unicode背景知识
    17.1.1 ASCII、Latin-1和Unicode
    17.1.2 UTF-8
    17.1.3 文本方向性
  17.2 字符（char）
    17.2.1 字符分类
    17.2.2 处理数字
    17.2.3 字符大小写转换
    17.2.4 与整数相互转换
  17.3 String与str
    17.3.1 创建字符串值
    17.3.2 简单检查
    17.3.3 追加和插入文本
    17.3.4 删除文本
    17.3.5 搜索与迭代的约定
    17.3.6 搜索文本的模式
    17.3.7 搜索与替换
    17.3.8 迭代文本
    17.3.9 修剪
    17.3.10 字符串大小写转换
    17.3.11 从字符串解析出其他类型
    17.3.12 将其他类型转换为字符串
    17.3.13 作为其他类文本类型借用
    17.3.14 访问UTF-8格式的文本
    17.3.15 从UTF-8数据产生文本
    17.3.16 阻止分配
    17.3.17 字符串作为泛型集合
  17.4 格式化值
    17.4.1 格式化文本值
    17.4.2 格式化数值
    17.4.3 格式化其他类型
    17.4.4 为调试格式化值
    17.4.5 为调试格式化指针
    17.4.6 通过索引或名字引用参数
    17.4.7 动态宽度与精度
    17.4.8 格式化自定义类型
    17.4.9 在你的代码中使用格式化语言
  17.5 正则表达式
    17.5.1 基本用法
    17.5.2 懒构建Regex值
  17.6 规范化
    17.6.1 规范化形式
    17.6.2 unicode-normalization包
第 18 章 输入和输出
  18.1 读取器和写入器
    18.1.1 读取器
    18.1.2 缓冲读取器
    18.1.3 读取文本行
    18.1.4 收集行
    18.1.5 写入器
    18.1.6 文件
    18.1.7 搜寻
    18.1.8 其他读取器和写入器类型
    18.1.9 二进制数据、压缩与序列化
  18.2 文件与目录
    18.2.1 OsStr和Path
    18.2.2 Path和PathBuf的方法
    18.2.3 文件系统访问函数
    18.2.4 读取目录
    18.2.5 平台特定的特性
  18.3 网络编程
第 19 章 并发
  19.1 并行分叉–合并
    19.1.1 产生及合并
    19.1.2 跨线程错误处理
    19.1.3 跨线程共享不可修改数据
    19.1.4 Rayon
    19.1.5 重温曼德布洛特集合
  19.2 通道
    19.2.1 发送值
    19.2.2 接收值
    19.2.3 运行管道
    19.2.4 通道特性与性能
    19.2.5 线程安全：Send与Sync
    19.2.6 将所有迭代器都接到通道上
    19.2.7 超越管道
  19.3 共享可修改状态
    19.3.1 什么是互斥量
    19.3.2 Mutex<T>
    19.3.3 mut与Mutex
    19.3.4 互斥量的问题
    19.3.5 死锁
    19.3.6 中毒的互斥量
    19.3.7 使用互斥量的多消费者通道
    19.3.8 读/写锁（RwLock<T>）
    19.3.9 条件变量（Condvar）
    19.3.10 原子类型
    19.3.11 全局变量
  19.4 习惯编写Rust并发代码
第 20 章 宏
  20.1 宏基础
    20.1.1 宏扩展基础
    20.1.2 意外结果
    20.1.3 重复
  20.2 内置宏
  20.3 调试宏
  20.4 json!宏
    20.4.1 片段类型
    20.4.2 在宏里使用递归
    20.4.3 在宏里使用特型
    20.4.4 作用域与自净宏
    20.4.5 导入和导出宏
  20.5 匹配时避免语法错误
  20.6 超越macro_rules!
第 21 章 不安全代码
  21.1 不安全源自哪里
  21.2 不安全的块
    示例：高效ASCII字符串类型
  21.3 不安全的函数
  21.4 不安全的块还是不安全的函数
  21.5 未定义行为
  21.6 不安全的特型
  21.7 原始指针
    21.7.1 安全解引用原始指针
    21.7.2 示例：RefWithFlag
    21.7.3 可空指针
    21.7.4 类型大小与对齐
    21.7.5 指针算术
    21.7.6 移入和移出内存
    21.7.7 示例：GapBuffer
    21.7.8 不安全代码中的诧异安全性
  21.8 外来函数：在Rust中调用C和C++
    21.8.1 查找共有数据表示
    21.8.2 声明外来函数和变量
    21.8.3 使用库函数
    21.8.4 libgit2的原始接口
    21.8.5 libgit2的安全接口
  21.9 小结