> 主要参考：
>
> - [Crafting Interpreters 中文版](https://readonly.link/books/https://raw.githubusercontent.com/GuoYaxiang/craftinginterpreters_zh/main/book.json?front-matter=contents)

# 2 领土地图

## 2.1 语言的各个部分

### 2.1.1 扫描

第一步**扫描**（Scanning），即**词法分析**（Lexing，Lexical analysis）。

扫描器（词法分析器）接收线性字符流，切分成由类似单词形式组成的**词法单元**（Token）。如符号（`(`、`,`）、数字（`0`、`123`）、字符串（`"haha"`）、标识符（`foo`）。

![字符流](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202404202359178.png)

源文件中的一些字符没有任何意义，如空格、注释等。扫描器会丢弃这些字符，只留下由意义的词法单元序列。

![词法单元序列](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202404202359809.png)

### 2.1.2 语法分析

然后是**语法分析**（Parsing），解析器（Parser）将由词法分析得到的词法单元序列转化为树形结构，也叫**解析树**（Parse tree）或**抽象语法树**（Abstract syntax tree，AST），该结构能够反映语法的嵌套关系。此外，解析器还会分析词法单元序列中的语法错误。

![AST](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202404202359566.png)

### 2.1.3 静态分析

在前两个阶段中，可以获知语法结构及之间的关系，但也仅限于此。如 `a + b` 这样的表达式，通过语法分析，仅能知道 `a` 和 `b` 需要相加，但是 `a` 和 `b` 这些标识符到底指代什么，是局部还是全局变量？在哪里被定义？是否能够相加？这些都是不清楚的。

许多语言会做**绑定**（Binding）或**决议**（Resolution）——对于每一个标识符，都需要找出定义该名称的位置，并将两者连接起来。这就是作用域的作用——在源代码的某个区域中，某个名字可以用来引用某个声明。

若语言是静态类型的，在进行绑定时，还可以借此机会进行类型检查，知道了标识符的定义位置，那么也可以知道其类型，若该类型不支持相加操作，则报类型错误。

在上面的分析中，所有的语义信息都会存储在某个地方：

- 存储在 AST 本身的属性中，属性是树中节点的额外字段，这些字段在解析时不会初始化，而是在之后进行填充；
- 存储在外部的查找表中，通常该表的关键字是标识符，也称为**符号表**，实际上就是一系列键值对，其值表示该标识符所指；
- 将树转化为全新的数据结构并存储在其中，这更能表达代码的语义。

### 2.1.4 中间代码

词法分析、语法分析、静态分析这些都称为实现的**前端**，还有中端和后端。

编译器实际上就是一条流水线，每个阶段的工作就是将上一阶段的结果进行加工，使下一阶段的实现更简单。前端部分主要针对源代码字符串的文本处理，后端关注的则是程序最终运行的部分。

在处理过程中，代码结果可能被存储在**中间代码**（Intermediate representation，IR）中，这些中间代码与源文件或最终运行部分没有紧密联系，而是作为一种中间层，充当两种语言之间接口，并可以支持多种目标平台。

若编译器要支持多种语言及目标平台，需要分别为这些组合实现，而现在只需要为每种语言实现一个前端统一转化为 IR，再为每个平台写一个后端，就可以将 IR 转为为各个目标平台的程序。

### 2.1.5 优化

源文件经由前端语义分析转化为 IR，而可能还存在语义相同但是生成的 IR 更加高效的情况。**优化**（Optimization）则是对具有相同语义但实现更高效的程序来进行替换。

如常量折叠，若某个表达式求值得到的始终是完全相同的值，则可以在编译时进行求值，而非在运行时进行计算，并用其结果替换该表达式的代码。

```javascript
a = 10 + 20 + 30 / 2

// 替换为
a = 45
```

更进一步，对更为复杂的表达式也同样可以进行优化：

```javascript
sum = 0;
for (i = 1; i <= 100; i++) {
    sum += i
}

// 替换为
sum = 5050
```

这种编译期优化可以极大的提高运行时的性能，但实际要找到一个具有更高效率且具有相同语义的过程是十分困难的。如 Lua、Python 这种解释型语言不会生成特别优化后的字节码。

### 2.1.6 代码生成

从源文件开始，对源代码进行向上的抽象处理，最后又向下接近机器可以理解的形式进一步处理。这就是前端和后端的处理过程。在最终的**代码生成**（Code generation）阶段，实际上这也是编译型语言和解释型语言的分水岭。

当为真实的 CPU 生成指令，那么会得到某个特定 CPU 平台的可执行文件，然后操作系统可以加载该程序然后直接运行。这意味着编译器与特定架构绑定，为 x86 生成的程序无法在 ARM 上运行。

而为虚拟的 CPU 生成指令，这实际上就是为虚拟机生成指令，也叫做**字节码**（Bytecode）或 P-Code。这种指令是可移植的，只要目标平台上安装了对应的虚拟机就可以执行。

### 2.1.7 虚拟机

编译器虽然生成了字节码，但没有真实的 CPU 可以解析执行这些字节码，因此还需要进一步的翻译。可以为每个目标平台编写一个小型编译器，并将这些字节码转化为目标平台可执行的指令。这仍然需要为每个所支持的平台做单独的适配，这时候字节码实际上就相当于一种 IR。

或者可以由**虚拟机**（Virtual machine，VM）去执行这些字节码。VM 可在运行时模拟支持虚拟架构的虚拟 CPU，VM 会最终将这些字节码转化为目标指令去执行。由于每条指令执行时都必须在运行时模拟，因此在 VM 中运行字节码比提前将其编译成目标代码要慢，但这种实现更简洁，可移植性更好。

### 2.1.8 运行时

最后一步则是运行该程序，若编译成机器码，则只需要告诉操作系统加载该程序运行即可。若编译成字节码，则需要启动 VM 并将程序加载到其中，由 VM 来运行。

在这两种情况下，除了最基本的底层语言外，通常语言还会在程序运行时提供一些服务。如语言支持自动管理内存，则需要一个 GC；如需要运行时反射，就需要动态跟踪执行过程中每个对象的类型；如需要运行时进行类型检查，如下标越界、整数溢出检查，就需要在每个这种操作前插入检查代码；如需要支持异常处理也是同理。

这些服务都是在运行时进行的，所以被称为**运行时**（Runtime）。在编译型语言中，如 Go 运行时的代码会直接插入到生成的可执行文件中。在解释执行或在 VM 内运行的语言中，如 Python、JavaScript，运行时将驻留于 VM 中。

## 2.2 捷径和备选路线

### 2.2.1 单遍编译器

一些简单的编译器将词法分析、语法分析和代码生成交织在一起，这样就可以直接在解析器中生成输出代码，而无需分配任何语法树或 IR。这些**单遍编译器**（Single-pass compilers）实现限制了语言的设计。没有中间数据结构来存储程序的全局信息，也不会重新访问任何之前被解析过代码的部分。这意味着一旦看到某个表达式，就需要足够的信息来正确地对其进行编译。

Pascal 和 C 就是围绕这个限制而设计的。在早期内存很小，一个编译器可能连整个源文件都无法存放在内存中，更别说整个程序了。这也是为什么 Pascal 要求类型声明要先出现在一个块中，在 C 中不能在定义函数之前调用函数，除非有一个明确的前向声明，以让编译器生成调用后面函数的代码。

### 2.2.2 树遍历解释器

有些语言在将代码解析为 AST 后就开始执行代码（可能应用了一点静态分析）。为了运行程序，解释器每次都会遍历语法树的一个分支和叶子节点，并在运行过程中计算每个节点。

这种**树遍历解释器**（Tree-walk interpreters）实现在小型语言中很常见，但在通用语言中并不常见，因为执行效率很低，不过早期的 MRI Ruby 就是用的这种实现。

### 2.2.3 转译器

为语言编写一个完整后端的工作量是巨大的。若已有通用的 IR，如 LLVM IR，那么可以用前端将代码转换到该 IR 上，然后使用该 IR 的后端将代码转化成可执行代码。

IR 不一定非得是某种特定的中间代码，还可以是其它语言的源代码。前端处理完后，后端生成一份与自己语言级别差不多的其它语言的有效源代码，而不是将所有代码降低到原始目标语言的语义。

这种方式称为**源到源编译器**、**转换编译器**或**转译器**（Transpilers）。以 C 为编译目标，可以运行在各个体系架构上；以 JavaScript（WebAssembly） 为目标，可以运行在浏览器上。转译器的前端（扫描器和解析器）和一般的编译器前端是类似的。若源语言只是在目标语言在语法方面的换皮版本，则可能会完全跳过分析，并直接输出目标语言中的类似语法。若两种语言的语义差异较大，则会包含编译器的更多典型阶段，甚至包括优化。

### 2.2.4 即时编译

执行代码最快的方法是将代码编译成目标机器代码，但不是什么时候都知道最终用户的机器支持什么架构的。像 JVM、CLR 和 JavaScript 解释器，在终端用户的机器上，当程序加载时（无论是源代码还是字节码），都可以将其编译为对应的本地代码，以适应本机支持的体系结构，这被称为**即时编译**（Just-in-time compilation，JIT）。

复杂的 JIT 将性能分析 Hook 插入到生成的代码中，以检测哪部分对性能更为敏感，并且会随着运行时间的变化动态优化并重新编译热点代码。

## 2.3 编译器和解释器

**编译**是一种实现技术，将源语言翻译成其它语言——通常是指较低级的形式，但无论是生成字节码、机器码还是另一种语言，都叫做编译。**编译器**（Compiler）是一种将源代码转化为其它形式的程序，只将结果输出，但不进行实际的执行，而**解释器**（Interpreter）除了接受源代码，还会执行。

如 GCC 和 Clang 就是接受 C 代码然后编译为机器码，最终用户可以执行生成的文件。而早期的 MRI Ruby 会在遍历语法树时就解析执行，期间没有其它转换。CPython 会将源代码解析转换为字节码，然后在 VM 中执行，所以这两种都可以看做解释器，虽然 CPython 在内部也做了一些编译的工作。实际上在很多语言中，这两种是同时存在的。

![编译器和解释器](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202404202358866.png)

# 3 Lox 语言

## 3.1 Hello, Lox

Lox 有着类似 C 的语法。

```javascript
// comment
/* comment */
print "hello world!"
print "hello " + "world!"
```

> `print` 不是函数，而是内置语句。

## 3.2 高级语言

### 3.2.1 动态类型

Lox 是动态类型的，变量可以存储任何值，同一个变量可以在不同时刻存储不同类型的值。若对类型进行错误的操作（如数字除以字符串），则运行时报错。不使用静态类型（Static typing）的原因是动态类型（Dynamic typing）实现起来更加简单。

### 3.2.2 自动内存管理

手动管理内存是繁琐且容易出错的，因此使用**自动内存管理**（Automatic memory management）。

存在两种内存管理技术：

- 引用计数（Reference counting）
- 垃圾收集（Garbage collection）

## 3.3 数据类型

在 Lox 中，有以下几种基本类型：

- Boolean：仅有 `true` 和 `false` 两种值；
- Number：仅有双精度浮点数，如 `1.23`、`10`；
- String：使用双引号包裹的字符串，如 `""`、`"foo"`；
- Nil：代表没有值，使用 `nil` 表示。

## 3.4 表达式

内置的基本类型是原子，那么表达式（Expression）就是分子。

### 3.4.1 算术运算

Lox 具备基本算术运算功能：

```javascript
a + b
a - b
a * b
a / b
```

操作符两边的子表达式都是**操作数**，有两个操作数的运算符称为**二元运算符**。操作符在中间，也称为**中缀操作符**。

正负号 `+` / `-` 是一元运算符同时也是**前缀操作符**，但表达加减法时又是中缀运算符。所有操作符都是针对数字的，除了可以使用 `+` 来将两个字符串连接起来，其它类型使用是错误的。

### 3.4.2 比较与相等

Lox 支持返回一个布尔值的比较运算（只支持数字）：

```javascript
a > b
a >= b
a < b
a <= b
```

以及比较任意类型值之间是否相等，操作数可以是不同的类型：

```javascript
1 == 2
"a" != "b"
1 == "a"
```

### 3.4.3 逻辑运算

Lox 支持逻辑运算：

```javascript
!true
true and false
true or false
```

>   `and` 和 `or` 进行的是短路运算。

### 3.4.4 优先级与分组

Lox 的操作符都与 C 有着相同优先级，同时还可以使用 `()` 来分组。

```javascript
var avg = (min + max) / 2
```

## 3.5 语句

表达式的主要作用是产生一个**值**，语句（Statement）的主要作用是产生一个副作用。如修改某些状态、读取输入或产生输出等。

如 `print` 就是一个语句：

```javascript
print "hello";
```

在表达式后跟 `;` 就可以将表达式提升为语句，称为**表达式语句**。

要将一系列语句打包成一个语句，可以放在一个**块**中，同时块还会影响作用域：

```javascript
{
    print "hello";
    print "world";
}
```

## 3.6 变量

使用 `var` 声明变量，如果没有初始化，则默认为 `nil`：

```javascript
var init_var = 123;
var uninit_var; // nil
```

一旦声明完成，则可以通过变量名对其进行访问：

```javascript
var a = 1;
print a;
```

## 3.7 控制流

Lox 从 C 中借鉴了几种控制流语句：

```javascript
if (cond) {
    print true;
} else {
    print false;
}

while (i < 10) {
    print i;
    i = i + 1;
}

for (var a = 1; a < 10; a = a + 1) {
    print a;
}
```

## 3.7 函数

Lox 的函数调用与 C 相同：

```javascript
hello();
foo(a, b, c);
```

调用函数必须使用括号，否则就仅仅是指向该函数。

Lox 中通过 `fun` 定义函数：

```javascript
fun add(a, b) {
    print a + b;
}
```

函数体总是一个块，可以使用 `return` 返回一个值：

```javascript
fun add(a, b) {
    return a + b;
}
```

若结尾没有 `return`，则隐式返回 `nil`。

### 3.8.1 闭包

在 Lox 中，函数是一等公民，这代表函数也是一种类型，具有值，可以将其存储在变量中，对其传递、引用等。

```javascript
fun add(a, b) {
    return a + b;
}

fun ret_fun(f) {
    return f
}

ret_fun(add)(1, 2);
```

函数声明是语句，因此可以在另一个函数中声明局部函数：

```javascript
fun f1() {
    fun f2() {
        print "nest fun";
    }

    f2();
}
```

将局部函数、头等函数、块作用域组合在一起：

```javascript
fun ret_fun() {
    var value = 123;

    fun inner() {
        print value;
    }

    return inner;
}

var f = ret_fun();
f();
```

`inner` 函数访问了其外部的局部变量，这代表即使外层函数返回后，`inner` 也保存着这些变量的引用，这些变量依然存在。能做到这一点的函数称为**闭包**。

## 3.9 类

Lox 具有动态类型，词法（块）作用域和闭包，所以与函数式和面向对象都比较接近。

### 3.9.3 类还是原型

涉及对象时，有两种方法：**类**（Class）和**原型**（Prototype）。在基于类的语言中，有两个核心概念：类和实例。

类包含方法和继承链，是创建实例的模板，实例存储每个对象的状态。要在实例上调用方法，总是需要通过一个中间层查到到实例的类，然后在其中查找方法。

![img](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202404211624224.png)

基于原型的语言融合了这两个概念——只有对象没有类。每个对象都可以包含状态和方法，对象之间可以继承。

![img](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202404211626815.png)

### 3.9.4 Lox 中的类

在 Lox 中，类也是一等公民，可以这样声明一个类及其方法：

```javascript
class Foo {
    f1() {
        print "f1"
    }

    f2(name) {
        print "hello, " + name;
    }
}
```

类的主体包含方法，看起来像没有 `fun` 的函数声明。类声明生效时， Lox 将创建一个类对象，并存储在与类名相同的变量中。

为了简单起见，Lox 不使用 `new` 创建类实例，而是把类本身当作一个工厂函数，调用一个类就可以生成一个实例：

```javascript
var foo = Foo();
print foo;
```

### 3.9.5 实例化和初始化

类除了包含方法，还会包含状态，因此还需要字段。Lox 允许动态地向对象添加属性。

```javascript
foo.a = 1;
foo.b = "hello";
```

若字段不存在，进行赋值时就会先创建。

在方法内部访问对象上的字段或方法，使用 `this`：

```javascript
class Foo {
    hello() {
        print "hello, " + this.name;
    }
}
```

在对象中封装数据的目的之一是确保对象在创建时处于有效状态。可以定义一个初始化器，若类中包含一个 `init` 方法，则在构造对象时会自动调用该方法：

```javascript
class User {
    init(name, age) {
        this.name = name;
        this.age = age;
    }

    hello() {
        print "hello, " + this.name;
    }
}

var user = User("Alice", 18);
user.hello();
```

### 3.9.6 继承

在面向对象的语言中，不仅可以定义方法，而且可以在多个类或对象中重用。Lox 支持使用 `<` 进行单继承：

```javascript
class VipUser < User {
    vip() {
        print "VIP User";
    }
}
```

`VipUser` 是 `User` 的子类或派生类，而 `User` 是基类、父类或超类。子类可以使用父类中的方法，即使是 `init` 方法也会被继承。子类通常也会定义自己的 `init` 方法，但还需要调用父类的初始化方法，以便父类能够维护其状态。这通过 `super` 来实现：

```javascript
class VipUser < User {
    init(name, age, lv) {
        super.init(name, age);
        this.lv = lv;
    }
}
```

Lox 不是一个纯粹的面向对象语言，在真正的 OOP 语言中，每一个对象都是一个类的实例，包括数字、布尔值这样的基本类型。

## 3.10 标准库

除了语言本身的定义外，剩下的就是用于在解释器中实现的功能集合，称为**标准库**（Standard library）。在 Lox 中，`print` 属于内置语句而不是标准库的一部分。一个实际可用的语言，其标准库通常包含了徐多功能，如字符串库、数学库、I/O 库、网络库等。

## 设计笔记: 表达式和语句

Lox 既有表达式也有语句，而有些语言省略了语句，并将声明和控制流也视为表达式。这类语言往往具有函数式的血统，如 Lisp、Haskell、Ruby 等。

对于语言中的每个类似于语句的构造，需要决定其计算的值是什么：

- `if` 表达式的计算结果是所选分支的结果。同理，`switch` 或其它多路分支的计算结果取决于所选择的情况；
- 变量声明的计算结果是变量的值；
- 块的计算结果是块中最后一个表达式的值。

而有些是比较复杂的，如循环应该如何计算？同时还必须决定这些类似语句的表达式如何与其它表达式组合，如 Ruby 允许这种写法：

```ruby
puts 1 + if true then 2 else 3 end + 4
```

取消了语句的语言通常还具有**隐式返回**的特点——函数自动返回其函数主体最后一个表达式的值，而不需要显式的 `return`。
