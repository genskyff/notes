# 11 解析和绑定

## 11.1 静态作用域

Lox 对变量和代码块的作用域的控制符合预期，但当添加闭包后，就出现了问题。考虑下面的代码：

```
fn f() {
  print a;
}

var a = 1;
f();
a = 2;
f();
```

函数 `f` 捕获了外部变量 `a`，而这个 `a` 甚至是在函数声明之后定义的。抛开这一点来说，由于是静态作用域，因此后续两次调用 `f` 得到的结果应该是一样的，但实际却不一样。

在讨论上述问题前，先更明确的定义作用域规则：**变量指向的是使用变量的外层环境中，前面具有相同名称的最内层作用域中的变量声明**。

这个规则明确了两点：

-   变量使用必须在变量声明之后
-   由于变量遮蔽的存在，当多个同名变量存在时，使用最内层的变量

由于该规则没有提及任何运行时行为，所以都能都在解析阶段确定，因此一个变量表达式在程序的整个生命周期中都指向同一个声明。但闭包就不符合这一点，这将通过语义分析来解决。

### 11.1.1 作用域和可变环境

在目前 Lox 的解释器中，环境是静态作用域的动态表现，这两者大多数情况下是同步的。当进入一个新的作用域时，如一个块，会创建一个新的环境，当离开块时，该环境会被丢弃。在环境中还可以绑定一个变量，这就是导致问题的原因。

考虑下面的代码：

```
var a = "global";
{
  fn showA() {
    print a;
  }

  showA();
  var a = "block";
  showA();
}
```

当在程序顶层声明一个变量时，会在全局环境 `global` 中添加一个变量。

![Env 1](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250511222208192.png)

然后进入代码块，此时有一个新的块环境 `block`，在其中有一个函数声明，该函数定义在 `block` 环境中，因此闭包会链接到 `block`。

![Env 2](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250511222338338.png)

当调用 `showA` 时，解释器为每个 `call` 表达式都动态地创建一个新环境，这主要是为了把传递的参数以及函数内部声明的变量都放到该环境中，在本例中没有参数以及变量声明，因此是空的。

![Env 3](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250511222921749.png)

在执行 `showA` 的函数体时，由于用到了 `a`，因此解释器通过环境链接遍历查找该变量，直到达到 `global` 环境。这里第一个 `a` 在 `global` 中，第二个 `a` 在 `block` 中。

![Env 4](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250511223348508.png)

这里第二个 `a` 和 `showA` 在同一个环境中，也就是闭包所指向的环境，当再次调用时，解释器创建一个新环境，并查找 `a`，但这时由于在 `block` 中已经有 `a` 了，因此不会再去查找 `global` 中的 `a`，这将导致两次运行结果不同。

![Env 5](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250511223632168.png)

目前的解释器实现方式认为同一个块中所有代码都在同一个作用域中，然后用一个环境来表示这个作用域。而这个环境本质上一个哈希表，通过键来查找值，并随着新的声明，该环境会被动态地改变，即一个环境是**可变的**（Mutable）。

考虑下面代码：

```
{
  var a = 1;
  var b = 2;
}
```

这里 `a` 和 `b` 虽然都在同一个作用域中，但是实则不然。当 `a` 声明时，对它而言此时的环境中只有一个 `a`，而对 `b` 而言，此时的环境有 `a`、`b` 两个变量。从这个角度看，很明显 `a` 和 `b` 的环境是不一样的，即作用域不同。

这似乎有点反直觉，在目前的实现中，一个块就是一个作用域，且该作用域会随着执行而变化。当函数被声明时，会捕获当前环境的作为闭包，但该环境是可变的，因此闭包也就变得可变了。而闭包应该捕获函数声明时的环境快照，且不会随着时间而改变。

### 11.1.2 持久环境

在函数式编程中，通常使用所谓的**持久性数据结构**（Persistent data structure），也叫做**不可变数据结构**（Immutable data structure）。所有的数据都是不可变的，不能直接修改数据本身，而是通过创建一个新的数据结构来包含想要修改的数据。

若将该思想用于环境，那么每次声明一个变量时，都会返回一个新的环境，其中包含之前的所有变量和此次的新变量，声明会隐式地分割环境。

![Env 6](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250511225243192.png)

当声明函数时，闭包得到的是现在的环境，后续就算有新的声明都会产生新的 `env` 对象，因此闭包就不会收到影响，上述代码的问题将会得到解决。

这是解决该问题的典型方式，但这意味着现有代码需要大幅修改。为了尽量不修改现有代码，通过引入静态解析中间层，然后将该中间层插入到访问操作中，这样就不需要将现有数据结构静态化。

### 11.2 语义分析

目前 Lox 的解析器每次对变量求值时，都会解析变量，即找到所指向的声明。这会造成一个问题，当该变量被重复使用时，特别是在一个循环中，那么会被重复解析。

由于静态作用域的性质，同一个变量一定会解析到同一个声明，因此可以直接通过查看文本来确定，动态的解析是没有必要的，这会造成性能下降。

一个更好的方法时一次性解析每个变量的使用，找到每个变量引用的是哪个声明，这其实就是**语义分析**（Semantic analysis）。解析器只能分析程序在语法上是否正确，但无法得知语义是否正确。

在目前的变量解析中，会检查链上的环境，逐级查找直到 `global` 环境，当又遇到相同的变量时，会再次执行该查找过程。若在第二次解析前，在内部作用域添加了同名变量，则会直接在内部环境找到，而不是到 `global` 上去找。

可以认为，第一次查找经历了 2 次链接，第二次查找只经历了 1 次链接。若能够保证变量查找总在环境链上遍历相同数量的链接，则也可以保证每次都在相同作用域中找到相同的变量。要解析一个变量使用，只需要计算声明的变量在环境链上有几次链接。

由于是根据词法作用域来计算一个静态属性，因此可以在解析器中实现。

### 11.2.1 变量解析过程

在解析器生成语法树后，解释器执行语法树之前，可以再对语法树进行一次遍历，以解析其中的变量以及发现一些额外错误。在一个静态类型语言中，这个阶段还会进行类型检查。而优化则是在语义分析后再遍历重新生成一遍优化后的语法树。

变量解析会遍历语法树，访问每个节点，这其实和解释器的执行是类似的。但不同的是，由于是静态解析，不会执行任何东西，因此是没有副作用的。且没有控制流，循环只会被处理一次，分支语句的所有分支都会被处理，逻辑运算的短路逻辑也不会生效，这能确保每个语法树节点都被访问一次。

## 11.3 Resolver 类

变量解析实际上是一个访问者类，添加 `Resolver` 类：

```ruby
class Lox::Visitor::Resolver < Lox::Visitor::Base
  def initialize(interp)
    @interp = interp
  end
end
```

解析器访问并处理每个节点，其中的部分需要做特殊处理，因为：

-   块语句为包含的语句引入了新作用域
-   函数声明为函数体引入了新作用域，并在该作用域中绑定了形参
-   变量声明将新变量追加到作用域
-   变量定义和赋值需要解析变量值

而其它节点则不用额外处理，当然也可以做更多的检查，如检查 `break` 或 `return` 的位置是否正确，因为只能在相关上下文中使用，但这里也实现相关的访问者方法。

### 11.3.1 解析代码块

先从代码块开始，因为它创建一个新作用域，而函数体本质上也是一个块。

```ruby
class Lox::Visitor::Resolver < Lox::Visitor::Base
  def visit_block_stmt(block_stmt)
    begin_scope
    resolve(*block_stmt.body)
    end_scope
    nil
  end
end
```

首先开始一个新作用域，并在其中遍历块中的语句，并结束作用域。

`resolve` 方法定义为：

```ruby
class Lox::Visitor::Resolver < Lox::Visitor::Base
  private

  def resolve(*ast_nodes)
    ast_nodes.each { it.accept(self) }
    nil
  end
end
```

其接受 AST 节点数组，然后遍历处理，这其实和解释器的 `evaluate` 方法是类似的。

`begin_scope` 方法定义为：

```ruby
class Lox::Visitor::Resolver < Lox::Visitor::Base
  def initialize(interp)
    @interp = interp
    @scope = []
  end

  private

  def begin_scope
    @scope << {}
  end
end
```

在解释器中，词法作用域是通过环境链接来实现的，本质上是用链表来模拟一个栈。当一个新作用域开启时，则创建一个环境，并链接到上一个环境，其实就是把新环境 `push` 到上一个环境，当在一个作用域中创建声明时，则是把一个键值对加入到所处环境的末尾，这也是一种 `push` 操作。在解析器中，则使用真正的栈来进行。

首先创建了一个实例变量 `@scope` 用来存放环境，而每个环境又是一个哈希表。当开始一个新作用域时，就将一个新的哈希表放入末尾，当创建一个新声明时，就把该声明放入哈希表末尾。

作用域栈只能用于局部作用域，解析器不会跟踪在顶层作用域的全局声明。当解析一个变量但局部作用域栈中找不到时，就认为一定是全局的。

由于作用域在一个栈中，当作用域结束时，需要销毁掉环境，这实际上就是一个 `pop` 操作，因此 `end_scope` 方法定义为：

```ruby
class Lox::Visitor::Resolver < Lox::Visitor::Base
  private

  def end_scope
    @scope.pop
  end
end
```

现在就实现了在栈中压入和弹出空作用域。

### 11.3.2 解析变量声明

