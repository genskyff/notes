# 11 解析和绑定

## 11.1 静态作用域

Lox 对变量和代码块的作用域的控制符合预期，但当添加闭包后，就出现了问题。考虑下面的代码：

```
fun f() {
  print a;
}

var a = 1;
f();
a = 2;
f();
```

函数 `f` 捕获了外部变量 `a`，而这个 `a` 甚至是在函数声明之后定义的。抛开这一点来说，由于是静态作用域，因此后续两次调用 `f` 得到的结果应该是一样的，但实际却不一样。

在讨论上述问题前，先更明确的定义作用域规则：**变量指向的是使用变量的外层环境中，前面具有相同名称的最内层作用域中的变量声明**。

这个规则明确了两点：

-   变量使用必须在变量声明之后
-   由于变量遮蔽的存在，当多个同名变量存在时，使用最内层的变量

由于该规则没有提及任何运行时行为，所有都能都在解析阶段确定，因此一个变量表达式在程序的整个生命周期中都指向同一个声明。但闭包就不符合这一点，这将通过语义分析来解决。

### 11.1.1 作用域和可变环境

在目前 Lox 的解释器中，环境是静态作用域的动态表现，这两者大多数情况下是同步的。当进入一个新的作用域时，如一个块，会创建一个新的环境，当离开块时，该环境会被丢弃。在环境中还可以绑定一个变量，这就是导致问题的原因。

考虑下面的代码：

```
var a = "global";
{
  fun showA() {
    print a;
  }

  showA();
  var a = "block";
  showA();
}
```

当在程序顶层声明一个变量时，会在全局环境 `global` 中添加一个变量。

![Env 1](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250511222208192.png)

然后进入代码块，此时有一个新的块环境 `block`，在其中有一个函数声明，该函数定义在 `block` 环境中，因此闭包会链接到 `block`。

![Env 2](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250511222338338.png)

当调用 `showA` 时，解释器为每个 `call` 表达式都动态地创建一个新环境，这主要是为了把传递的参数以及函数内部声明的变量都放到该环境中，在本例中没有参数以及变量声明，因此是空的。

![Env 3](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250511222921749.png)

在执行 `showA` 的函数体时，由于用到了 `a`，因此解释器通过环境链接遍历查找该变量，直到达到 `global` 环境。这里第一个 `a` 在 `global` 中，第二个 `a` 在 `block` 中。

![Env 4](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250511223348508.png)

这里第二个 `a` 和 `showA` 在同一个环境中，也就是闭包所指向的环境，当再次调用时，解释器创建一个新环境，并查找 `a`，但这时由于在 `block` 中已经有 `a` 了，因此不会再去查找 `global` 中的 `a`，这将导致两次运行结果不同。

![Env 5](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250511223632168.png)

目前的解释器实现方式认为同一个块中所有代码都在同一个作用域中，然后用一个环境来表示这个作用域。而这个环境本质上一个哈希表，通过键来查找值，并随着新的声明，该环境会被动态地改变，即一个环境是**可变的**（Mutable）。

考虑下面代码：

```
{
  var a = 1;
  var b = 2;
}
```

这里 `a` 和 `b` 虽然都在同一个作用域中，但是实则不然。当 `a` 声明时，对它而言此时的环境中只有一个 `a`，而对 `b` 而言，此时的环境有 `a`、`b` 两个变量。从这个角度看，很明显 `a` 和 `b` 的环境是不一样的，即作用域不同。

这似乎有点反直觉，在目前的实现中，一个块就是一个作用域，且该作用域会随着执行而变化。当函数被声明时，会捕获当前环境的作为闭包，但该环境是可变的，因此闭包也就变得可变了。而闭包应该捕获函数声明时的环境快照，且不会随着时间而改变。

### 11.1.2 持久环境

在函数式编程中，通常使用所谓的**持久性数据结构**（Persistent data structure），也叫做**不可变数据结构**（Immutable data structure）。所有的数据都是不可变的，不能直接修改数据本身，而是通过创建一个新的数据结构来包含想要修改的数据。

若将该思想用于环境，那么每次声明一个变量时，都会返回一个新的环境，其中包含之前的所有变量和此次的新变量，声明会隐式地分割环境。

![Env 6](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250511225243192.png)

当声明函数时，闭包得到的是现在的环境，后续就算有新的声明都会产生新的 `env` 对象，因此闭包就不会收到影响，上述代码的问题将会得到解决。

这是解决该问题的典型方式，但这意味着现有代码需要大幅修改。通过引入静态解析中间层，然后将该中间层插入到访问操作中，这样就不需要将现有数据结构静态化。

### 11.2 语义分析

