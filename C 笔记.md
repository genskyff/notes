>   主要参考：
>
>   -   [《C Primer Plus》](https://book.douban.com/subject/26792521/)
>   -   [《C 陷阱与缺陷》](https://book.douban.com/subject/2778632/)
>   -   [《C 和指针》](https://book.douban.com/subject/3012360/)
>   -   [《深入理解计算机系统》](https://book.douban.com/subject/26912767/)

# 1 概述

## 语言标准

C 语言最初并没有官方标准，最早是其创始人所著的 [《C程序设计语言》](https://book.douban.com/subject/1139336/) 一书成为普遍接受的标准，被称为 **K&R C**。

ANSI 于 1989 年定义了 C 标准和标准库，称为 ANSI C。ISO 于 1990 年也采用了这个 C 标准，称为 ISO C，因此这两者是同一个标准，而 ANSI C / ISO C 标准的最终版本被称为 **C89 / C90**。

1999 年发布的修订后的 C 标准被称为 **C99**，目前绝大多数编译器都已支持 C99 标准，目前最新标准为 **C23**。

## 编译指令

```shell
# 编译成可执行文件
gcc <source> -o <output>

# 预处理
gcc -E <source> -o <output>

# 编译成汇编指令
gcc -S <source> -o <output>

# 编译成目标文件
gcc -c <source> -o <output>

# 链接生成可执行文件
gcc <source> -o <output>

# 保留中间文件
gcc -save-temps <output>
```

### 编译选项

 ```shell
 # 指定标准
 gcc -std=c23 <source> -o <output>
  
 # 指定架构
 gcc -m32 <source> -o <output>
  
 # 编译优化
 gcc -O2 <source> -o <output>
  
 # 开启所有警告
 gcc -Wall <source> -o <output>
  
 # 将警告视为错误
 gcc -Werror <source> -o <output>
 
 # 动态链接 libxxx.so
 gcc <source> -o <output> -lxxx
 
 # 静态链接 libxxx.a
 gcc -static <source> -o <output> -lxxx
 
 # 生成位置无关的代码
 gcc -c -fPIC <source>
 
 # 生成动态库
 gcc -shared <source> -o <output>
 ```

# 2 数据类型

## 数据类型

| **关键字** | **类型**             | **关键字**  | **类型**       |
| ---------- | -------------------- | ----------- | -------------- |
| void       | 空类型               | void*       | 指针类型       |
| signed     | 有符号型（默认）     | unsigned    | 无符号型       |
| char       | 字符型               | short       | 短整型         |
| int        | 整型（默认）         | long        | 长整型         |
| long long  | 长长整型             | ﬂoat        | 单精度浮点型   |
| double     | 双精度浮点型（默认） | long double | 长双精度浮点型 |
| _Bool      | 布尔类型             | _Complex    | 复数类型       |
| _Imaginary | 虚数类型             |             |                |

C 的数据类型只做以下保证：

-   整型字面量默认为 int，浮点型字面量默认为 double；

-   short 和 int 至少 16 位，long 至少 32 位，long long 至少 64 位，且 short ≤ int ≤ long ≤ long long。

通过前缀和后缀来表示不同的字面量。

```c
037, 0x71a3f                    // 八进制数，十六进制数
12345u, 9876L, 10000LL, 2223UL  // 无符号整数，长整数，长长整数，无符号长整数
123.123f, 100.00L               // 单精度浮点数，长双精度浮点数
-1.23e10                        // 指数表示法
.234, .07e-5, -.6               // 省略整数部分
0xc1.6dP8                       // 十六进制浮点数表示法
```

## 常量和宏

**宏**用于创建一个常量：

```c
#define PI 3.14
```

宏通常放在程序开头，这样在程序中就可以使用 PI 来替代 3.14 了，这样定义的常量被称为**符号常量**。

`const` 也可来定义常量：

```c
const double PI = 3.14;
```

使用宏和 `const` 定义的常量并不完全具有相同的性质。宏是替换机制，在预处理阶段处理，`const` 实际上定义的是一个只读变量，作用于编译期。

# 3 表达式和语句

## 表达式

表达式由运算符和操作数组成，**每个表达式都会产生一个值**。

```c
4
2 + 8
b = 10 / 2
c = 3 + 8
6 + (c = 2 - 1)
a + b / c
i > 3
```

表达式可以是常量和变量的组合。一些表达式由**子表达式**组成，如 `a + b / c` 中的子表达式为 `b = 10 / 2`。

## 语句

**语句会改变值或调用函数**。所有以 `;` 结尾的都是语句，一些语句不一 `;` 结尾，如控制语句，函数调用也是表达式，在表达式后加 `;` 就变成表达式语句。声明不是表达式也不是语句，因为没有产生之也没有改变值。

```c
3 + 4               // 表达式
3 + 4;              // 表达式语句
;                   // 空语句
x = 6 + (y = 5);    // 表达式语句
int n;              // 声明（非表达式、非表达式）
printf("OK!\n");    // 表达式语句
if(x > 2) {         // 控制语句
    i = i + 1;      // 表达式语句
}
```

## 数据对象、左值和右值

赋值语句的目的是把值存储到某个数据对象上，而数据对象（如变量）又代表存储区域的某个位置，所以赋值运算实际上是把值放到某个存储区域中，用于存储值的存储区域被称为**数据对象**。数据对象的名称或表达式被称为**左值**，左值并不一定能被修改，如使用 `const` 创建的变量。对赋值运算符而言，它的左值应该是可修改的。右值指能赋给可修改的左值的量，可以是常量、变量或可以**产生值**的表达式。


## 复合语句

有许多种语句，如赋值语句把值赋给一个变量，它改变了值；函数引起函数的执行，也改变了值。对于一个用大括号括起来的函数，如 `main` 函数，它包含了多个语句，称为**复合语句**，也叫做**代码块**。复合语句用一对大括号括起来以限定范围。结构化语句如 `if`，它也包含了一个代码块。

## 副作用和序列点

**副作用**表示对数据对象的修改。

```c
n = 1;  // 副作用是将 n 的值变为 1
```

**序列点**是程序执行的一个点，在该点处，所有的副作用都在进入下一步前被发生。语句的分号标识了一个序列点。任何一个完整表达式的结束也是一个序列点，完整表达式即其本身不是另一个更大的表达式的子表达式，如表达式语句和 `if` 中的条件表达式都为完整表达式。

分号标识了一个序列点，所以按照顺序执行。`if` 里的是一个完整表达式，也是一个序列点，所以在执行大括号中的语句之前，`i` 的值一定会加 1。

```c
a = b + c;
if (i++ > 10) {}
```

`printf` 函数后的分号是序列点，但是括号内的参数并没有被标记序列点，所以编译器可以选择计算参数的顺序，结果是不定的，只能保证在这条语句执行后 `a` 的值加 1。

```c
printf(“%d, %d\n”, a, a * a++);
```

表达式 `(4 + x++)` 不是一个完整表达式，所以无法保证 `x` 在子表达式 `(4 + x++)` 求值后立即加 1，其结果有多种可能，只能保证在执行下一条语句之前 `x` 的值加 2，因此不要在同一个表达式里多次使用自增自减运算符。

```c
y = (4 + x++) + (6 + x++);

// 不要这样使用
++i + i++;
j-- + ++j;
```

# 4 流程控制

## 分支

### if

if 语句通过判断表达式的真假来执行下面的流程，可以嵌套多层 if 语句。

```c
if (表达式 1)
{
    语句
}
else if (表达式 2)
{
    if (表达式 3)
    {
        语句
    }
    else
    {
        语句
    }     
}
else
{
    语句
}
```

如果 if 语句部分只有一条语句，则可以不用加上大括号。

### 条件运算符

C 提供**条件表达式**作为表达 if else 语句的一种便捷方式，使用条件运算符 `?:` 来表示，其通用形式如下：

```c
表达式 1 ? 表达式 2 : 表达式 3
```

如果表达式 1 的值为真，则整个条件表达式的值为表达式 2，否则为表达式 3。

```c
if (a > b)
    printf("%d\n", a);
else
    printf("%d\n", b);
```

以上代码用条件表达式可以表示为：

```c
printf("%d\n", a > b ? a : b);
```

### switch

对于某些选择分支，使用 switch 语句更为方便，其通用形式如下：

```c
switch (整型表达式)
{
case 常量 1:
    语句 1
case 常量 2:
    语句 2
    // ...
case 常量 n:
    语句 n
default:
    语句 default
}
```

switch 语句首先对**整型表达式**求值，然后逐一扫描标签 `case`，直到发现一个匹配项然后跳转至该行。如果没有匹配项，且含有 `default` 标签，则会跳转至该行，如果没有此标签，则什么都不执行。

和 if 语句不同的是，switch 语句的判断条件只能是整型表达式，其 case 标签也只能使用整型**常量**或**常量表达式**。除了第 1 个标签外，其余的都是可选项。

switch 语句的执行关键在于跳转，而不是选择。如果匹配，则会跳转至该标签，然后一直顺序执行。如果此标签下面还有标签，则 switch 会一直不断执行，直到全部执行完毕为止。如果只想执行对应标签，则需要使用 `break` 语句：

```c
switch (ch)
{
case 'a':
    ch++;
case 'b':
    ch += 2;
    break;
case 'c':
    ch += 3;
    break;
default:
    ch += 5;
}
```

以上代码如果 ch 的值为字符 `a`，则会选择第 1 个标签，ch 的值加 2，但是这里并没有使用 break 语句，所以会接着执行下个标签中的 `ch += 2` 语句，于是 ch 的值又被加了 2。由于第 2 个标签含有 break 语句，所以会直接跳出 switch 语句，不再执行下面标签的语句。

### goto

goto 语句实际上并不是 C 所十分依赖的，且最好不要滥用 goto 语句，虽然 goto 语句很强大，但它十分容易导致代码结构变得混乱。在 C 中，能够使用 if 语句或 switch 语句时，尽量不要用 goto 语句。其通用形式为：

```c
goto 标签
// ...
标签: 语句
```

执行 goto 语句后，程序会直接跳转到标签所在行。

之后会直接从此处开始执行程序。

实际上，break 语句和 continue 语句都是 goto 语句的特殊形式。通常使用 goto 从一组出现问题的循环中跳出：

```c
while (表达式)
{
    // ...
    while (表达式)
    {
        // ...
        if (出现问题)
            goto help;
    }
}
help : 语句
```

跳转可以往后跳，也可以往前跳。

## 循环

### while

while 语句的通用形式如下：

```c
while (表达式)
{
    语句
}
```

如果表达式的值为真，则执行语句部分一次，然后再次判断表达式是否为真。在表达式的值为假之前，循环的判断和语句的执行一直重复进行，每次循环都被称为一次**迭代**，代码块部分被称为**循环体**。循环语句需要有终止条件，如果表达式的值始终为真，则会陷入**无限循环**。

### for

在使用循环时，通常会遵循**初始化、判断表达式、执行循环体、更新**四个步骤，用 while 语句表示出来即：

```c
n = 1;                  // 初始化
while (n < 10)          // 判断表达式
{                       // 执行循环体
    printf("%d\n", n);
    n++;                // 更新
}
```

而 for 语句则是把这四者合一，从而写出更加简洁明朗的程序，而且在效率上也比 while 语句和 do while 语句更加高效。

for 语句的通用形式如下：

```c
for (初始化; 判断; 更新)
{
    语句
}
```

for 语句使用 3 个表达式控制循环过程，分别用分号隔开。初始化表达式在执行 for 语句之前只执行一次，然后判断表达式，如果为真，则执行循环体一次，接着更新表达式，然后再判断表达式。

以上程序用 for 语句可以写为：

```c
for (n = 1; n < 10; n++)
    printf("%d\n", n);
```

可以省略一个或多个表达式，但不能省略分号：

```c
for (;;)        // 全部省略
for (n = 1;;)   // 省略第 2、3 个表达式
for (; n < 3;)  // 省略第 1、3 个表达式
```

如果省略了第二个表达式，则**默认为真值**。

### do while

while 语句和 for 语句都是入口条件循环，即在循环的每次迭代之前检查表达式，所以有可能根本不执行循环体中的内容，而 do while 语句为出口条件循环，即在循环的每次迭代之后检查表达式，这保证了至少执行循环体一次。do while 语句的通用形式如下：

```c
do
{
    语句
} while (表达式);
```

do while 语句会首先执行循环体一次，然后判断表达式，若为真，则再次迭代一次，否则结束循环。这里需要注意的是，**do while** **语句的** **while** **后需要加一个分号**。

### 选择循环方式

首先确定是入口循环还是出口循环，如果是出口循环，则选择 do while 语句。如果选择入口循环，涉及初始化和更新时，用 for 语句比较好，而一些简单的循环方式则用 while 语句。实际上 while 语句和 do while 语句能做的，for 语句都能做，且在效率上更加高效。

### 嵌套循环

在使用循环的时候可以嵌套，即一个循环包含另一个循环。嵌套循环通常用来处理多行多列的问题，如打印乘法口诀表：

```c
for (i = 1; i <= 9; i++)
{
    for (j = 1; j <= i; j++)
        printf("%d*%d=%d\t", j, i, i * j);
    printf("\n");
}
```
运行结果：

>   1\*1=1
>   1\*2=2   2\*2=4
>   1\*3=3   2\*3=6   3\*3=9
>   1\*4=4   2\*4=8   3\*4=12  4\*4=16
>   1\*5=5   2\*5=10  3\*5=15  4\*5=20  5\*5=25
>   1\*6=6   2\*6=12  3\*6=18  4\*6=24  5\*6=30  6\*6=36
>   1\*7=7   2\*7=14  3\*7=21  4\*7=28  5\*7=35  6\*7=42  7\*7=49
>   1\*8=8   2\*8=16  3\*8=24  4\*8=32  5\*8=40  6\*8=48  7\*8=56  8\*8=64
>   1\*9=9   2\*9=18  3\*9=27  4\*9=36  5\*9=45  6\*9=54  7\*9=63  8\*9=72  9\*9=81

第 1 行的 for 语句为**外层循环**，第 3 行的 for 语句为**内层循环**。注意第 5 行的 printf 函数并不属于内层循环的循环体。

### 循环的另类使用方式

不管是 while 语句、do while 语句还是 for 语句，其括号中的内容本质是表达式，既然是表达式，则不会仅仅有着诸如初始化、更新等最基础的操作，实际上它可以是任何一种合法的表达式：

```c
while (scanf("%d", &i) == 1)
for (i = 1, printf("OK!"); i < 10; scanf("%d", &i))
```

### continue 和 break

一般来说，在进入循环后，执行完循环体中所有语句之前都不会跳出循环，如果想要忽略一部分语句，提前结束循环，可以使用 `continue` 和 `break` 语句。

三种循环都可以使用这两种语句，使用 continue 时，会跳过本次迭代剩余部分，直接开始下一次迭代，对于 for 语句来说，执行 continue 语句后，会先执行更新部分，然后开始判断表达式。

使用 break 时，会直接跳出循环，不再执行本次迭代剩余部分。对于 do while 语句和 for 来说，前者最后的判断部分会直接跳过，后者连更新部分也会直接跳过。

这两种语句都只会跳过当前循环语句，也就是说，如果该循环处在一个循环嵌套中，则只会影响内层循环，不会影响到外层循环。

# 5 函数

## 函数概述

函数是用于完成特定任务的独立程序代码单元，免于编写重复代码，在使用某一特定功能时，调用函数即可。函数可以看作一个黑盒，不必关心其内部实现细节。

```c
void add(int, int);         // 声明函数原型

int main(void)
{
    int a = 2, b = 3;
    add(a, b);              // 把 a、b 当作参数传递给 add 函数
    return 0;
}

void add(int a, int b)      // 定义 add 函数
{
    printf("%d\n", a + b);  // 打印两个数相加的值
}
```

程序在三处位置使用了 add 标识符。

第 1 处，在程序第 1 行，声明了一个函数原型，目的是告诉编译器函数的类型，void 说明了函数的返回值类型，这里不返回任何值，即**空类型**，后面的圆括号有两个 int，声明了两个变量，表示接受由 main 函数传递过来的两个 int 型的参数。

第 2 处，在程序第 6 行，在 main 函数中调用了 add 函数，把输入的两个数传递给 add 函数，main 函数称为**调用函数**，add 函数称为**被调函数**。

第 3 处，在程序第 10 行，定义了 add 函数。在定义函数时，参数必须有标识符。功能是输出 a + b 的值，定义函数时后面不加分号，因为它不是一个语句。

**函数原型**告诉编译器函数的类型，**函数调用**表明在此处执行函数，**函数定义**指明了函数要做什么，这些信息称为函数的**签名**。

函数声明是声明一个函数的原型，其通用格式为：

```c
返回值类型 函数名字(参数类型);
```

多个参数用逗号隔开，每个参数前都必须声明类型，且参数为这个函数所私有，是局部变量，所以调用函数和被调函数即使用了相同的变量名，也互不影响。函数原型中的参数为**形式参数**，仅仅是告诉编译器该函数参数的类型，并不会为其分配空间，在**声明函数原型时可以省略变量标识符**。

在定义函数时也支持 ANSI C 以前的形式：

```c
void functoin(a, b)
int a, b;
{
    // ...
}
```

若是声明多个类型相同的参数可以用这种方法。若是不带任何参数，则在括号里加上 void，也可以使用旧的函数声明，即一个空圆括号。函数定义中的参数为**实际参数**，编译器会为其分配空间。

若需要 add 函数返回一个值：

```c
int add(int a, int b)
{
    return a + b;
}
```

add 函数回返回一个 int 型的值给 main 函数，return 语句有终止函数的作用：

 ```c
int judge(int a, int b); // 函数声明
int judge(int a, int b)  // 函数定义
{
    if (a > b)
        return a;
    else
        return b;
    printf("End\n");
}
 ```

这里的 printf 函数用永远不会被执行，因为在执行 printf 函数之前，必定会遇到 return 语句，则会终止函数的执行，并把控制交给 main 函数。

声明函数时必须声明函数类型，有返回值的函数其类型必须与返回值类型相同，没有返回值即为 void 类型。以下两种声明方式都是可以的：

```c
/* 放在main函数之前 */
void add(int a, int b); // 函数声明
int main(void)
{
    int a, b;
    // ...
    add(a, b);          // 函数调用
    // ...
}
void add(int a, int b) // 函数定义
{
    // ...
}
```

函数声明和函数定义是不同的，必须在使用函数之前进行函数声明，以告知编译器这个函数的信息，这样当在程序中调用函数时，编译器就知道如何处理。而函数定义是函数功能的具体实现，如 math.h 头文件中有 sqrt 函数的声明，但是其定义却在另一个库函数文件中。

**如果把函数定义放在使用之前，也可以不声明。**

## 函数原型

ANSI C 之前的函数原型：

```c
int function();
```

它告知了函数返回值的类型，但是并没有说明函数参数的类型与个数，如果使用了错误的参数类型和个数，编译器将不会发现这种错误。

```c
int add();              // 不确切的函数声明

int main(void)
{
    // ...
    add(a, b);          // 接受两个参数
}

int add(int a, int b)
{
    return a + b;
}
```

这里的函数声明部分并没有明确说明参数类型和个数，就算在定义函数时说明了参数类型及个数，编译器也不会检查实际传递参数时的正确性。

调用函数把要传递的参数放在内存中一个叫做**栈**的临时存储区域中，然后被调函数从栈中读取这些参数，但是这两个过程并没有协调进行，调用函数根据实际传递的参数确定其类型和个数，但是被调函数根据其形式参数确定其类型和个数。

若是传递的参数类型不正确，如对 add 函数只传递一个浮点类型的参数：

```c
add(12.5, 30);
```

由于没有声明参数类型，所以调用函数根据实际传递参数确定其类型。这里第一个为浮点数，自动转换为 double 类型，占用 8 个字节；第二个为 int 型，占用 4 个字节。而被调函数读取时根据其定义类型来读取，即读取两个 int 型数值，首先读取 4 个字节，为 double 值的前 4 个字节，然后再读取 4 个字节，为 double 值的后 4 个字节，那么栈就会出问题，结果不可知。

若是传递的参数个数不正确，如只传递一个参数：

```c
add(30);
```

这里只有一个参数，所以先读取 4 个字节，再往后读取 4 个字节，栈也会出问题，结果也是不可知的。

所以我们需要在声明函数时正确声明其形式参数的类型，如果有一个参数类型不匹配的情况，编译器会自动转换为相匹配的类型。**但是有一个例外**，就是在使用之前就已经定义了函数，这种情况也不会发生。

一个程序中的每个 C 函数和其它函数之间是平等的，每一个函数都可以调用其它函数，或者被其它任何一个函数调用（包括 main 函数）。

## 递归

C 允许函数调用它自己（包括 main 函数），这个过程称为**递归**，递归一般可以代替循环语句使用，但效率没有循环语句高。

设有以下代码：

```c
void recursion_function(int);

int main(void)
{
    recursion_function(1);
    return 0;
}

void recursion_function(int n)
{
    printf("Level %d, n location = %p\n", n, &n);
    if (n < 4)
        recursion_function(n + 1);
    printf("Level %d, n location = %p\n", n, &n);
}
```

通过分析可以知道递归的基本原理。

第一，每一级函数调用都有自己的变量（即使它们名字一样），但这几个变量是独立的，我们从执行结果看出，每一级变量的值和内存中的地址都不一样。

第二，每一次函数调用都有一次返回，当程序到递归的结尾时，它会转移到上一级继续执行，程序不能直接返回第一个调用函数，只能每一级逐级返回。

第三，在递归中，位于递归调用前的语句被顺序执行，递归返回时反序执行，当最后一次递归完成后，从最后一次递归后的 printf 函数开始执行。

第四，递归函数必须包含终止递归的程序，否则将会一直递归下去。

递归调用语句放在 return 语句之前的递归叫做**尾递归**，相当于一个循环语句：

```c
void re_fu(int n)
{
    if (n > 0)
        return re_fu(n - 1);
    else
        return 0;
}
```

虽然这里的调用不是在函数中的最后一行，但它是在 n > 0 的情况下执行的最后一条语句，所以也算尾递归。

因为递归函数的每一级都拥有自己独立的变量，所以会占用较多的内存，且每次递归函数都会把参数放在栈中，所以执行效率和速度会下降，递归会占用较多的计算机资源。

递归效率虽然不高，且占用资源较多，但是在处理倒序问题时比循环更方便，如打印一个整数的二进制形式时：

```c
void to_binary(unsigned long n);

int main(void)
{
    unsigned long num = 255;
    to_binary(num);
    return 0;
}

void to_binary(unsigned long n)
{
    int r;
    r = n % 2;
    if (n >= 2)
        to_binary(n / 2);
    putchar(r == 0 ? '0' : '1');
    return 0;
}
```

运行结果：

>   11111111

又如计算斐波那契数列的函数可以这样定义：

```c
unsigned long fibonacci(unsigned n)
{
    if (n > 2)
        return fibonacci(n - 1) + fibonacci(n - 2);
    else
        return 1;
}

```

## 使用头文件

如果把 main 函数放在一个文件中，而把自定义函数放在另一个文件中，那么在 main 函数中使用自定义函数前仍需要声明原型，而如果把函数声明放在一个头文件中，就不必每次使用这些函数时都声明一次。又如定义常量时，如果把这个常量放在一个文件中，如果另一个文件想要使用这个常量，那么就需要在另一个文件中同样定义这个常量，如果把这些常量统一放在一个头文件中，那么只用在需要使用的文件前加上 `#include` 指令。

```c
/* 文件 function.h */
#include <stdio.h>
#define NUM
void function(void);

/* 文件 main.c */
#include "function.h" // 自定义头文件用双引号扩起来，被包含的文件位于当前工作目录下
int main(void)
{
    //  ...
    function();
    // ...
    return 0;
}

/* 文件 function.c */
#include "function.h"
void function(void)
{
    // ...
}
```

以上三个文件放在一个项目里一起编译即可。

# 6 数组和指针

## 数组

数组由一系列类型相同的元素组成，在内存中**顺序存储**，属于派生类型，因为它是建立在其它类型之上的。数组声明包括数组元素的类型和数目：

```c
int ar[5]; // 声明一个包含 5 个 int 类型元素的数组
```

方括号 `[]` 表示 ar 是一个数组，其内的数字指明了数组所包含元素的数目，**且只能是整型常量或整型表达式**。要访问数组中的元素，可以使用**下标**来表示单个元素，从零开始计数，如 ar[0] 表示数组的第 1 个元素。

### 初始化

变量在声明时可以初始化，数组同样也可以，ANSI C 支持以下方式进行初始化：

```c
int ar[5] = {1, 2, 3, 4, 5}; // 花括号表示这是一个列表，数值之间以逗号隔开
```

在只需要检索数组值的时候，可以把数组声明为只读（常量数组）：

```c
const int ar[5] = {1, 2, 3, 4, 5}; // 声明时必须初始化，之后不能再修改
```

初始化列表中的元素数目应该和数组大小相同。若是小于数组大小，则其余元素会被默认初始化为 `0`（浮点数为 `0.0`，字符为 `'\0'`）；若大于数组大小，则报错。

若在声明时省略方括号中的数字，则必须初始化，编译器会根据初始化元素数目自动匹配数组大小。

#### 指定初始化器

C99 允许初始化指定元素，未经初始化的元素同上。此种方式初始化数组有两个特性：

第一，如果在一个指定初始化元素后跟有不只一个值：

```c
int ar[5] = { [2] = 3, 4, 5}; // 后续数值将用来对指定元素的后续元素初始化
```

第二，多次对同一个元素进行初始化，则最后一次有效：

```c
int ar[5] = {1, 2, 3, 4, [2] = 5, 6}; // ar[2] = 5，ar[3] = 6，ar[4] = 0
```

如果在指定初始化时未确定数组大小：

```c
int ar[] = {1, [3] = 6, 8}; // 实际元素个数为 5
```

那么编译器会把数组大小设置为足够装得下初始化的值。

### 给数组元素赋值

声明数组后（不管它是否初始化），之后都可以对它进行赋值（只读数组除外）。C 不支持把数组作为一个整体来进行赋值，也不支持用花括号（列表）的形式进行赋值（初始化除外），只能进行单个赋值：

```c
int ar[5];
int ar2[5] = {1, 2, 3, 4, 5};
ar = ar2;                       // 错误
ar[5] = {1, 2, 3, 4, 5};        // 错误
ar[5] = ar2[5];                 // 语法上没有错误，但下标越界
```

要注意的是，除了声明以外，下标的最大值为 `数组元素个数 - 1`，因为在使用数组时下标是从 `0` 开始的。

### 数组边界

使用数组时要注意下标不能超过数组的边界，因为编译器不会检查下标的合法性（为了使程序运行更快）。在 C 中使用越界下标的行为是未定义的，一旦使用了错误的下标，那么结果通常不可知，程序可能出错也可能得到一个垃圾值还可能改变其它在该程序中的变量的值：

```c
int value = 1, value2 = 2;
int ar[5] = {3, 4, 5, 6, 7};
ar[-1] = 10;
ar[5] = 20;
```

如果 value 在内存中的位置正好在元素 ar[0] 之前，那么 value 的值会被改变为 10，value2 也可能同样如此，还有可能什么都不发生。

## 多维数组

形如这样的数组：

```c
int ar[3][3]; // 声明一个二维数组
```

它表示由 3 个元素且每个元素由 3 个 int 型数值组成的数组的数组。如 ar[0] 是一个包含 3 个 int 数值的数组，ar[1] 也同样如此。ar\[n\][m] 可以理解为一个 n 行 m 列的一个矩阵。

### 二维数组的初始化

二维数的初始化建立在初始化一维数组的基础上：

```c
int ar[3][3] = {{1, 2}, {6, 7}}; // 行与行之间以逗号隔开
int ar[3][3] = {1, 2, 0, 6, 7};
```

上面这两行是等价的，未被初始化的元素会被默认初始化为 0。

若是超出了边界：

```c
int ar[3][3] = {{1, 2, 3, 4}, {8, 9, 10}}; // 错误
```

对二维数组指定初始化：

```c
// ar[0][0] = 1, ar[0][1] = 2, ar[2][0] = 5, ar[2][1] = 6
int ar[3][3] = {1, 2, [2] = 5, 6};
```

二维以上的数组对此同样适用：

```c
// ar[0][0][0] = 1, ar[0][0][1] = 2, ar[2][0][0] = 5, ar[2][1][0] = 8
int ar[3][3][3] = {1, 2, [2] = 5, [2][1] = 8};
```

## 变长数组

C99 新增了变长数组（VLA），它允许使用变量来定义数组的维度：

```c
int i = 3, j = 4;
int ar[i][j];
```

变长数组有一些限制：第一，必须是自动存储类别；第二，声明时不能初始化。

变长数组和普通数组一样，并不意味着它的维度可以随时改变，而是只要确定了维度，就不能再改变，作为维数的变量必须在数组声明之前：

```c
void fuction(int i, int j, int ar[i][j]); // 正确
void fuction(int ar[i][j], int i, int j); // 错误
```

声明函数时，形参名可以省略，但对于变长数组来说，必须在方括号中加 `*` 号：

```c
void fuction(int, int, int ar[*][*]); // 省略了形参名
```

C11 把变长数组作为一个可选特性，而不是强制实现的特性，目前完全支持这一特性的编译器不多。在 C99 / C11中，作为变长数组维数的变量可以用关键字 const 来声明：

```c
const int SIZE = 5;
int ar[SIZE];
```

而 C90 则未定义，对于不同的环境，可能允许或不允许。

## 指针

### 指针简介

指针是一种新的数据类型，其值为一个数据对象的地址，由无符号整数表示，但不能被看作整数。如 int 变量的值为整数，char 变量是一个数值为字符的变量（本质上也是 int），double 变量是一个数值为浮点数的变量，而指针表示数值的地址。

设指针变量 `pt`：

```c
pt = &a; // 把 a 的地址赋给 pt
```

对于这个语句，称 pt 指向 a，pt 是一个变量，而 &a 是一个常量，其值为 a 的地址，& 为**地址运算符**，用来获取变量的地址。

### 声明指针

声明指针前，需要明确指针所指向变量的类型，因为不同变量类型所占内存空间和在内存中的存储方式不同，如 int 在内存中占 4 个字节，short 在内存中占 2 个字节；又如 int 和 ﬂoat 都在内存中占 4 个字节，但是在内存中存储方式完全不同。

```c
int *pi;          // pi 是指向 int 指针
char *pc;         // pc 是指向 char指针
float *pf1, *pf2; // pf1 和 pf2 都是指向 float 的指针
```

类型标识符表明了被指向变量的类型，`*` 表示该变量为一个指针。

### 初始化

指针在声明后必须初始化，如果不进行初始化，那么它的值并不确定，以后在使用时，并不清楚到底对内存中哪个地址进行了操作，这种指针俗称**野指针**。

```c
int *pi; // 野指针
*pi = 5;
```

由于 pi 并没有初始化，所以它的初值是任意的，也就是说它随便指向内存中的某个位置，这时改变了这个地址的值，也就有可能改变内存中任意位置的值，可能覆盖一个本身存在的值，也可能导致程序出错。虽然编译器不会报错，但是在使用指针时务必立即初始化。

### 取值

可以用间接运算符 `*` 取出指针所指向地址的值：

```c
int i = 1;
int *pi = &i;
printf("pi = %p, *pi = %d\n", pi, *pi);
```

运行结果：

> pi = 000000000062FE14, *pi = 1

即：

>   pi = &i
>
>   *pi = *&i = i

这里的 `*` 与声明指针所用的 `*` 意义不同，在使用时它是间接运算符，而声明时它代表这个变量是一个指针，可以简单的看作把 `&` 和 `*` 放在一起时可以相互抵消。

### 指针和指针的地址

指针和指针的地址是两个概念。指针是一个指向某个内存空间的变量，其值是所指向内存空间的地址。而指针的地址表示指针本身这个变量在内存中的地址。

```c
int i = 1;
int *pi = &i;
printf("i = %d, &i = %p\n", i, &i);
printf("*pi = %d, pi = %p, &pi = %p\n", *pi, pi, &pi);
```

运行结果：

> i = 1, &i = 000000000062FE1C
>
> *pi = 1, pi = 000000000062FE1C, &pi = 000000000062FE10

### 指向指针的指针

指针可以指向指向任何类型，包括指针类型，声明一个指向指针的指针：

```c
int n = 5;
int m = 10;
int *p = &n;            // p 的值为 n 的地址，*p 为 n 的值
int **pp = &p;          // pp 的值为 p 的地址，*pp 为 p 的值，即 n 的地址，**pp 为 n 的值
printf("&n = %p, p = %p, &p = %p\n", &n, p, &p);
printf("pp = %p, *pp = %p, **p = %d\n", pp, *pp, **pp);
*pp = &m;               // 通过 pp 来改变 p 所指向的地址，此时 p 的值为 m 的地址
printf("&m = %p, p = %p, &p = %p\n", &m, p, &p);
printf("pp = %p, *pp = %p, **p = %d\n", pp, *pp, **pp);
```

运行结果：

> &n = 000000000062FE14, p = 000000000062FE14, &p = 000000000062FE08
>
> pp = 000000000062FE08, *pp = 000000000062FE14, **p = 5
>
> &m = 000000000062FE10, p = 000000000062FE10, &p = 000000000062FE08
>
> pp = 000000000062FE08, *pp = 000000000062FE10, **p = 10

### 函数和指针

函数中的变量为自己私有的，也就是说，被调函数不能直接影响调用函数中变量的值，但通过指针，可以获取调用函数中变量的地址来改变它的值，即使是两个毫不相干的函数。

```c
void swap(int *a, int *b);

int main(void)
{
    int a = 1, b = 2;
    printf("a = %d, b = %d\n", a, b);
    swap(&a, &b);
    printf("Now, a = %d, b = %d\n", a, b);
    return 0;
}

void swap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
```

运行结果：

> a = 1, b = 2

> Now, a = 2, b = 1

通过传递变量的地址而不是传递变量本身，来改变变量的数值，一个变量的地址在运行时是不会变化的，所以可以使用指针来改变变量的值。

其中函数接受的参数类型也改变了，通过加 `*` 号，使函数接受一个 int 变量的地址。

变量有两种属性：标识符和值。当程序被加载时，数据被加载到内存中，此时变量在计算机中的名字变为了地址。标识符是我们赋予变量的名字，而地址是计算机赋予变量的名字。

普通变量把它的数值作为基本数值量，通过 `&` 运算符来间接获取它的地址。对指针来说，地址是它的基本数值量，它的值需要通过 `*` 运算符来间接获取。两者不同的是，数值可以改变，地址不能改变。

### 数组和指针

数组实际上是一种变相使用指针的形式，指针能够有效处理数组：

```c
int ar[5] = {1, 2, 3};
```

数组名 ar 不仅是该数组的名字，还是该数组首元素 a[0] 的地址，即：

>   ar = &ar = &ar[0]

这三者都是该数组的首地址，且都为常量，不能更改其值，但是可以把它们赋给指针变量，修改指针变量的值。

```c
int *p = ar; // p 的值为数组 ar 的首地址
p++;         // 把 p 所指向的地址往下移动一个单位，即 ar[1] 的地址 &ar[1]
*p = 5;      // 取出 *p 的值，并改变值，即 ar[1] = 5
```

对一个指针加 1 的结果是对该指针增加 1 个存储单元（所指向类型的字节大小）。对数组而言，地址会增加到下一个元素的地址，而不是下一个字节。

可以用指针标识数组的每个元素，并得到其数值，即对同一个对象有两种不同的表示方法，如定义 ar[n] 时，意思是 `*(ar + n)`，即寻址到内存中的 ar，然后移动 n 个单位，再取出该单位所对应的数值。

```c
*(ar + i); // 该数组的第 i 个元素的值，等同于 ar[i]
*ar + i;   // 第 1 个元素的值和 i 相加，等同于 ar[0] + i
```

### 函数、数组和指针

若要一个函数（如 sum 函数返回该数组中所有元素之和）对数组进行操作：

```c
int ar[5] = {1, 2, 3, 4, 5};
int result = sum(ar, 5);
```

C 不支持把整个数组作为函数参数进行传递，但可以传递数组的地址。

这里的第一个参数把数组首地址和类型的信息传递给函数；第二个参数把数组中的元素个数传递给函数。

声明函数原型：

```c
int sum(int *ar, int n);
```

由于声明函数原型和函数定义时可以省略名称，并且数组名本质上是一个指针，则还可以使用这三种形式：

```c
int sum(int *, int);
int sum(int ar[], int n);
int sum(int [], int);
```

在这种情况下，C 对 `int ar[]` 和 `int *ar` 作出同样的解释，但另外一种情况就不同了：

```c
void size_of_ar(int ar[])
{
    printf("%zd\n", sizeof(ar));
}

int main(void)
{
    int ar[5];
    printf("%zd\n", sizeof(ar));
    size_of_ar(ar);
    return 0;
}
```

运行结果：

> 20
>
> 8

第 1 个 sizeof 返回数组 ar 的大小，int 为 4 个字节，那么大小就为 20。而 size_of_ar 函数获得的参数的值实际上是数组 ar 的首地址，传递过来的是一个指针，所以第 2 个 sizeof 返回的是这个指针的大小，在 64 位系统上大小为 8。

设 sum 函数有两个参数，一个是指向数组 ar 首地址的指针，一个是数组 ar 末地址的指针：

```c
int sum(int *st, int *end)
{
    while (st < end)
        result += *st++; // * 和 ++ 优先级相同，但从右至左结合
    return result;
}

int main(void)
{
    int ar[5] = {1, 2, 3, 4, 5};
    printf("sum = %d\n", sum(ar, ar + 5));
    return 0;
}
```

运行结果：

> sum = 15

传递给函数的第一个参数是数组 ar 的首地址，也就是 &ar[0]。第二个参数 ar + 5 等同于 &ar[5]，但数组 ar 最后一个元素的下标为 4，按理说下标越界了。实际上，虽然在 while 中结束循环的判定点在 &ar[5] 之前，但是 end 指向数组 ar 之后的地址类型并不一定是 int 型的，所以 C 保证在为数组分配存储空间的时候，指向数组后的第一个位置的指针也是合法的（仅仅是可以指向，但不能取值）。

### 指针操作

可以对指针进行操作，有以下几种方式：

-   **赋值**——可以把地址赋给一个指针，通常使用取地址运算符 &、数组名和另一个指针来进行。地址类型应该和指针类型兼容，如不能把一个 double 类型的地址赋给一个指向 int 的指针。

-   **解引用**——取值运算符 `*` 可取出指针指向地址中所存储的值。

-   **取地址**——可以用 `&` 得到存储该指针本身的地址。

-   **指针与整数相加**——可以使用 `+` 运算符把指针与整数相加，这个整数会和这个指针所指向类型的大小的字节数相乘，然后加到这个指针上。如果相加的结果超出了指针所指向地址的范围，则结果是未定义的。

-   **指针与整数相减**——可以使用 `-` 运算符把指针与整数相减，指针必须是第一个操作数，这个整数会和这个指针所指向类型的大小的字节数相乘，然后指针减去这个数。如果相减的结果超出了指针所指向地址的范围，则结果是未定义的。

-   **指针自增自减**——相当于相 / 加减的整数为 1，即把指针移至数组的下 / 上一个元素。

-   **指针求差**——计算两个指针间的差值，**有效指针差运算的前提是参加运算的两个指针是指向同一个数组**，以求出两个指针所指向元素的距离，单位是该类型大小。如果不是指向同一个数组，则结果是未定义的。

-   **指针比较**——使用关系运算符来比较两个指针的大小，前提是两个指针都指向相同的类型的对象。

```c
int ar[3] = {1, 2, 3};
int *p = ar;
int *p2 = &ar[2];
printf("p + 2 = %p\n", p + 2);       // 等同于 &ar[2]
printf("*(p + 2) = %d\n", *(p + 2)); // 等同于 ar[2]
printf("*(p + 3) = %d\n", *(p + 3)); // 等同于 ar[3]，下标越界，结果未定义
printf("p2 - p = %ld\n", p2 - p);    // ar[2] 和 ar[0] 相差了 2 个单位距离
```

运行结果：

> p + 2 = 000000000062FE08
>
> *(p + 2) = 3
>
> *(p + 3) = 0 （结果不确定）
>
> p2 - p = 2

C 并不检查指针是否仍然指向数组中的某个元素，只保证指向数组元素的指针和指向数组后的第一个地址的指针是有效的，但如果在指针在进行运算时超出了这个范围，那么结果将是未定义的，另外不可以对指向数组后第一个地址的指针进行取值运算，尽管这样的指针是合法的。

### 保护数组内容

是否需要传递给函数一个指针，取决于是否需要在函数内改变传递过来的值。但在传递一个数组时，只能使用指针传递，这时可以使用关键字 const 来保护数组内容不被改变：

```c
int sum(const int ar[], int n); // 函数原型
```


该指针指向一个 int 常量，它是一个指向常量的指针，于是该函数不能修改数组 ar 中的内容。

将常量或非常量赋给一个指向常量的指针是合法的，但是将常量赋给一个普通指针是非法的，这意味着可以使用普通的指针修改常量的值。指向常量的指针本身是一个变量，它自身可以改变。

```c
int a = 1, b = 2;
const int *p = &a; // p 的值可以改变，但不能改变 *p
p = &b;            // 正确
*p = 3;            // 错误
```

也可以声明一个常量指针，这意味着指针的值不能改变，但指针所指向地址的值可以改变：

```c
int a = 1, b = 2;
int *const p = &a; // p 的值不能改变，但可以改变 *p
p = &b;            // 错误
*p = 3;            // 正确
```

还可以声明一个指向常量的常量指针，这意味着既不能改变指针的值，也不能改变指针所指向地址的值，且必须初始化：

```c
int a = 1, b = 2;
const int *const p = &a; // p 和 *p 的值都不能改变
p = &b;                  // 错误
*p = 3;                  // 错误
```

一切都取决于 const 的位置和个数。

### 指针和多维数组

声明一个二维数组：

```c
int ar[5][5];
```

数组名 ar 是该数组的首地址，也就是该数组第一个元素的地址，即 &ar[0]，而第一个元素本身也是一个包含 5 个 int 型数值的数组，所以 ar[0] 既是数组 ar 的第一个元素，又是数组 ar[0] 的数组名，同时还是数组 ar[0] 的首地址，即 ar[0] = &ar\[0\][0]（可以把 ar[0] 当作一个数组的名字）。在数值上，ar = &ar[0] = ar[0] = &ar[0]

但这并不代表 ar 等同于 ar[0]，因为 ar 是指向一个包含 5 个 int 型的数组地址的指针，而 ar[0] 是指向一个 int 型地址的指针，两者的数值可能等同，但是类型不同。

```c
int ar[5][5] = {{1, 2, 3}, {6, 7, 8}};
*ar;              // 等同于 *&ar[0]       = ar[0]
**ar;             // 等同于 *ar[0]        = *&ar[0][0]   = ar[0][0]
ar + 1;           // 等同于 &ar[1]
*ar + 1;          // 等同于 ar[0] + 1     = ar[1]        = &ar[1][0]
**ar + 1;         // 等同于 *ar[0] + 1    = ar[0][0] + 1 = 2
*(ar + 1);        // 等同于 *(&ar[0] + 1) = *&ar[1]      = ar[1]      = &ar[1][0]
**(ar + 1);       // 等同于 **&ar[1]      = *ar[1]       = *&ar[1][0] = ar[1][0] = 6
*(ar + 1) + 1;    // 等同于 &ar[1][0] + 1 = &ar[1][1]
*(*(ar + 1) + 1); // 等同于 *&ar[1][1]    = 7
```

二维数组用指针表示的通用形式为：

>   ar\[n\][m] = \*(\*(ar + n) + m)

### 指向二维数组的指针

声明一个指向二维数组的指针：

```c
int ar[5][5];
int *p;      // 错误，但是可以指向 ar[m]，0 ≤ m ≤ 4
int *p[5];   // 错误，[] 的优先级高于 *，是一个包含 5 个指向 int 元素的指针数组
int (*p)[5]; // 正确，指向一个数组，数组的每个元素由 5 个 int 元素组成
```

### 处理二维数组的函数

声明一个处理二维数组的函数，其函数原型为：

```c
int ar[5][5];
void fuction(int (*p)[5]);
```

当且仅当 p 是函数的形式参数时，也可以这样声明：

```c
void fuction(int p[][5]); // 第一个方括号是空的，表示它是一个指针
```

声明 N 维数组的指针时，除了最左边的方括号可以留空之外，其它都需要填写：

```c
int ar[5][5][5];
void fuction(int p[][5][5]);
// 等同于
void fuction(int (*p)[5][5]);
```

### 指针的兼容性

指针之间的赋值规则更为严格，不用类型转换就可以把 int 型值赋给 double 型，但指针不可以。

```c
int n = 5;
double x;
int *pi = &n;
double *pd = &x;
x = n;   // 允许
pd = pi; // 错误
```

前面所说可以把一个常量或非常量数值赋给一个指向常量的指针，这有一个前提——**只进行一层间接运算**，在进行多层运算时，将不再安全：

```c
const int n = 1;
const int **pp;
int *p;
pp = &p;  // 这将导致 const 失效
*pp = &n; // p 的值被改变为 &n
*p = 2;   // 常量 n 的值被改变了
```

C 标准规定通过非 const 指针更改 const 数据的行为是未定义的。

## 复合字面量

C99 新增了复合字面量，字面量是除符号常量外的常量。如 3 是 int 型字面量，3.14 是 double 型字面量，'a' 是 char 型字面量，"abcdefg" 是字符串字面量。而表示数组内容和结构的字面量称为复合字面量。

定义复合字面量：

```c
int ar[3] = {1, 2, 3};             // 普通数组声明并初始化方法
(int[3]){1, 2, 3};                 // 复合字面量，它缺少了名字和赋值运算符
(int[]){1, 2, 3, 4, 5};            // 复合字面量也可以省略大小，编译器会自动计算
(int[2][3]){{1, 2, 3}, {4, 5, 6}}; // 复合字面量类型为 int[2][3]
```

复合字面量是匿名的，不能先创建后使用，必须在创建时同时使用它，可以使用指针记录字面量的地址：

```c
int *pt = (int [2]){1, 2};
int (*pt)[2] = (int [][2]){ {1, 2}, {3, 4}, {5, 6} };
```

还可以把复合字面量作为实际参数传递给函数：

```c
total = sum((int []){1, 2, 3, 4, 5}, 5);
```
