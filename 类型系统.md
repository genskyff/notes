>   参考：
>
>   -   [Cardelli L. Type systems](https://lucacardelli.name/papers/typesystems.pdf)

# 1 概述

## 类型系统的意义与目标

**类型系统**（Type system）的根本目的是防止程序在运行时出现**执行错误**（Execution error），如非法指令故障或非法内存引用故障。这种保证要求对错误进行精确定义，并证明整个语言在所有可能的运行中都不出现执行错误时，称该语言是**类型健全的**（Type sound）。

## 执行错误、安全性与良好行为

执行错误分为两大类：

-   **捕获错误**（Trapped error）：如除零或非法内存访问，这类错误会使程序立即停止。
-   **未捕获错误**（Untrapped error）：如在缺乏运行时边界检查的情况下访问数组末尾之后的数据，或错误地跳转到内存中的非指令区域，可能导致数据损坏而不立即引发故障。

若不会引起未捕获错误，则程序被认为是**安全的**（Safe）；而**良好行为**（Good behavior）则要求程序避免所有**禁止错误**（Forbidden error），包括**所有未捕获错误**和**部分捕获错误**，类型系统利用**静态检查**（Static checking）和必要的**动态检查**（Dynamic checking）来确保这一点。

一个具有良好行为的程序必然是安全的，所有程序代码都具有良好行为的语言称为**强制检查语言**（Stringly checked language），应至少满足以下条件：

-   不会发生任何未捕获错误
-   不会发生任何被视为禁止错误的捕获错误
-   其它捕获错误可能会发生，这部分由程序员负责

## 有类型与无类型语言

**有类型语言**（Typed language）通过给程序变量规定明确的取值范围来避免错误。如一个类型为 Boolean 的变量 $x$ 在每次运行时只能取布尔值，使得表达式 $not(x)$ 始终有明确意义。而**无类型语言**（Untyped language）不限制变量的取值，或视所有值为单一通用类型（Universal type），这可能导致操作被应用于不适当的参数，从而产生任意结果、故障或异常。一个极端例子是纯 λ 演算（Pure λ-calculus），所有值都是函数，唯一的操作（函数应用）永远不会失败。

有类型语言可以通过在编译时进行静态检查从而强制程序具有良好行为，称为**静态检查语言**（Static checking language）。这种检查过程称为**类型检查**（Typechecking），而执行这一检查的算法称为**类型检查器**（Typechecker）。通过类型检查器检查的程序称为**类型良好**（Well-typed）的。

无类型语言则可以通过执行足够详细的动态检查来排除所有禁止错误，从而实现良好行为。如检查所有数组边界以及所有除法操作，在可能发生禁止错误时生成可恢复的异常。如 Lisp 没有静态检查也没有类型系统，但仍然是强制检查的。

即使是静态检查语言通常也需要在运行时进行测试以保证安全性，如检查数组边界。一个语言是静态检查的并不意味着没有动态检查。

有类型语言可能是**显式标注类型**（Explicitly typed），也可能依靠类型推断实现**隐式类型**（Implicitly typed），如 ML 和 Haskell。

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250213223742605.png" alt="Table 1. Safety" style="zoom:50%;" />

## 安全性与语言设计的权衡

一个具有良好行为的程序必然是安全的。类型系统的主要目标是通过排除所有未捕获错误来确保语言安全。不过大多数类型系统通常会确保良好行为从而隐含地保证类型安全。

静态检查语言并不保证绝对安全，因为一些语言的禁止错误集合不包括所有的未捕获错误，称为**弱检查**（Weakly checked）。

安全性通常需要在性能上付出代价，因为实现安全性往往依赖于运行时检查，而这些检查可能带来额外开销。

-   C 语言因追求高性能而刻意设计为不安全，但其广泛应用和随之而来的安全漏洞（如由于指针算术和缺乏数组边界检查导致的缓冲区溢出）促使开发安全子集以及引入额外的运行时检查。
-   安全性带来的故障停止、调试便利、运行时结构的完整性（支持垃圾回收）以及系统安全（如操作系统内核和网页浏览器加载外部代码）等优势，在整体上降低了开发和维护成本。

## 类型系统的工程优势

类型系统不仅有助于防止错误，还带来许多工程上的好处：

-   **执行效率**：准确的类型信息可消除对指针解引用时的空检查，避免运行时检查开销
-   **开发效率**：类型检查能在编译时捕捉大部分常见错误，使调试过程更简单
-   **编译与模块化**：类型信息构成模块接口，使各模块可以独立编译，从而提高编译效率和可维护性
-   **大规模协作**：明确的类型接口降低了各模块间的依赖，便于团队协作和局部代码重构
-   **安全保障**：防止诸如将整数随意转换为指针类型等危险操作，避免可能的安全漏洞

## 类型系统的基本属性与形式化方法

类型系统应具备以下特性：

-   **可判定性**（Decidably verifiable）：存在类型检查算法，能在编译时确定程序是否符合类型要求
-   **透明性**（Transparent）：能够直观预见程序是否能通过类型检查，且错误原因应明确
-   **可执行性**（Enforceable）：类型声明应尽可能在静态阶段得到验证，必要时辅以动态检查，保证声明与程序行为的一致

形式化类型系统通常包括以下步骤：

1.  **描述语法**（Syntax）：定义类型和项（Term）的结构
2.  **确定作用域规则**（Scoping rule）：通常采用静态作用域，将标识符与其声明位置严格对应。而缺乏静态作用域则称为动态作用域
3.  **建立类型规则**（Type rule）：描述项 $M$ 与 类型 $A$ 之间的关系。如 has-type 关系 $M : A$、子类型关系 $A <: B$，以及类型等价关系 $A = B$
4.  **引入静态类型环境**（Static typing environment）：记录程序中自由变量的类型，对应于编译器在类型检查阶段使用的符号表。如 has-type 关系 $M : A$ 通常写作为 $\Gamma\vdash M : A$，表示在环境 $\Gamma$ 下，$M$ 的类型为 $A$
5.  **定义语义**（Semantics）：确保程序项与其运行结果在类型上保持一致

## 类型等价问题

**类型等价**（Type equivalence）问题的关键在于确定何时不同书写的类型表达式可以视为等同。如下面的例子展示了两种可能的解释：

```
type X = Bool
type Y = Bool
```

-   若仅依据 X 和 Y 所关联的类型判断，则属于**结构性等价**（Structural equivalence）
-   若依据类型名称的不同而区分，则属于**按名称等价**（By-name equivalence）

实际语言中常采用两者的混合策略。结构性等价在数据存储和网络传输中具有明显优势，而按名称等价在处理独立开发或编译的代码时也有其独特作用。

# 2 语言的类型系统

## 类型系统的基本概念

### 独立性

类型系统规定了编程语言中的类型规则，与具体的类型检查算法相互独立，类似于用形式文法（Formal grammar）描述语法而不涉及具体解析算法。

### 分离职责

-   类型系统属于语言定义的一部分
-   类型检查算法属于编译器的实现

这种分离使得描述和理解语言的类型特性更加简单，同时允许不同编译器使用不同的算法来实现相同的类型系统。

### 效率考量

尽管可以设计出只支持不可行或不存在算法的类型系统，但通常目标是支持高效的类型检查算法。

## 判断

### 基本形式

**判断**（Judgments）是由上下文和断言组成的形式化陈述，通常写作：
$$
\Gamma\vdash\mathfrak{J}
$$
其中：

-   $\Gamma$ 是**静态类型环境**（Static typing environment），如 $\empty, x_1 : A_1, x_2:A_2, \cdots, x_n:A_n$
-   **空环境**记作 $\empty$，环境中声明的变量集合记作 $dom(\Gamma)$
-   $\mathfrak{J}$ 表示具体的断言，其所有自由变量均在 $\Gamma$ 中声明

### 类型判断

最核心的判断形式是类型判断，记作
$$
\Gamma\vdash M:A
$$
表示在环境 $\Gamma$ 下，项 $M$ 的类型为 $A$。如：

-   $true$ 的类型为 $Bool$，记作 $\empty\vdash true : Bool$
-   $x+1$ 的类型为 $Nat$，前提是 $x$ 的类型为 $Nat$，记作 $\empty, x : Nat\vdash x+1 : Nat$

一个常见的判断是断言一个环境是**良构的**（Well-formed），即已被正确构造：
$$
\Gamma\vdash\diamond
$$

## 类型规则

类型规则通常以如下形式给出：

-   上方列出若干前提判断 $\Gamma_i\vdash\mathfrak{J}_i$ （前提数目可为零）
-   下方写出结论判断 $\Gamma\vdash\mathfrak{J}$
-   每条规则都有名称

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202502020212846.png" alt="类型规则" style="zoom:60%;" />

### 规则的作用

类型规则用以从已知有效的判断推出新的判断，通过这样的链式推理构造出整个推导树。

-   数字规则：规定在任一良构环境 $\Gamma\vdash\diamond$ 下，任何数字都是 $Nat$ 类型的表达式

-   加法规则：规定若 $M$ 和 $N$ 均表示自然数，则 $M+N$ 表示自然数，且环境 $\Gamma$ 对 $M$、$N$ 和 $M+N$ 一致传递

    <img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202502020217876.png" alt="数字规则·加法规则" style="zoom:60%;" />

-   空环境规则： 规定空环境没有前提判断，且是良构的
    $$
    (Env\ \empty) \\\\
    \frac{}{\empty\vdash\diamond}
    $$
    

类似上述的一组类型规则就可构成一个形式化类型系统。

## 类型推导

**推导**（Derivation）是一棵由判断构成的树：叶子在顶部、根在底部，每个判断均由其直接上方的判断通过某条类型规则得到。一个判断若能作为推导树的根节点获得，则称其为**有效判断**，代表能通过正确应用类型规则得到。

通过已有规则可构造如下推导，如：

![推导树](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202502031734530.png)

是一个有效判断，每一步的结论旁标注了所用规则。

## 良好类型化与类型推断

### 良好类型化定义

在环境 $\Gamma$ 下，若存在某类型 $A$ 使得：
$$
\Gamma\vdash M:A
$$


成立，则称项 $M$ 为**良好类型化**（Well-typed）。

### 类型推断问题

指为某项发现一个推导从而确定其类型的过程。如在规则 Env $\empty$、Val $n$ 和 Val $+$ 构成的系统中，可以在空环境下为 $1+2$ 推断出类型 $Nat$。

### 类型系统对类型推断的影响

添加规则 $\Gamma\vdash true:Bool$ 后，项 $1+true$ 无法推断出类型，因为没有规则支持自然数与布尔值相加。

若进一步添加规则：

-   前提：$\Gamma\vdash M:Nat$ 和 $\Gamma\vdash N:Bool$
-   结论：$\Gamma\vdash M+N:Nat$（如将 $true$ 解释为 $1$）

则 $1+true$ 可被类型化，这表明类型推断问题对具体类型系统非常敏感，算法实现的难易取决于类型系统的设计。

### 实践中的类型推断

-   对于显式类型化的语言（如 C），类型推断较为容易
-   对于隐式类型化的语言（如 ML）以及涉及多态性（Polymorphism）的情况，类型推断则更为复杂

## 类型健全性

**类型健全性**（Type soundness）确保良好类型化的程序在执行过程中不会出现运行时错误。

### 与语义的联系

-   **指称语义**（Denotational semantics）：若 $\empty\vdash M : A$ 有效，则应满足 $[M] \in [A]$，即 $M$ 的值属于类型 $A$ 所指称的值集合。
-   **操作语义**（Operational semantics）：若 $\empty\vdash M:A$ 有效，且 $M$ 归约为 $M’$，则有 $\empty\vdash M’: A$

在这两种情况下，类型健全性定理均断言：良好类型化的程序在计算时不会产生执行错误，联系了类型系统与程序语义之间的关系。

# 3 一阶类型系统

## System $F_1$

**一阶类型系统**（First-order type systems）用于大多数过程式语言，缺乏**类型参数化**（Type parameterization）与**类型抽象**（Type abstraction），但包含**高阶函数**（Higher order function）。

无类型 λ 演算中的 λ 抽象 $\lambda x.M$ 添加类型注释后变为 $\lambda x:A.M$ 构成了 $F_1$。

![Table 2. Syntax of F1](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202502031752304.png)

![Table 3. Judgments for F1](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250212182621524.png)

### $F_1$ 的基本构造

-   函数类型：$A\rightarrow B$ 表示参数类型为 $A$、结果类型为 $B$ 的函数
-   基本类型：由集合 $Basic$ 定义，任一 $K\in Basic$ 均为基本类型
-   判断规则和环境扩展规则：(Env $\empty$)、(Env $x$)、(Val $x$)、(Val Fun)、(Val Appl)

![Table 4. Rules for F1](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250212183319096.png)

![Table 5. A derivation in F1](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250212183803328.png)

## 基本数据类型

### Unit 类型

-   类型：$Unit$
-   唯一值：$unit$
-   用作占位，填充不重要的参数或结果（类似某些语言中的 $Void$ 或 $Null$）

![Table 6. Unit Type](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250212184114773.png)

### Bool 类型

-   类型：$Bool$
-   值：$true$ 和 $false$
-   条件表达式形式： $if_A\ M\ N_1\ N_2$ 要求 $N_1$ 与 $N_2$ 均具有相同类型 $A$（类型提示 $if_A$ 用于辅助类型检查）

![Table 7. Bool Type](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250212184425363.png)

### Nat 类型

-   类型：$Nat$
-   构造器：$0$ 和 $succ$
-   运算原语：通过 $pred$ 与 $isZero$ 实现

![Table 8. Nat Type](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250212184558667.png)

## 结构化类型

### 乘积类型（Product types）

-   定义：$A_1 \times A_2$ 表示一对值，其中第一分量类型为 $A_1$，第二分量类型为 $A_2$
-   提取操作：投影操作 $first$ 与 $second$，或使用 $with$ 语句对对进行分解

![Table 9. Product Types](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250212185255193.png)

### 联合类型（Union types）

-   定义：$A_1 + A_2$ 表示两种类型的并集

-   注入操作：

    -   $inLeft$ 为 $left$ 标记注入 $A_1$ 的值

    -   $inRight$ 为 $right$ 标记注入 $A_2$ 的值

-   检测与提取操作：$isLeft$、$isRight$、$asLeft$ 和 $asRight$

-   统一处理：$case$ 语句 $case\ M\ of\ x_1\rightarrow N_1 \mid x_2\rightarrow N_2$

-   示例：

    -   $Int$ 可定义为 $Nat+Nat$

    -   枚举类型 $\{red,green,blue\}$ 可定义为 $Variant(red:Unit,  green:Unit,  blue:Unit)$

![Table 10. Union Types](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250212185810926.png)

### 记录类型（Record types）

-   表示带标签的乘积类型，组件顺序无关

-   $with$ 语句在记录类型中的推广见 (Val Record With)，将记录中标签如 $l_1, \cdots, l_n$ 的分量分别绑定到变量 $x_1, \cdots, x_n$ 中
-   示例：$A_1 \times A_2$ 可定义为 $Record(first:A_1,second:A_2)$

![Table 11. Record Types](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250212222635521.png)

### 变体类型（Variant types）

-   定义：具名的不相交联合类型，语法上在组件重新排列下等价
-   构造操作：
    -   $is\ l$ 构造推广了 $isLeft$ 和 $isRight$
    -   $as\ l$ 构造推广了 $asLeft$ 和 $asRight$
-   多分支 case 语句可替代上述操作

![Table 12. Variant Types](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250212222643726.png)

## 可变类型与数组

### 引用类型（Reference types）

-   定义：$Ref(A)$ 表示一个可变单元，其中存储类型为 $A$ 的值

-   主要操作：

    -   分配新单元：(Val Ref)
    -   解引用：(Val Deref)

    -   赋值：(Val Assign)

-   赋值操作结果为 $unit$（强调副作用）

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250212223039934.png" alt="Table 13. Reference Types" style="zoom: 67%;" />

### 数组（Array）

-   数组类型：$Array(A)$ 表示一种固定长度、元素类型为 $A$ 的数组
-   构造及操作依赖引用、算术原语和局部 $let$ 声明
-   数组操作的类型规则可根据乘积、函数与引用类型的规则推导

![Table 14. An implementation of arrays](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250212223213572.png)

![Table 15. Array Types](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250213222237929.png)

## 递归类型

### 基本构造

-   **递归类型**（Recursive types）允许类型定义中自我引用，用于描述无限或递归数据结构（如列表、树）。

-   形式表示为 $\mu X. A$，其中 $X$ 是类型变量，在 $A$ 中出现，表示**不动点**（Fixed point），即 $X = A$

### 展开与折叠操作

-   $Unfold$（展开）：将递归类型转换为其展开形式，即 $[\mu X.A/X]A$ 类似于解包递归结构
-   $Fold$（折叠）：将已展开的结构打包回递归类型 $\mu X.A$

-   两者满足互逆关系： $unfold(fold(M))=M$ 和 $fold(unfold(M'))=M'$

-   这些操作在类型检查时明确标识递归边界，通常不在运行时产生额外开销

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250213222248077.png" alt="Table 16. Recursive Types" style="zoom:67%;" />

### 列表类型
-   定义： $List_A = \mu X. Unit + (A \times X)$

-   $Unit$ 表示空列表（$nil$）
-   $A \times X$ 表示非空列表，由一个元素（类型为 $A$）与剩余列表（类型为 $X$）组成（$cons$ 构造子），以及分析器 $listCase$

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250213222400440.png" alt="Table 17. List Types" style="zoom:67%;" />

### 编码递归与无类型 λ 演算

-   递归类型与函数类型结合时，能够隐含实现值层递归
-   对任意类型 $A$，可定义发散元素 $\bot_A$ 和不动点算子 $Y_A$
-   无类型 λ 演算可编码于类型化演算中

![Table 18. Encoding of Divergence and Recursion via Recursive Types](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250213223027682.png)

![Table 19. Encoding the Untyped λ-calculus via Recursive Types](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250213223023871.png)

### 类型等价

在递归类型下，仅当两个递归类型在结构上完全相同（考虑绑定变量重命名）时视为等价，无需额外判断规则。

# 4 命令式语言的一阶类型系统

命令与表达式的区分：

-   命令（Commands）不产生值，而表达式（Expressions）产生值
-   尽管可以将命令简化为表达式（通过赋予 Unit 类型），但保持二者自然区分更符合直观语义

下表给出了一个未类型化的命令式语言的语法。该语言允许研究**声明**（Declaration）的类型规则，并对**过程**（Procedure）和**数据类型**进行初步处理。

![Table 20. Syntax of the imperative language](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250213223627583.png)

### 判断规则

命令和表达式分别有独立判断规则：

-   $\Gamma\vdash C$ 用于命令
-   $\Gamma\vdash E : A$ 用于表达式

这两个判断规则对应于早期系统 $F_1$ 中的单一判断规则 $\Gamma\vdash M : A$。

对于声明的判断规则为 $\Gamma\vdash D \therefore S$，其中**签名**（Signature） $S$ 本质上是声明的类型。

-   如一个简单签名可以为 $x : Nat$，与之匹配的声明形式为 `var x : Nat = 3`
-   在更一般的情况中，签名将由多个组件构成，类似于或等同于环境 $\Gamma$

![Table 21. Judgments for the imperative language](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250213224315408.png)

### 类型规则

类型规则分为多个类别：

-   (Env ...)、(Type ...)、(Expr ...)：直接变体于系统 $F_1$ 中的规则
-   (Decl ...)：专门处理声明的类型检查
-   (Comm ...)：专门处理命令的类型检查，其中 (Comm Block) 将签名转换为环境的一部分，以便检查块（Block）的主体

![Table 22. Type rules for the imperative language](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250213224551267.png)

# 5 Second-order Type Systems

Many modern languages include constructs for type parameters, type abstraction, or both. Type parameters can be found in the module system of several languages, where a generic module, class, or interface is parameterized by a type to be supplied later. Planned extensions of Java and C# use type parameters at the class and interface level. (C++ templates are similar to type parameters, bur are actually a form of macro-expansion, with very different properties.) Polymorphic languages such as ML and Haskell use type parameters more pervasively, at the function level. Type abstraction can be found in conjunction with modules, in the form of opaque types in interfaces, as in Modula-2 and Modula-3. Languages such as CLU use type abstraction at the data level, to obtain abstract data types. These advanced features can be modeled by so-called second-order type systems.

Second-order type systems extend first-order type systems with the notion of $type\ parameters$. A new kind of term, written $\lambda X.M$, indicates a program $M$ that is parameterized with respect to a type variable $X$ that stands for an arbitrary type. For example, the identity function for a fixed type $A$, written $\lambda x:A.x$, can be turned into a parametric identity function by abstracting over $A$ and writing $id \overset{\triangle}{=} \lambda X.\lambda x:X.x$. One can then instantiate such a parametric function to any given type $A$ by a type instantiation, written $id\ A$, which produces back $\lambda x:A.x$. 

Corresponding to the new terms $\lambda X.M$ we need new $universally\ quantified$ types. The type of a term such as $\lambda X.M$ is written $\forall X.A$, meaning that forall $X$, the body $M$ has type $A$ (here $M$ and $A$ may contain occurrences of $X$). For example, the type of the parametric identity is $id : \forall X.X\rightarrow X$, since forall $X$, the type instantiation $id\ X$ has type $X\rightarrow X$.

The pure second-order system $F_2$ (Table 23) is based exclusively on type variables, function types, and quantified types. Note that we are dropping the basic types $K$, since we can now use type variables as the basic case. It turns out that virtually any basic type of interest can be encoded within $F_2$. Similarly, product types, sum types, existential types, and some recursive types, can be encoded within $F_2$: polymorphism has an amazing expressive power. Thus there is little need, technically, to deal with these type constructions directly.

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214194606242.png" alt="Table 23. Syntax of F2" style="zoom: 60%;" />

Free variables for $F_2$ types and terms can be defined in the usual fashion; suffice it to say that $\forall X.A$ binds $X$ in $A$ and $\lambda X.M$ binds $X$ in $M$. An interesting aspect of $F_2$ is the substitution of a type for a type variable that is carried out in the type rule for type instantiation, (Val Appl2).

![Table 24. Judgments for F2](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214194739730.png)

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214194852507.png" alt="Table 25. Rules for F2" style="zoom: 60%;" />

The judgments for $F_2$ (Table 24) are the same ones as for $F_1$, but the environments are richer. With respect to $F_1$, the new rules (Table 25), are: (Env X), which adds a type variable to the environment; (Type Forall), which constructs a quantified type $\forall X.A$ from a type variable $X$ and a type $A$ where $X$ may occur; (Val Fun2), which builds a polymorphic abstraction; and (Val Appl2), which instantiates a polymorphic abstraction to a given type, where $[B/X]A$ is the substitution of $B$ for all the free occurrences of $X$ in $A$. For example, if $id$ has type $\forall X.X\rightarrow X$ and $A$ is a type, then by (Val Appl2) we have that $id\ A$ has type $[A/X](X\rightarrow X)\equiv A\rightarrow A$. As a simple but instructive exercise, the reader may want to build the derivation for $id(\forall X.X\rightarrow X)(id)$.

As extensions of $F_2$ we could adopt all the first-order constructions that we already discussed for $F_1$. A more interesting extension to consider is $existentially\ quantified$ types, also known as type abstractions:

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214195543697.png" alt="Table 26. Existential types" style="zoom:67%;" />
To illustrate the use of existentials, we consider an abstract type for booleans. As we said earlier, booleans can be represented as the type $Unit+Unit$. We can now show how to hide this representation detail from a client who does not care how booleans are implemented, but who wants to make use of $true$, $false$ and $cond$ (conditional). We first define an interface for such a client to use,

![BoolInterface](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214195952333.png)

This interface declares that there exists a type $Bool$ (without revealing its identity) that supports the operations $true$, $false$ and $cond$ of appropriate types. The conditional is parameterized with respect to its result type $Y$, which may vary depending of the context of usage.

Next we define a particular implementation of this interface; one that represents $Bool$ as $Unit+Unit$, and that implements the conditional via a case statement. The boolean representation type and the related boolean operations are packaged together by the pack construct.

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214200143379.png" alt="boolModule" style="zoom:67%;" />

Finally, a client could make use of this module by opening it, and thus getting access to an abstract name $Bool$ for the boolean type, and a name $boolOp$ for the record of boolean operations. These names are used in the next example for a simple computation that returns a natural number. (The computation following $in$ is, essentially, if $boolOp.true$ then 1 else 0.)

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214200631366.png" alt="open_nat boolModule" style="zoom:67%;" />

The reader should verify that these examples typecheck according to the rules previously given. Note the critical third assumption of (Val Open), which implies that the result type $B$ cannot contain the variable $X$. That assumption forbids writing, for example, $boolOp.true$ as the body of $open$ (following $in$) in the previous example, since the result type would then be the variable $Bool$. Because of that third assumption, the abstract name of the representation type ($Bool$) cannot escape the scope of $open$, and therefore values having the representation type cannot escape either. A restriction of this kind is necessary, otherwise the representation type might become known to clients.

# 6 Subtyping

Typed object-oriented languages have particularly interesting and complex type systems. There is little consensus about what characterizes these languages, but at least one feature is almost universally present: subtyping. Subtyping captures the intuitive notion of inclusion between types, where types are seen as collections of values. An element of a type can be considered also as an element of any of its supertypes, thus allowing a value (object) to be used flexibly in many different typed contexts.

When considering a subtyping relation, such as the one found in object-oriented programming languages, it is customary to add a new judgment $\Gamma\vdash A <: B$ stating that $A$ is a subtype of $B$ (Table 27). The intuition is that any element of $A$ is an element of $B$ or, more appropriately, any program of type $A$ is also a program of type $B$.

One of the simplest type systems with subtyping is an extension of $F_1$ called $F_{1<:}$. The syntax of $F_1$ is unchanged, except for the addition of a type $Top$ that is a supertype of all types. The existing type rules are also unchanged. The subtyping judgment is independently axiomatized, and a single type rule, called subsumption, is added to connect the typing judgment to the subtyping judgment. 

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214201319026.png" alt="Table 27. Judgments for type systems with subtyping" style="zoom:60%;" />

The subsumption rule states that if a term has type $A$, and $A$ is a subtype of $B$, then the term also has type $B$. That is, subtyping behaves very much like set inclusion, when type membership is seen as set membership.

The subtyping relation in Table 28 is defined as a reflexive and transitive relation with a maximal element called $Top$, which is therefore interpreted as the type of all well typed terms. 

The subtype relation for function types says that $A\rightarrow B$ is a subtype of $A'\rightarrow B'$ if $A'$ is a subtype of $A$, and $B$ is a subtype of $B'$. Note that the inclusion is inverted (contravariant) for function arguments, while it goes in the same direction (covariant) for function results. Simpleminded reasoning reveals that this is the only sensible rule. A function $M$ of type $A\rightarrow B$ accepts elements of type $A$; obviously it also accepts elements of any subtype $A'$ of $A$. The same function $M$ returns elements of type $B$; obviously it returns elements that belong to any supertype $B'$ of $B$. Therefore, any function $M$ of type $A\rightarrow B$, by virtue of accepting arguments of type $A'$ and returning results of type $B'$, has also type $A'\rightarrow B'$. The latter is compatible with saying that $A\rightarrow B$ is a subtype of $A'\rightarrow B'$.

In general, we say that a type variable occurs contravariantly within another type of $F_1$, if it always occurs on the left of an odd number of arrows (double contravariance equals covariance). For example, $X\rightarrow Unit$ and ($Unit\rightarrow X)\rightarrow Unit$ are contravariant in $X$, whereas $Unit\rightarrow X$ and $(X\rightarrow Unit)\rightarrow X$ are covariant in $X$.

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214202424285.png" alt="Table 28. Additional rules for F1 Subtyping" style="zoom:67%;" />

Ad hoc subtyping rules can be added on basic types, such as $Nat <: Int$.

All of the structured types we considered as extensions of $F_1$ admit simple subtyping rules; therefore, these structured types can be added to $F_{1<:}$ as well (Table 29). Typically, we need to add a single subtyping rule for each type constructor, taking care that the subtyping rule is sound in conjunction with subsumption. The subtyping rules for products and unions work component-wise. The subtyping rules for records and variants operate also lengthwise: a longer record type is a subtype of a shorter record type (additional fields can be forgotten by subtyping), whereas a shorter variant type is a subtype of a longer variant type (additional cases can be introduced by subtyping). For example,

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214202817499.png" alt="WorkingAge" style="zoom:60%;" />

Then,

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214202854784.png" alt="WorkingAge" style="zoom:60%;" />

Reference types do not have any subtyping rule: $Ref(A) <: Ref(B)$ holds only if $A=B$ (in which case $Ref(A) <: Ref(B)$ follows from reflexivity). This strict rule is necessary because references can be both read and written, and hence behave both covariantly and contravariantly. For the same reason, array types have no additional subtyping rules.

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214203314467.png" alt="Table 29. Additional rules for extensions of F1 Subtyping" style="zoom:67%;" />

As was the case for $F_1$, a change to the structure of environments is necessary when considering recursive types. This time, we must add bounded variables to environments (Table 30). Variables bound by $Top$ correspond to our old unconstrained variables. The soundness of the subtyping rule (Sub Rec) for recursive types (Table 31) is not obvious, but the intuition is fairly straightforward. To check whether $\mu X.A <: \mu Y.B$ we assume $X<:Y$ and we check $A <: B$; the assumption helps us when finding matching occurrences of $X$ and $Y$ in $A$ and $B$, as long as they are in covariant contexts. A simpler rule asserts that $\mu X.A <: \mu X.B$ whenever $A <: B$ for any $X$, but this rule is unsound when $X$ occurs in contravariant contexts (e.g., immediately on the left of an arrow).

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214203849006.png" alt="Table 30. Environments with bounded variables" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214203924984.png" alt="Table 31. Subtyping recursive types" style="zoom:67%;" />

The bounded variables in environments are also the basis for the extension of $F_2$ with subtyping, which gives a system called $F_{2<:}$ (Table 32). In this system the term $\lambda X<:A.M$ indicates a program $M$ parameterized with respect to a type variable $X$ that stands for an arbitrary subtype of $A$. This is a generalization of $F_2$, since the $F_2$ term $\lambda X.M$ can be represented as $\lambda X<:Top.M$. Corresponding to the terms $\lambda X<:A.M$, we have bounded type quantifiers of the form $\forall X<:A.B$.

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214205627386.png" alt="Table 32. Syntax of F2 Subtyping" style="zoom: 60%;" />

Scoping for $F_{2<:}$ types and terms is defined similarly to $F_2$, except that $\forall X<:A.B$ binds $X$ in $B$ but not in $A$, and $\lambda X<:A.M$ binds $X$ in $M$ but not in $A$. 

The type rules for $F_{2<:}$ consist of most of the type rules for $F_{1<:}$ (namely, (Env $\empty$), (Env $x$), (Type Top), (Type Arrow), (Sub Refl), (Sub Trans), (Sub Top), (Sub Arrow), (Val Subsumption), (Val $x$), (Val Fun), and (Val Appl)), plus the rules for bounded variables (namely, (Env $X<:$), (Type $X<:$), and (Sub $X<:$)), and the ones listed in Table 33 for bounded polymorphism.

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214210102746.png" alt="Table 33. Rules for bounded universal quantifiers" style="zoom:67%;" />

As for $F_2$, we do not need to add other type constructions to $F_{2<:}$, since all of the common ones can be expressed within it (except for recursion). Moreover, it turns out that the encodings used for $F_2$ satisfy the expected subtyping rules. For example, it is possible to encode bounded existential types so that the rules described in Table 34 are satisfied. The type $\exist X<:A.B$ represent a partially abstract type, whose representation type $X$ is not completely known, but is known to be a subtype of $A$. This kind of partial abstraction occurs in some languages based on subtyping (e.g., in Modula-3).

Some nontrivial work is needed to obtain encodings of record and variant types in $F_{2<:}$ that satisfy the expected subtyping rules, but even those can be found.

# 7 Equivalence

For simplicity, we have avoided describing certain judgments that are necessary when type systems become complex and when one wishes to capture the semantics of programs in addition to their typing. We briefly discuss some of these judgments.

A type equivalence judgment, of the form $\Gamma\vdash A = B$, can be used when type equivalence is nontrivial and requires precise description. For example, some type systems identify a recursive type and its unfolding, in which case we would have $\Gamma\vdash\mu X.A = [\mu X.A/X]A$ whenever $\Gamma\vdash\mu X.A$.

As another example, type systems with type operators $\lambda X.A$ (functions from types to types) have a reduction rule for operator application of the form $\Gamma\vdash  (\lambda X.A) B = [A/X]B$. The type equivalence judgment is usually employed in a retyping rule stating that if $\Gamma\vdash M : A$ and $\Gamma\vdash A = B$ then $\Gamma\vdash M : B$.

A term equivalence judgment determines which programs are equivalent with respect to a common type. It has the form $\Gamma\vdash M = N : A$. For example, with appropriate rules we could determine that $\Gamma\vdash 2+1 = 3 : Int$. The term equivalence judgment can be used to give a typed semantics to programs: if $N$ is an irreducible expression, then we can consider N as the resulting value of the program $M$.

# 8 Type inference

Type inference is the problem of finding a type for a term within a given type system, if any type exists. In the type systems we have considered earlier, programs have abundant type annotations Thus, the type inference problem often amounts to little more than checking the mutual consistency of the annotations. The problem is not always trivial but, as in the case of $F_1$, simple typechecking algorithms may exist.

A harder problem, called typability or type reconstruction, consists in starting with an untyped program $M$, and finding an environment $\Gamma$, a type-annotated version $M'$ of $M$, and a type $A$ such that $A$ is a type for $M'$ with respect to $\Gamma$. (A type-annotated program $M'$ is simply one that stripped of all type annotations reduces back to $M$.) The type reconstruction problem for the untyped λ-calculus is solvable within $F_1$ by the Hindley-Milner algorithm used in ML; in addition, that algorithm has the property of producing a unique representation of all possible $F_1$ typings of a λ-term. The type reconstruction problem for the untyped λ-calculus, however, is not solvable within $F_2$. Type reconstruction within systems with subtyping is still largely an open problem, although special solutions are beginning to emerge.

We concentrate here on the type inference algorithms for some representative systems: $F_1$, $F_2$, and $F_{2<:}$. The first two systems have the unique type property: if a term has a type it has only one type. In $F_{2<:}$ there are no unique types, simply because the subsumption rule assigns all of the supertypes of a type to any term that has that type. However, a minimum type property holds: if a term has a collection of types, that collection has a least element in the subtype order. The minimum type property holds for many common extensions of $F_{2<:}$ and of $F_{1<:}$ but may fail in the presence of ad-hoc subtypings on basic types.

## The type inference problem

In a given type system, given an environment $\Gamma$ and a term $M$ is there a type $A$ such that $\Gamma\vdash M: A$ is valid? The following are examples:

- In $F_1$, given $M\equiv\lambda x:K.x$ and any well-formed $\Gamma$ we have that $\Gamma\vdash M : K\rightarrow K$. 
- In $F_1$, given $M\equiv\lambda\equiv x:K.y(x)$ and $\Gamma\equiv\Gamma', y:K\rightarrow K$ we have that $\Gamma\vdash M : K\rightarrow K$.
- In $F_1$, there is no typing for $\lambda x:B.x(x)$, for any type $B$. 
- However, in $F_{1<:}$ there is the typing $\Gamma\vdash\lambda x:Top\rightarrow B.x(x) : (Top\rightarrow B)\rightarrow B$, for any type $B$, since $x$ can also be given type $Top$.
- Moreover, in $F_1$ with recursive types, there is the typing $\Gamma\vdash\lambda x:B.(unfold_B\ x)(x) : B\rightarrow B$, for $B\equiv\mu X.X\rightarrow X$, since $unfold_B\ x$ has type $B\rightarrow B$.
- Finally, in $F_2$ there is the typing $\Gamma\vdash\lambda x:B. x(B)(x) : B\rightarrow B$, for $B\equiv\forall X.X\rightarrow X$, since $x(B)$ has type $B\rightarrow B$.

(An alternative formulation of the type inference problem requires $\Gamma$ to be found, instead of given. However, in programming practice one is interested only in type inference for programs embedded in a complete programming context, where $\Gamma$ is therefore given.)

We begin with the type inference algorithm for pure $F_1$, given in Table 35. The algorithm can be extended in straightforward ways to all of the first-order type structures studied earlier. This is the basis of the typechecking algorithms used in Pascal and all similar procedural languages.

The main routine $Type(\Gamma, M)$, takes an environment $\Gamma$ and a term $M$ and produces the unique type of $M$, if any. The instruction $fail$ causes a global failure of the algorithm: it indicates a typing error. In this algorithm, as in the ones that follow, we assume that the initial environ ment parameter $\Gamma$ is well formed so as to rule out the possibility of feeding invalid environments to internal calls. (For example, we may start with the empty environment when checking a full program.) In any case, it is easy to write a subroutine that checks the well formedness of an environment, from the code we provide. The case for $\lambda x:A.M$ should have a restriction requiring that $x\notin dom(\Gamma)$, since $x$ is used to extend $\Gamma$. However, this restriction can be easily sidestepped by renaming, e.g., by making all binders unique before running the algorithm. We omit this kind of restrictions from Tables 35, 36, and 37.

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214213949909.png" alt="Table 35. Type inference algorithm for F1" style="zoom:60%;" />

As an example, let us consider the type inference problem for term $\lambda z:K.y(z)$ in the environment $\empty, y:K\rightarrow K$, for which we gave a full $F_1$ derivation in section 3. The algorithm proceeds as follows:

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214214131314.png" alt="Type inference" style="zoom:60%;" />

The type inference algorithm for $F_2$ (Table 36) is not much harder than the one for $F_1$, but it requires a subroutine $Good(\Gamma, A)$ to verify that the types encountered in the source program are well formed. This check is necessary because types in $F_2$ contain type variables that might be unbound. A substitution subroutine must also be used in the type instantiation case, $M\ A$.

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214214344019.png" alt="Table 36. Type inference algorithm for F2" style="zoom:60%;" />

The type inference algorithm for $F_{2<:}$, given in Table 37, is more subtle. The subroutine $Subtype(\Gamma, A, B)$ attempts to decide whether $A$ is a subtype of $B$ in $\Gamma$, and is at first sight straight-forward. It has been shown, though, that Subtype is only a semialgorithm: it may diverge on certain pairs $A,B$ that are not in subtype relation. That is, the typechecker for $F_{2<:}$ may diverge on ill typed programs, although it will still converge and produce a minimum type for well typed programs. More generally, there is no decision procedure for subtyping: the type system for $F_{2<:}$ is undecidable. Several attempts have been made to cut $F_{2<:}$ down to a decidable subset; the simplest solution at the moment consists in requiring equal quantifiers bounds in (Sub Forall<:). In any case, the bad pairs $A,B$ are extremely unlikely to arise in practice. The algorithm is still sound in the usual sense: if it finds a type, the program will not go wrong. The only troublesome case is in the subtyping of quantifiers; the restriction of the algorithm to $F_{1<:}$ is decidable and produces minimum types.

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20250214214819956.png" alt="Table 37. Type inference algorithm for F2 Subtyping" style="zoom:60%;" />

$F_{2<:}$ provides an interesting example of the anomalies one may encounter in type inference. The type inference algorithm given above is theoretically undecidable but is practically applicable. It is convergent and efficient on virtually all programs one may encounter; it diverges only on some ill typed programs, which should be rejected anyway. Therefore, $F_{2<:}$ sits close to the boundary between acceptable and unacceptable type systems, according to the criteria enunciated in the introduction.

# 9 Summary and Research Issues

## What we learned

Natural questions for a beginner programmer are: What is an error? What is type safety? What is type soundness? (perhaps phrased, respectively, as Which errors will the computer tell me about? Why did my program crash? Why does the computer refuse to run my program?). The answers, even informal ones, are surprisingly intricate. We have paid particular attention to the distinction between type safety and type soundness, and we have reviewed the varieties of static checking, dynamic checking, and absence of checking for program errors in various kinds of languages.

The most important lesson to remember from this chapter is the general framework for formalizing type systems. Understanding type systems, in general terms, is as fundamental as understanding BNF(Backus-Naur Form): it is hard to discuss the typing of programs without the precise language of type systems, just as it is hard to discuss the syntax of programs without the precise language of BNF. In both cases, the existence of a formalism has clear benefits for language design, compiler construction, language learning, and program understanding. We described the formalism of type systems, and how it captures the notions of type soundness and type errors. 

Armed with formal type systems, we embarked on the description of an extensive list of program constructions and of their type rules. Many of these constructions are slightly abstracted versions of familiar features, whereas others apply only to obscure corners of common languages. In both cases, our collection of typing constructions is meant as a key for interpreting the typing features of programming languages. Such an interpretation may be nontrivial, particularly because most language definitions do not come with a type system, but we hope to have provided sufficient background for independent study. Some of the advanced type constructions will appear, we expect, more fully, cleanly, and explicitly in future languages.

In the latter part of the chapter, we reviewed some fundamental type inference algorithms: for simple languages, for polymorphic languages, and for languages with subtyping. These algorithms are very simple and general, but are mostly of an illustrative nature. For a host of pragmatic reasons, type inference for real languages becomes much more complex. It is interesting, though, to be able to describe concisely the core of the type inference problem and some of its solutions.

## Future directions

The formalization of type systems for programming languages, as described in this chapter, evolved as an application of type theory. Type theory is a branch of formal logic. It aims to replace predicate logics and set theory (which are untyped) with typed logics, as a foundation for mathematics.

One of the motivations for these logical type theories, and one of their more exciting applications, is in the mechanization of mathematics via proof checkers and theorem provers. Typing is useful in theorem provers for exactly the same reasons it is useful in programming. The mechanization of proofs reveals striking similarities between proofs and programs: the structuring problems found in proof construction are analogous to the ones found in program construction. Many of the arguments that demonstrate the need for typed programming languages also demonstrate the need for typed logics.

Comparisons between the type structures developed in type theory and in programming are, thus, very instructive. Function types, product types, (disjoint) union types, and quantified types occur in both disciplines, with similar intents. This is in contrast, for example, to structure used in set theory, such as unions and intersections of sets, and the encoding of functions as sets of pairs, that have no correspondence in the type systems of common programming languages.

Beyond the simplest correspondences between type theory and programming, it turns out that the structures developed in type theory are far more expressive than the ones commonly used in programming. Therefore type theory provides a rich environment for future progress in programming languages.

Conversely, the size of systems that programmers build is vastly greater than the size of proofs that mathematicians usually handle. The management of large programs, and in particular the type structures needed to manage large programs, is relevant to the management of mechanical proofs. Certain type theories developed in programming, for example, for object-orientation and for modularization, go beyond the normal practices found in mathematics, and should have something to contribute to the mechanization of proofs.

Therefore, the cross fertilization between logic and programming will continue, within the common area of type theory. At the moment, some advanced constructions used in programming escape proper type-theoretical formalization. This could be happening either because the programming constructions are ill conceived, or because our type theories are not yet sufficiently expressive: only the future will tell. Examples of active research areas are the typing of advanced object-orientation and modularization constructs and the typing of concurrency and distribution.

# Defining Terms

**Abstract type:** A data type whose nature is kept hidden, in such a way that only a predetermined collection of operations can operate on it.

**Contravariant:** A type that varies in the inverse direction from one of its parts with respect to subtyping. The main example is the contravariance of function types in their domain. For example, assume $A<:B$ and vary $X$ from $A$ to $B$ in $X\rightarrow C$; we obtain $A\rightarrow C :> B\rightarrow C$. Thus $X\rightarrow C$ varies in the inverse direction of $X$.

**Covariant:** A type that varies in the same direction as one of its parts with respect to subtyping. For example, assume $A<:B$ and vary $X$ from $A$ to $B$ in $D\rightarrow X$; we obtain $D\rightarrow A <: D\rightarrow B$. Thus $D\rightarrow X$ varies in the same direction as $X$.

**Derivation:** A tree of judgments obtained by applying the rules of a type system.

**Dynamic checking:** A collection of run time tests aimed at detecting and preventing forbidden errors.

**Dynamically checked language:** A language where good behavior is enforced during execution.

**Explicitly typed language:** A typed language where types are part of the syntax.

**First-order type system:** One that does not include quantification over type variables.

**Forbidden error:** The occurrence of one of a predetermined class of execution errors; typically the improper application of an operation to a value, such as $not(3)$.

**Good behavior:** Same as being well behaved.

**Ill typed:** A program fragment that does not comply with the rules of a given type system.

**Implicitly typed language:** A typed language where types are not part of the syntax.

**Judgment:** A formal assertion relating entities such as terms, types, and environments. Type systems prescribe how to produce valid judgments from other valid judgements.

**Polymorphism:** The ability of a program fragment to have multiple types (opposite of monomorphism).

**Safe language:** A language where no untrapped errors can occur.

**Second-order type system:** One that includes quantification over type variables, either universal or existential.

**Static checking:** A collection of compile time tests, mostly consisting of typechecking.

**Statically checked language:** A language where good behavior is determined before execution.

**Strongly checked language:** A language where no forbidden errors can occur at run time (depending on the definition of forbidden error).

**Subsumption:** A fundamental rule of subtyping, asserting that if a term has a type $A$, which is a subtype of a type $B$, then the term also has type $B$.

**Subtyping:** A reflexive and transitive binary relation over types that satisfies subsumption; it asserts the inclusion of collections of values.

**Trapped error:** An execution error that immediately results in a fault.

**Type:** A collection of values. An estimate of the collection of values that a program fragment can assume during program execution.

**Type inference:** The process of finding a type for a program within a given type system.

**Type reconstruction:** The process of finding a type for a program where type information has been omitted, within a given type system.

**Type rule:** A component of a type system. A rule stating the conditions under which a particular program construct will not cause forbidden errors.

**Type safety:** The property stating that programs do not cause untrapped errors.

**Type soundness:** The property stating that programs do not cause forbidden errors.

**Type system:** A collection of type rules for a typed programming language. Same as static type system.

**Typechecker:** The part of a compiler or interpreter that performs typechecking.

**Typechecking:** The process of checking a program before execution to establish its compliance with a given type system and therefore to prevent the occurrence of forbidden errors.

**Typed language:** A language with an associated (static) type system, whether or not types are part of the syntax.

**Typing error:** An error reported by a typechecker to warn against possible execution errors.

**Untrapped error:** An execution error that does not immediately result in a fault.

**Untyped language:** A language that does not have a (static) type system, or whose type system has a single type that contains all values.

**Valid judgment:** A judgment obtained from a derivation in a given type system.

**Weakly checked language:** A language that is statically checked but provides no clear guarantee of absence of execution errors.

**Well behaved:** A program fragment that will not produce forbidden errors at run time.

**Well formed:** Properly constructed according to formal rules.

**Well-typed program:** A program (fragment) that complies with the rules of a given type system.
