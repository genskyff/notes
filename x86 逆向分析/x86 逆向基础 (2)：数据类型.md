# 1 作用域和可变性

在程序中，数据根据作用域可以分为局部量、全局量和静态量等，而根据可变性又可以分为变量和常量。

## 局部变量

局部变量是在函数内部定义的变量，其作用域和生命周期局限于函数内，局部变量分配内存通常会使用栈或寄存器。

局部变量在栈中进行分配，因此函数执行完毕后会释放这些栈。如下表所示，通常用 `sub esp,imm` 或 `push reg` 来给局部变量分配内存，用 `[ebp-imm]` 来寻址，而对参数的寻址通常是 `[ebp+imm]`。因此在逆向中，参数寻址和局部变量寻址很容易区分。编译器在优化模式下，可能会直接用 esp 对参数和局部变量进行寻址。有些编译器会给 esp 加一个负值来分配内存，函数执行完毕后，用 `add esp,imm` 来平衡栈。

|          | 形式 1       | 形式 2        | 形式 3   |
| -------- | ------------ | ------------- | -------- |
| 分配内存 | sub esp, imm | add esp, -imm | push reg |
| 平衡栈   | add esp, imm | sub esp, -imm | pop reg  |

对局部变量来说，先定义的在低地址，后定义的在高地址。在 Windows x64 下，函数在入口申请了预留栈空间和局部变量空间，其中预留栈空间在低地址，局部变量在高地址，而 Linux x64 下则没有预留栈空间。

考虑如下 C 代码：

```c
int sum(int x, int y) {
    int r = x + y;

    return r;
}

int main(void) {
    int a = 1, b;
    printf("%d\n", sum(a, b));

    return 0;
}
```

其汇编代码如下：

```assembly
; int sum(int x, int y)
00091080  push        ebp
00091081  mov         ebp,esp
00091083  push        ecx                       ; 分配内存
; int r = x + y;
00091084  mov         eax,dword ptr [ebp+8]
00091087  add         eax,dword ptr [ebp+0Ch]
0009108A  mov         dword ptr [ebp-4],eax
; return r;
0009108D  mov         eax,dword ptr [ebp-4]
00091090  mov         esp,ebp
00091092  pop         ebp
00091093  ret

; int main(void)
000910A0  push        ebp
000910A1  mov         ebp,esp
000910A3  sub         esp,8                     ; 分配内存
; int a = 1, b;
000910A6  mov         dword ptr [ebp-4],1
; printf("%d\n", sum(a, b));
000910AD  mov         eax,dword ptr [ebp-8]
000910B0  push        eax
000910B1  mov         ecx,dword ptr [ebp-4]
000910B4  push        ecx
000910B5  call        00091080                  ; sum 函数
000910BA  add         esp,8
000910BD  push        eax
000910BE  push        93020h
000910C3  call        00091040                  ; printf 函数
000910C8  add         esp,8
; return 0;
000910CB  xor         eax,eax
000910CD  mov         esp,ebp
000910CF  pop         ebp
000910D0  ret
```

编译器不会自动将局部变量初始化为 0，如果不赋初值，则值是不确定的，为这个区域原来留下的值，可以通过 mov 或者 push 指令来为变量赋值。通常情况下，编译器会使用寄存器来存放局部变量，这样可以提高效率，如果不够用，才会使用栈来存放局部变量。

## 全局变量

全局变量作用于整个程序，在整个程序周期中会一直存在，不会像局部变量在需要时才会分配内存，通常位于 `.data` 或 `.bss` 中，编译器一般会直接把全局变量放到可读写的区域中，若放到只读区域，则是常量。访问全局变量时，会直接使用固定的地址进行寻址，如下：

```assembly
mov eax,dword ptr ds:[004A338Ch]
```

和局部变量不同，如果没有给全局变量赋初值，则编译器会自动将其初始化为 0。和局部变量一样，对全局变量来说，先定义的在低地址，后定义的在高地址。

考虑如下 C 代码：

```c
int gx = 0;

void funcA(void) {
    gx += 1;
}

void funcB(void) {
    gx += 2;
}

int main(void) {
    gx = 1;
    funcA();
    funcB();

    printf("%d\n", gx);

    return 0;
}
```

其汇编代码如下：

```assembly
; void funcB(void)
00D010A0  push        ebp
00D010A1  mov         ebp,esp
; gx += 2;
00D010A3  mov         eax,dword ptr ds:[00D03394h]
00D010A8  add         eax,2
00D010AB  mov         dword ptr ds:[00D03394h],eax
00D010B0  pop         ebp
00D010B1  ret

; int main(void)
00D010C0  push        ebp
00D010C1  mov         ebp,esp
; gx = 1;
00D010C3  mov         dword ptr ds:[00D03394h],1
; funcA();
00D010CD  call        00D01080
; funcB();
00D010D2  call        00D010A0
; printf("%d\n", gx);
00D010D7  mov         eax,dword ptr ds:[00D03394h]  ; gx = 4
00D010DC  push        eax
00D010DD  push        0D03020h
00D010E2  call        00D01040
00D010E7  add         esp,8
; return 0;
00D010EA  xor         eax,eax
00D010EC  pop         ebp
00D010ED  ret
```

可以看到，全局变量并没有分配内存和初始化的操作。

全局变量还能够以外部变量的方式被其它文件访问，将上述 C 代码改成多文件的形式，如下：

文件 `func.h`：

```c
#ifndef FUNC
#define FUNC
void funcA(void);
void funcB(void);
#endif
```

文件 `func.c`：

```c
#include "func.h"

extern int gx;       // 导入外部变量

void funcA(void) {
    gx += 1;
}

void funcB(void) {
    gx += 2;
}
```

文件 `main.c`：

```c
#include "func.h"

int gx = 0;

int main(void) {
    gx = 1;
    funcA();
    funcB();

    printf("%d\n", gx);

    return 0;
}
```

其汇编代码和单文件编译时并无较大差异。需要注意的是，在使用外部变量时需要加上 `extern` 关键字。

## 静态变量

静态变量的声明使用 `static` 关键字，与全局变量类似，都可以直接寻址访问，且在整个程序周期一直存在，但是静态变量的作用域仅限于定义的区域内。静态变量的其中一个作用是如果该函数被多次调用，则可以利用上次静态变量的值，因此静态变量在编译时就必须初始化且只能被初始化一次。

考虑如下 C 代码：

```c
int funcCount(void) {
    static int x = 0;
    x++;

    return x;
}

int main(void) {
    int c = funcCount();
    c = funcCount();
    c = funcCount();

    printf("%d\n", c);

    return 0;
}
```

其汇编代码如下：

```assembly
; int funcCount(void)
00831080  push        ebp
00831081  mov         ebp,esp
; static int n = 0;
; n++;
00831083  mov         eax,dword ptr ds:[00833394h]
00831088  add         eax,1
0083108B  mov         dword ptr ds:[00833394h],eax
; return n;
00831090  mov         eax,dword ptr ds:[00833394h]
00831095  pop         ebp
00831096  ret

; int main(void)
008310A0  push        ebp
008310A1  mov         ebp,esp
008310A3  push        ecx
; int c = funcCount();
008310A4  call        00831080
008310A9  mov         dword ptr [ebp-4],eax
; c = funcCount();
008310AC  call        00831080
008310B1  mov         dword ptr [ebp-4],eax
; c = funcCount();
008310B4  call        00831080
008310B9  mov         dword ptr [ebp-4],eax         ; c = 3
; printf("%d\n", c);
008310BC  mov         eax,dword ptr [ebp-4]
008310BF  push        eax
008310C0  push        833020h
008310C5  call        00831040
008310CA  add         esp,8
; return 0;
008310CD  xor         eax,eax
008310CF  mov         esp,ebp
008310D1  pop         ebp
008310D2  ret
```

可以看到，和全局变量一样，静态变量并没有分配内存和初始化操作，因为在编译时就已经把初值写进了一个固定地址中，如果没有给静态变量赋初值，则编译器会自动将其初始化为 0。

## extern Vs. static

全局变量可以在整个程序运行周期中一直存在，且可以被所有范围的代码访问，因此有较大风险。静态变量虽然和全局变量一样可以在整个程序运行周期中存在，但只能在定义的区域内访问。就算是在同一个文件中定义的全局变量，如果加上了 static 关键字，则不能被其它文件访问，即使加上 extern 关键字，编译后仍会报错，如下：

```c
// 文件 main.c
static int x = 0;

// 文件 func.c
extern int x;       // 报错
```

## 常量

常量就是在初始化后不能改变的量，如果是局部常量，则依然分配在栈空间中，但是如果企图修改，在编译时会报错；如果是全局常量或静态常量，则放到只读数据区域中。

考虑如下 C 代码：

```c
int gx = 1;
const int GX = 2;
static int sgx = 3;
static const int SGX = 4;

int main(void) {
    int x = 5;
    const int X = 6;
    static int sx = 7;
    static const int SX = 8;

    printf("gx = %d, GX = %d, sgx = %d, SGX = %d\n", gx, GX, sgx, SGX);
    printf("x = %d, X = %d, sx = %d, SX = %d\n", x, X, sx, SX);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(void)
00491080  push        ebp
00491081  mov         ebp,esp
00491083  sub         esp,8
; int x = 5;
00491086  mov         dword ptr [ebp-8],5
; const int X = 6;
0049108D  mov         dword ptr [ebp-4],6
; static int sx = 7;
; static const int SX = 8;
; printf("gx = %d, GX = %d, sgx = %d, SGX = %d\n", gx, GX, sgx, SGX);
00491094  mov         eax,dword ptr ds:[00492108h]  ; 全局静态常量 SGX
00491099  push        eax
0049109A  mov         ecx,dword ptr ds:[00493024h]  ; 全局静态变量 sgx
004910A0  push        ecx
004910A1  mov         edx,dword ptr ds:[00492104h]  ; 全局常量 GX
004910A7  push        edx
004910A8  mov         eax,dword ptr ds:[00493020h]  ; 全局变量 gx
004910AD  push        eax
004910AE  push        493050h
004910B3  call        00491040
004910B8  add         esp,14h
; printf("x = %d, X = %d, sx = %d, SX = %d\n", x, X, sx, SX);
004910BB  mov         ecx,dword ptr ds:[00492100h]  ; 静态常量 SX
004910C1  push        ecx
004910C2  mov         edx,dword ptr ds:[00493028h]  ; 静态变量 sx
004910C8  push        edx
004910C9  mov         eax,dword ptr [ebp-4]         ; 常量 X
004910CC  push        eax
004910CD  mov         ecx,dword ptr [ebp-8]         ; 变量 x
004910D0  push        ecx
004910D1  push        49302Ch
004910D6  call        00491040
004910DB  add         esp,14h
; return 0;
004910DE  xor         eax,eax
004910E0  mov         esp,ebp
004910E2  pop         ebp
004910E3  ret
```

仅从汇编的角度看，变量和常量、全局量和静态量无法直接区分。常量看上去可以被修改，但这样做的话编译器会报错。

# 2 整数

## 整数的表示

整数分为无符号和有符号数，这两种数在计算机内部的表示方式不同。

### 无符号数

设一个无符号数 $\vec{x}$ 有 $n$ 位，$[x_{n-1},\ x_{n-2},\ ...,\ x_0]$ 表示这个数的每一个二进制位， 将其转换为十进制整数，则有如下定义：
$$
B2U_n(\vec{x}) = \sum^{n - 1}_{i = 0}{x_i*2^i}
$$

$$
UMax_n = \sum^{n - 1}_{i = 0}{2^i} = 2^n - 1
$$

如二进制数 `1011` 转化为十进制可以表示为：
$$
B2U_4([1011]) = \sum^{3}_{i = 0}{x_i*2^i} = 11
$$

### 有符号数

计算机不能直接表示负数，因此需要设置符号位，并进行编码，现代计算机绝大部分都将补码作为默认编码，此外还有反码和原码。

#### 补码

设一个有符号数 $\vec{x}$ 有 $n$ 位，$[x_{n-1},\ x_{n-2},\ ...,\ x_0]$ 表示这个数的每一个二进制位， 将其转换为十进制整数，则有如下定义：
$$
B2T_n(\vec{x}) = -x_{n-1}*2^{n-1} + \sum^{n - 2}_{i = 0}{x_i*2^i}
$$
$$
TMax_n = \sum^{n - 2}_{i = 0}{2^i} = 2^{n-1} - 1
$$

$$
TMin_n = -2^{n-1}
$$

最高位 $x_{n-1}$ 为符号位，其权值为 -2<sup>n-1</sup>，当最高位为 1 时，表示负数，否则表示正数。

根据上式显然可以得到：
$$
|TMin_n| = |TMax_n| + 1
$$
$$
UMax_n = 2*TMax_n + 1
$$

可以看到，补码是不对称的，且最大的无符号数正好比最大的有符号数大两倍加一。

如二进制数 `1011` 用补码表示为十进制：
$$
B2T_4([1011]) = -2^3 + \sum^{2}_{i = 0}{x_i*2^i} = -5
$$

#### 反码

反码除了最高有效位的权值为 -(2<sup>n-1</sup> - 1) 外，其余与补码相同：
$$
B2O_n(\vec{x}) = -x_{n-1}*(2^{n-1} - 1) + \sum^{n - 2}_{i = 0}{x_i*2^i}
$$
$$
OMax_n = TMax_n = 2^{n-1} - 1
$$

$$
OMin_n = -OMax_n = TMin_n + 1 = -2^{n-1} + 1
$$

可以看到，反码是对称的，且 0 有两种表示，`[00···0]` 时为 `+0`，`[11···1]` 时为 `-0`。

#### 原码

原码的最高有效位是符号位，没有权重，仅用来确定数的正负：
$$
B2S_n(\vec{x}) = (-1)^{x_{n-1}} * \sum^{n - 2}_{i = 0}{x_i*2^i}
$$
$$
SMax_n = TMax_n = 2^{n-1} - 1
$$

$$
SMin_n = -SMax_n = TMin_n + 1 = -2^{n-1} + 1
$$

可以看到，原码也是对称的，且 0 也有两种表示，`[00···0]` 时为 `+0`，`[10···0]` 时为 `-0`。

此外，这三种有符号数的编码对正数都是相同的。

## 整数的识别

整数在汇编中实际上就是一个对应大小的内存空间，当声明一个整数时，编译器将会为其分配空间。

考虑如下 C 代码：

```c
int main(void) {
    char c = 'a';
    short s = 1;
    int i = 2;
    unsigned int ui = 3;
    long l = 4;
    long long ll = 5;

    printf("c = %c, s = %hd, i = %d, ui = %u\n", c, s, i, ui);
    printf("l = %ld, ll = %lld\n", l, ll);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(void)
00971080  push        ebp
00971081  mov         ebp,esp
00971083  sub         esp,1Ch
; char c = 'a';
00971086  mov         byte ptr [ebp-1],61h
; short s = 1;
0097108A  mov         eax,1
0097108F  mov         word ptr [ebp-8],ax
; int i = 2;
00971093  mov         dword ptr [ebp-10h],2
; unsigned int ui = 3;
0097109A  mov         dword ptr [ebp-0Ch],3
; long l = 4;
009710A1  mov         dword ptr [ebp-14h],4
; long long ll = 5;
009710A8  xor         ecx,ecx
009710AA  mov         dword ptr [ebp-1Ch],5
009710B1  mov         dword ptr [ebp-18h],ecx
; printf("c = %c, s = %hd, i = %d, ui = %u\n", c, s, i, ui);
009710B4  mov         edx,dword ptr [ebp-0Ch]
009710B7  push        edx
009710B8  mov         eax,dword ptr [ebp-10h]
009710BB  push        eax
009710BC  movsx       ecx,word ptr [ebp-8]
009710C0  push        ecx
009710C1  movsx       edx,byte ptr [ebp-1]
009710C5  push        edx
009710C6  push        973034h
009710CB  call        00971040
009710D0  add         esp,14h
; printf("l = %ld, ll = %lld\n", l, ll);
009710D3  mov         eax,dword ptr [ebp-18h]
009710D6  push        eax
009710D7  mov         ecx,dword ptr [ebp-1Ch]
009710DA  push        ecx
009710DB  mov         edx,dword ptr [ebp-14h]
009710DE  push        edx
009710DF  push        973020h
009710E4  call        00971040
009710E9  add         esp,10h
; return 0;
009710EC  xor         eax,eax
009710EE  mov         esp,ebp
009710F0  pop         ebp
009710F1  ret
```

实际上不同类型在汇编中的区别仅仅是修饰词的不同，无符号数和有符号数也无法直接区分。还可以看到对于 char，实际上指的是 1 字节的整数，而 long long 在 32 位下和 long 相同，在 64 位上则是 8 字节，如下：

```assembly
; long long ll = 5;
00007FF7E89C10EB  mov         qword ptr [rsp+48h],5
```

可以看到，在 32 位下为 dword 修饰词，而在 64 位下为 qword 修饰词。

## 布尔类型

在 C 中，布尔类型实际上是 1 字节大小的整数，任何 0 值为假，任何非 0 值为真。

考虑如下 C 代码：

```c
int main(void) {
    _Bool a = 6;
    _Bool b = -3;
    _Bool c = 1;
    _Bool d = 0;

    printf("a = %d, b = %d\n", a, b);
    printf("c = %d, d = %d\n", c, d);

    return 0;
}
```

 其汇编代码如下：

```assembly
; int main(void)
005F1080  push        ebp
005F1081  mov         ebp,esp
005F1083  sub         esp,0Ch
; _Bool a = 6;
005F1086  mov         eax,6
005F108B  test        eax,eax
005F108D  jne         005F1098
005F108F  mov         dword ptr [ebp-8],0
005F1096  jmp         005F109F
005F1098  mov         dword ptr [ebp-8],1
005F109F  mov         cl,byte ptr [ebp-8]
005F10A2  mov         byte ptr [ebp-2],cl
; _Bool b = -3;
005F10A5  mov         edx,0FFFFFFFDh
005F10AA  test        edx,edx
005F10AC  jne         005F10B7
005F10AE  mov         dword ptr [ebp-0Ch],0
005F10B5  jmp         005F10BE
005F10B7  mov         dword ptr [ebp-0Ch],1
005F10BE  mov         al,byte ptr [ebp-0Ch]
005F10C1  mov         byte ptr [ebp-1],al
; _Bool c = 1;
005F10C4  mov         byte ptr [ebp-4],1
; _Bool d = 0;
005F10C8  mov         byte ptr [ebp-3],0
; printf("a = %d, b = %d\n", a, b);
005F10CC  movzx       ecx,byte ptr [ebp-1]
005F10D0  push        ecx
005F10D1  movzx       edx,byte ptr [ebp-2]
005F10D5  push        edx
005F10D6  push        5F3030h
005F10DB  call        005F1040
005F10E0  add         esp,0Ch
; printf("c = %d, d = %d\n", c, d);
005F10E3  movzx       eax,byte ptr [ebp-3]
005F10E7  push        eax
005F10E8  movzx       ecx,byte ptr [ebp-4]
005F10EC  push        ecx
005F10ED  push        5F3020h
005F10F2  call        005F1040
005F10F7  add         esp,0Ch
; return 0;
005F10FA  xor         eax,eax
005F10FC  mov         esp,ebp
005F10FE  pop         ebp
005F10FF  ret
```

可以看到，无论给布尔类型赋什么整数，最后都会转化为 0 或 1 来表示逻辑值，当为任何非 0 或 1 的值时，会进行一个判断然后重新赋值。

# 3 浮点数

## 浮点数的表示

 浮点数在计算机内部的表示通常采用 IEEE 754 标准，定义如下：
$$
V = (-1)^s * M *2^E
$$
其中：

-   $s$ 表示符号位，为 0 时表示正数，为 1 时表示负数；
-   $M$ 表示尾数，是一个二进制小数，k 位尾数字段的位表示为 $[m_{k-1},\ m_{k-2},\ ...,k_0]$；
-   $E$ 表示阶码，作用为对浮点数加权，n 位阶码字段的位表示为 $[e_{n-1},\ e_{n-2},\ ...,\ e_0]$。

这三种字段的构成如下图所示，在 float 和 double 中符号位字段长度为 1 位，尾数字段分别为 23 位和 52 位，阶码字段分别为 8 位和 11 位。

![浮点数表示](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109182328467.png)

根据阶码的值，可以分成三种不同的情况：

-   阶码字段的位不全为 0 或 1，则表示一个规格化的值，在这种情况下 $E = e - Bias$，其中 $e$ 是以 n 位阶码字段表示的无符号整数，$Bias$ 是一个值为 2<sup>n-1</sup> 的偏置值，尾数字段的范围是 1 ≤ M < 2。可以通过调整阶码，来调整浮点数的精度。
-   阶码字段的位全为 0，表示一个非规格化的值，当尾数字段全为 0 时，符号字段为 0 表示 `+0.0`，符号字段为 1 表示 `-0.0`。当尾数字段不全为 0 时，表示一个非常小的数。
-   阶码字段的位全为 1，当尾数字段全为 0 时表示 `Inf`，不全为 0 时表示 `NaN`。

在有些编译器下，支持使用 long double 的长双精度浮点数，但其标准不一，在有些编译器下将使用 80 位的扩展双精度处理，有些使用 96 或 128 位，有些则保持 64 位不变。多出来的位数若用于尾数，则会提高精度，若用于阶码，则会扩大范围。

### 舍入

绝大部分情况下，计算机无法精确表示浮点数。如有某特定存储格式只允许 3 个小数位，那么该格式就不能保存形如 1.0101 的数值。

浮点数可以在四种舍入方法中进行选择：

-   舍入到最接近的偶数：舍入结果最接近无限精确的结果，如果有两个值近似程度相同，则取偶数值。

-   向 -∞ 舍入：舍入结果小于或等于无限精确结果。

-   向 +∞ 舍入：舍入结果大于或等于无限精确结果。

-   向 0 舍入：也叫截断，舍入结果的绝对值小于或等于无限精确结果。

舍入到最接近的偶数是最精确的，是绝大部分情况下默认的选择。

## 浮点数的识别

不同的指令集对浮点数的处理是不同的，虽然现在的程序都已经默认使用 SSE 和 AVX 指令集来处理浮点数，但还有一些早期的程序使用 x87 指令集来处理，因此需要分开讨论。

考虑如下 C 代码：

```c
int main(void) {
    float f = 1.2;
    double d = 3.4;
    long double ld = 4.8;

    printf("f = %f, d = %f, ld = %Lf\n", f, d, ld);

    return 0;
}
```

用 x87 指令来处理，其汇编代码如下：


```assembly
; int main(void)
00951080  push        ebp
00951081  mov         ebp,esp
00951083  sub         esp,14h
; float f = 1.2;
00951086  fld         dword ptr ds:[00952100h]
0095108C  fstp        dword ptr [ebp-4]
; double d = 3.4;
0095108F  fld         qword ptr ds:[00952108h]
00951095  fstp        qword ptr [ebp-14h]
; long double ld = 4.8;
00951098  fld         qword ptr ds:[00952110h]
0095109E  fstp        qword ptr [ebp-0Ch]
; printf("f = %f, d = %f, ld = %Lf\n", f, d, ld);
009510A1  sub         esp,8
009510A4  fld         qword ptr [ebp-0Ch]
009510A7  fstp        qword ptr [esp]
009510AA  sub         esp,8
009510AD  fld         qword ptr [ebp-14h]
009510B0  fstp        qword ptr [esp]
009510B3  fld         dword ptr [ebp-4]
009510B6  sub         esp,8
009510B9  fstp        qword ptr [esp]
009510BC  push        953020h
009510C1  call        00951040
009510C6  add         esp,1Ch
; return 0;
009510C9  xor         eax,eax
009510CB  mov         esp,ebp
009510CD  pop         ebp
009510CE  ret
```

因为 x87 FPU 是栈式处理的，因此每次加载浮点数都需要进行入栈的操作，把数据放到 st0 中，使用时再出栈。作为函数参数时，不能直接使用 push 指令，需要使用 sub 指令来间接将其入栈。

用 SSE 指令来处理，其汇编代码如下：

```assembly
; int main(void)
009C1080  push        ebp
009C1081  mov         ebp,esp
009C1083  sub         esp,14h
; float f = 1.2;
009C1086  movss       xmm0,dword ptr ds:[009C2100h]
009C108E  movss       dword ptr [ebp-4],xmm0
; double d = 3.4;
009C1093  movsd       xmm0,mmword ptr ds:[009C2108h]
009C109B  movsd       mmword ptr [ebp-14h],xmm0
; long double ld = 4.8;
009C10A0  movsd       xmm0,mmword ptr ds:[009C2110h]
009C10A8  movsd       mmword ptr [ebp-0Ch],xmm0
; printf("f = %f, d = %f, ld = %Lf\n", f, d, ld);
009C10AD  sub         esp,8
009C10B0  movsd       xmm0,mmword ptr [ebp-0Ch]
009C10B5  movsd       mmword ptr [esp],xmm0
009C10BA  sub         esp,8
009C10BD  movsd       xmm0,mmword ptr [ebp-14h]
009C10C2  movsd       mmword ptr [esp],xmm0
009C10C7  cvtss2sd    xmm0,dword ptr [ebp-4]
009C10CC  sub         esp,8
009C10CF  movsd       mmword ptr [esp],xmm0
009C10D4  push        9C3020h
009C10D9  call        009C1040
009C10DE  add         esp,1Ch
; return 0;
009C10E1  xor         eax,eax
009C10E3  mov         esp,ebp
009C10E5  pop         ebp
009C10E6  ret
```

可以看到，xmm 寄存器是直接线性访问的，同样，作为函数参数时，不能直接使用 push 指令，需要使用 sub 指令来间接将其入栈。

# 4 类型转换

不同类型的数据之前可以相互转换，绝大多数情况下都不会改变数据的位表示，只是解释的方式不同。

## 无符号与有符号数的转换

### 补码转换为无符号数

对满足 $TMin_n ≤ x ≤ TMax_n$ 的 $x$ 有：
$$
T2U_n(x) = \begin{cases}
x & x ≥ 0\\
x + 2^n & x < 0
\end{cases}
$$

### 无符号数转换为补码

对满足 $0 ≤ x ≤ UMax_n$ 的 $x$ 有：
$$
U2T_n(x) = \begin{cases}
x - 2^n & x > TMax_n\\
x & x ≤ TMax_n
\end{cases}
$$

## 整数的扩展

将数转换为更大类型的数时，如将 short 转换为 int，对无符号数进行**零扩展**即在高位补 0，对补码则是进行**符号扩展**，即在最高位填充符号位。

### 零扩展

`movzx reg,reg/mem` 为**零扩展后传送**，其中目的操作数长度必须大于源操作数，只用于无符号数。

```assembly
mov bx,8000h
movzx eax,bx    ; eax = 00008000h
```

### 符号扩展

`movsx reg,reg/mem` 为**符号扩展后传送**，其中目的操作数长度必须大于源操作数，只用于有符号数。

```assembly
mov bx,8000h
movsx eax,bx    ; eax = FFFF8000h
```

当要扩展操作数的位数时，且不改变其正负性，此时也可以用移位指令来完成。如将 ax 扩展到 eax，可以先左移 16 位，再进行相同次数的算术右移。

```assembly
mov ax, FF80h   ; ax = -128d
shl eax, 10h    ; eax = FF800000h
sar eax, 10h    ; eax = FFFFFF80h
```

符号扩展也会使用 `cbw`、`cwd`、`cdq` 和 `cqo` 指令，主要用于有符号除法运算，在执行 idiv 指令之前，必须使用该类指令进行符号扩展。cbw 将符号位从 al 扩展到 ah；cwd 将符号位从 ax 扩展到 dx；cdq 将符号位从 eax 扩展到 edx，cqo 将符号位从 rax 扩展到 rdx。

```assembly
mov eax,8000h
mov ebx,9Fh
cdq             ; edx = FFFFFFFFh
idiv ebx
```

此外，`cwde` 指令将符号位从 ax 扩展到 eax，`cdqe` 指令将符号位从 eax 扩展到 rax。

```assembly
mov ax,8000h
cwde            ; eax = FFFF8000h
cqde            ; rax = FFFFFFFFFFFF8000h
```

## 整数的截断

将数转换为更小类型的数时，如将 int 转换为 short，会直接丢弃高位，剩下的位按照对应的方式进行解析。如果这个数的大小超过转换后类型的最大值，则会发生溢出，数的值将发生改变。

考虑如下 C 代码：

```c
int main(void) {
    int i1 = 1;
    short s1 = i1;

    short s2 = 3;
    int i2 = s2;

    int i3 = 0xFFFFFFFF;
    short s3 = i3;

    printf("i1 = %d, s1 = %d\n", i1, s1);
    printf("i2 = %d, s2 = %d\n", i2, s2);
    printf("i3 = %d, s3 = %d\n", i3, s3);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(void)
00261080  push        ebp
00261081  mov         ebp,esp
00261083  sub         esp,18h
; int i1 = 1;
00261086  mov         dword ptr [ebp-10h],1
; short s1 = i1;
0026108D  mov         ax,word ptr [ebp-10h]
00261091  mov         word ptr [ebp-8],ax
; short s2 = 3;
00261095  mov         ecx,3
0026109A  mov         word ptr [ebp-4],cx
; int i2 = s2;
0026109E  movsx       edx,word ptr [ebp-4]
002610A2  mov         dword ptr [ebp-18h],edx
; int i3 = 0xFFFFFFFF;
002610A5  mov         dword ptr [ebp-14h],0FFFFFFFFh
; short s3 = i3;
002610AC  mov         ax,word ptr [ebp-14h]
002610B0  mov         word ptr [ebp-0Ch],ax
; printf("i1 = %d, s1 = %d\n", i1, s1);
002610B4  movsx       ecx,word ptr [ebp-8]
002610B8  push        ecx
002610B9  mov         edx,dword ptr [ebp-10h]
002610BC  push        edx
002610BD  push        263048h
002610C2  call        00261040
002610C7  add         esp,0Ch
; printf("i2 = %d, s2 = %d\n", i2, s2);
002610CA  movsx       eax,word ptr [ebp-4]
002610CE  push        eax
002610CF  mov         ecx,dword ptr [ebp-18h]
002610D2  push        ecx
002610D3  push        263034h
002610D8  call        00261040
002610DD  add         esp,0Ch
; printf("i3 = %d, s3 = %d\n", i3, s3);
002610E0  movsx       edx,word ptr [ebp-0Ch]
002610E4  push        edx
002610E5  mov         eax,dword ptr [ebp-14h]
002610E8  push        eax
002610E9  push        263020h
002610EE  call        00261040
002610F3  add         esp,0Ch
; return 0;
002610F6  xor         eax,eax
002610F8  mov         esp,ebp
002610FA  pop         ebp
002610FB  ret
```

可以看到，仅仅是修饰词的不同，从 dword 到 word 相当于直接丢弃高位。

## 浮点数的转换

考虑如下 C 代码：

```c
int main(void) {
    float f1 = 1.2;
    double d1 = f1;
    
    double d2 = 2.4;
    float f2 = d2;
    
    double d3 = 1.7e39;
    float f3 = d3;

    printf("f1 = %f, d1 = %f\n", f1, d1);
    printf("f2 = %f, d2 = %f\n", f2, d2);
    printf("f3 = %f, d3 = %e\n", f3, d3);

    return 0;
}
```

用 x87 指令来处理，其汇编代码如下：

```assembly
; int main(void)
00A01080  push        ebp
00A01081  mov         ebp,esp
00A01083  sub         esp,24h
; float f1 = 1.2;
00A01086  fld         dword ptr ds:[00A02100h]
00A0108C  fstp        dword ptr [ebp-4]
; double d1 = f1;
00A0108F  fld         dword ptr [ebp-4]
00A01092  fstp        qword ptr [ebp-24h]
; double d2 = 2.4;
00A01095  fld         qword ptr ds:[00A02108h]
00A0109B  fstp        qword ptr [ebp-14h]
; float f2 = d2;
00A0109E  fld         qword ptr [ebp-14h]
00A010A1  fstp        dword ptr [ebp-8]
; double d3 = 1.7e39;
00A010A4  fld         qword ptr ds:[00A02110h]
00A010AA  fstp        qword ptr [ebp-1Ch]
; float f3 = d3;
00A010AD  fld         qword ptr [ebp-1Ch]
00A010B0  fstp        dword ptr [ebp-0Ch]
; printf("f1 = %f, d1 = %f\n", f1, d1);
00A010B3  sub         esp,8
00A010B6  fld         qword ptr [ebp-24h]
00A010B9  fstp        qword ptr [esp]
00A010BC  fld         dword ptr [ebp-4]
00A010BF  sub         esp,8
00A010C2  fstp        qword ptr [esp]
00A010C5  push        0A03048h
00A010CA  call        00A01040
; printf("f2 = %f, d2 = %f\n", f2, d2);
00A010CF  add         esp,0Ch
00A010D2  fld         qword ptr [ebp-14h]
00A010D5  fstp        qword ptr [esp]
00A010D8  fld         dword ptr [ebp-8]
00A010DB  sub         esp,8
00A010DE  fstp        qword ptr [esp]
00A010E1  push        0A03034h
00A010E6  call        00A01040
; printf("f3 = %f, d3 = %e\n", f3, d3);
00A010EB  add         esp,0Ch
00A010EE  fld         qword ptr [ebp-1Ch]
00A010F1  fstp        qword ptr [esp]
00A010F4  fld         dword ptr [ebp-0Ch]
00A010F7  sub         esp,8
00A010FA  fstp        qword ptr [esp]
00A010FD  push        0A03020h
00A01102  call        00A01040
00A01107  add         esp,14h
; return 0;
00A0110A  xor         eax,eax
00A0110C  mov         esp,ebp
00A0110E  pop         ebp
00A0110F  ret
```

可以看到，x87 没有类型转换指令，只是修饰词不同。

用 SSE 指令来处理，其汇编代码如下：

```assembly
; int main(void)
00BD1080  push        ebp
00BD1081  mov         ebp,esp
00BD1083  sub         esp,24h
; float f1 = 1.2;
00BD1086  movss       xmm0,dword ptr ds:[00BD2100h]
00BD108E  movss       dword ptr [ebp-4],xmm0
; double d1 = f1;
00BD1093  cvtss2sd    xmm0,dword ptr [ebp-4]            ; float to double
00BD1098  movsd       mmword ptr [ebp-24h],xmm0
; double d2 = 2.4;
00BD109D  movsd       xmm0,mmword ptr ds:[00BD2108h]
00BD10A5  movsd       mmword ptr [ebp-14h],xmm0
; float f2 = d2;
00BD10AA  cvtsd2ss    xmm0,mmword ptr [ebp-14h]         ; double to float
00BD10AF  movss       dword ptr [ebp-8],xmm0
; double d3 = 1.7e39;
00BD10B4  movsd       xmm0,mmword ptr ds:[00BD2110h]
00BD10BC  movsd       mmword ptr [ebp-1Ch],xmm0
; float f3 = d3;
00BD10C1  cvtsd2ss    xmm0,mmword ptr [ebp-1Ch]         ; double to float
00BD10C6  movss       dword ptr [ebp-0Ch],xmm0
; printf("f1 = %f, d1 = %f\n", f1, d1);
00BD10CB  sub         esp,8
00BD10CE  movsd       xmm0,mmword ptr [ebp-24h]
00BD10D3  movsd       mmword ptr [esp],xmm0
00BD10D8  cvtss2sd    xmm0,dword ptr [ebp-4]            ; float to double
00BD10DD  sub         esp,8
00BD10E0  movsd       mmword ptr [esp],xmm0
00BD10E5  push        0BD3048h
00BD10EA  call        00BD1040
; printf("f2 = %f, d2 = %f\n", f2, d2);
00BD10EF  add         esp,0Ch
00BD10F2  movsd       xmm0,mmword ptr [ebp-14h]
00BD10F7  movsd       mmword ptr [esp],xmm0
00BD10FC  cvtss2sd    xmm0,dword ptr [ebp-8]            ; float to double
00BD1101  sub         esp,8
00BD1104  movsd       mmword ptr [esp],xmm0
00BD1109  push        0BD3034h
00BD110E  call        00BD1040
; printf("f3 = %f, d3 = %e\n", f3, d3);
00BD1113  add         esp,0Ch
00BD1116  movsd       xmm0,mmword ptr [ebp-1Ch]
00BD111B  movsd       mmword ptr [esp],xmm0
00BD1120  cvtss2sd    xmm0,dword ptr [ebp-0Ch]          ; float to double
00BD1125  sub         esp,8
00BD1128  movsd       mmword ptr [esp],xmm0
00BD112D  push        0BD3020h
00BD1132  call        00BD1040
00BD1137  add         esp,14h
; return 0;
00BD113A  xor         eax,eax
00BD113C  mov         esp,ebp
00BD113E  pop         ebp
00BD113F  ret
```

SSE 会使用类型转换指令来处理。可以看到，float 转化为 double 不会丢失信息，但从 double 转换为 float 则可能丢失，若是超出范围，则转换指令会把阶码全置 1，把尾数全置 0，这样 float 就为 Inf。还可以看到，无论是否是 double 类型，在处理时都会先转换成 double 处理。

# 5 指针

指针实际上就是一个值为地址的内存单元，在汇编中一般用 lea 指令来处理。

考虑如下 C 代码：

```c
int main(void) {
    int a = 1;
    int *pa = &a;
    *pa = 5;

    printf("&a = %p, pa = %p\n", &a, pa);
    printf("a = %d, *pa = %d\n", a, *pa);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(void)
00601080  push        ebp
00601081  mov         ebp,esp
00601083  sub         esp,8
; int a = 1;
00601086  mov         dword ptr [ebp-8],1
; int *pa = &a;
0060108D  lea         eax,[ebp-8]
00601090  mov         dword ptr [ebp-4],eax
; *pa = 5;
00601093  mov         ecx,dword ptr [ebp-4]
00601096  mov         dword ptr [ecx],5
; printf("&a = %p, pa = %p\n", &a, pa);
0060109C  mov         edx,dword ptr [ebp-4]
0060109F  push        edx
006010A0  lea         eax,[ebp-8]
006010A3  push        eax
006010A4  push        603034h
006010A9  call        00601040
006010AE  add         esp,0Ch
; printf("a = %d, *pa = %d\n", a, *pa);
006010B1  mov         ecx,dword ptr [ebp-4]
006010B4  mov         edx,dword ptr [ecx]
006010B6  push        edx
006010B7  mov         eax,dword ptr [ebp-8]
006010BA  push        eax
006010BB  push        603020h
006010C0  call        00601040
006010C5  add         esp,0Ch
; return 0;
006010C8  xor         eax,eax
006010CA  mov         esp,ebp
006010CC  pop         ebp
006010CD  ret
```

lea 表示装入有效地址，其操作数为地址。可以看到，lea 指令将内存单元的地址当作值进行传送，而不是取这个内存单元的值。由于 lea 指令较短，效率较高，因此除了用来处理指针，还可以用来用一些运算上的优化。

# 6 数组

数组是相同数据类型元素的集合，以线性的方式连续存储在栈、数据段或内存中，通常按从低地址到高地址的顺序存放。数组寻址通常用 `[基址 + n]` 或 `[基址 + reg*n]` 来表示，基址可以是常量也可以是寄存器。通过这种方式可以很容易的识别对于数组的操作。

## 一维数组

设一维数组 `type a[N]`，其元素 `a[i]` 的寻址公式为：
$$
\&a[i]=\&a+sizeof(type) * i\quad 0 ≤ i ≤ N - 1
$$
在汇编中通常利用基址加变址寻址来访问数组，如：

```assembly
mov eax,[edx+imm]
mov eax,[edx*n+imm]
mov eax,[ecx+edx*n+imm]
```

考虑如下 C 代码：

```c
int ga[3] = { 1, 3, 5 };

int main(void) {
    int a[3] = { 2, 4, 6 };
    int gsum = ga[0] + ga[1] + ga[2];
    int sum = 0;

    for (int i = 0; i < sizeof(a) / sizeof(int); i++)
        sum += a[i];
    
    printf("gsum = %d, sum = %d\n", gsum, sum);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(void)
00E81080  push        ebp
00E81081  mov         ebp,esp
00E81083  sub         esp,18h
; int a[3] = { 2, 4, 6 };
00E81086  mov         dword ptr [ebp-18h],2
00E8108D  mov         dword ptr [ebp-14h],4
00E81094  mov         dword ptr [ebp-10h],6
; int gsum = ga[0] + ga[1] + ga[2];
00E8109B  mov         eax,4
00E810A0  imul        ecx,eax,0
00E810A3  mov         edx,4
00E810A8  shl         edx,0
00E810AB  mov         eax,dword ptr [ecx+00E83020h]     ; 寻址
00E810B1  add         eax,dword ptr [edx+00E83020h]
00E810B7  mov         ecx,4
00E810BC  shl         ecx,1
00E810BE  add         eax,dword ptr [ecx+00E83020h]
00E810C4  mov         dword ptr [ebp-0Ch],eax
; int sum = 0;
00E810C7  mov         dword ptr [ebp-8],0
; for (int i = 0; i < sizeof(a) / sizeof(int); i++)
00E810CE  mov         dword ptr [ebp-4],0
00E810D5  jmp         00E810E0
00E810D7  mov         edx,dword ptr [ebp-4]
00E810DA  add         edx,1
00E810DD  mov         dword ptr [ebp-4],edx
00E810E0  cmp         dword ptr [ebp-4],3
00E810E4  jae         00E810F5
; sum += a[i];
00E810E6  mov         eax,dword ptr [ebp-4]
00E810E9  mov         ecx,dword ptr [ebp-8]
00E810EC  add         ecx,dword ptr [ebp+eax*4-18h]     ; 寻址
00E810F0  mov         dword ptr [ebp-8],ecx
00E810F3  jmp         00E810D7
; printf("gsum = %d, sum = %d\n", gsum, sum);
00E810F5  mov         edx,dword ptr [ebp-8]
00E810F8  push        edx
00E810F9  mov         eax,dword ptr [ebp-0Ch]
00E810FC  push        eax
00E810FD  push        0E8302Ch
00E81102  call        00E81040
00E81107  add         esp,0Ch
; return 0;
00E8110A  xor         eax,eax
00E8110C  mov         esp,ebp
00E8110E  pop         ebp
00E8110F  ret
```

可以看到，下标为常量时，会直接使用首地址加偏移量访问；下标为变量时，使用寻址公式访问。

## 多维数组

多维数组也可以看作是多个一维数组的组合，其本质上还是一维数组，只是寻址公式不同。

设二维数组 `type a[N][M]`，其元素 `a[i][j]` 的寻址公式为：
$$
\&a[i][j] = \&a + sizeof(type) * (M*i + j)
$$
$$
0 ≤ i ≤ N - 1,\ 0 ≤ j ≤ M - 1
$$



设三维数组 `type a[N][M][L]`，其元素 `a[i][j][k]` 的寻址公式为：
$$
\&a[i][j][k] = \&a + sizeof(type) * (M*L*i + L*j + k)
$$
$$
0 ≤ i ≤ N - 1,\ 0 ≤ j ≤ M - 1,\ 0 ≤ k ≤ L - 1
$$



考虑如下 C 代码：

```c
int main(void) {
    int a[2][3];

    for (int i = 0; i < sizeof(a) / sizeof(a[0]); i++)
        for (int j = 0; j < sizeof(a[0]) / sizeof(int); j++)
            a[i][j] = 1;

    printf("%d\n", a[1][2]);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(void)
00C61080  push        ebp
00C61081  mov         ebp,esp
00C61083  sub         esp,20h
; int a[2][3];
; for (int i = 0; i < sizeof(a) / sizeof(a[0]); i++)
00C61086  mov         dword ptr [ebp-4],0
00C6108D  jmp         00C61098
00C6108F  mov         eax,dword ptr [ebp-4]
00C61092  add         eax,1
00C61095  mov         dword ptr [ebp-4],eax
00C61098  cmp         dword ptr [ebp-4],2
00C6109C  jae         00C610CC
; for (int j = 0; j < sizeof(a[0]) / sizeof(int); j++)
00C6109E  mov         dword ptr [ebp-8],0
00C610A5  jmp         00C610B0
00C610A7  mov         ecx,dword ptr [ebp-8]
00C610AA  add         ecx,1
00C610AD  mov         dword ptr [ebp-8],ecx
00C610B0  cmp         dword ptr [ebp-8],3
00C610B4  jae         00C610CA
; a[i][j] = 1;
00C610B6  imul        edx,dword ptr [ebp-4],0Ch
00C610BA  lea         eax,[ebp+edx-20h]
00C610BE  mov         ecx,dword ptr [ebp-8]
00C610C1  mov         dword ptr [eax+ecx*4],1   ; 寻址
00C610C8  jmp         00C610A7
00C610CA  jmp         00C6108F
; printf("%d\n", a[1][2]);
00C610CC  mov         edx,0Ch
00C610D1  shl         edx,0
00C610D4  lea         eax,[ebp+edx-20h]
00C610D8  mov         ecx,4
00C610DD  shl         ecx,1
00C610DF  mov         edx,dword ptr [eax+ecx]   ; 寻址
00C610E2  push        edx
00C610E3  push        0C63020h
00C610E8  call        00C61040
00C610ED  add         esp,8
; return 0;
00C610F0  xor         eax,eax
00C610F2  mov         esp,ebp
00C610F4  pop         ebp
00C610F5  ret
```

可以看到，二维数组依然按照寻址公式进行访问。

## 数组的指针

在 C 中，数组名代表了这个数组第一个元素的地址，也就是整个数组的基址，通过传递数组名来传递数组的指针，可以将此当作函数的参数或者返回值。

考虑如下 C 代码：

```c
int sum(int a[], int len) {
    int n = 0;
    for (int i = 0; i < len; i++)
        n += a[i];

    return n;
}

int main(void) {
    int a[4] = { 2, 4, 6, 8 };
    printf("%d\n", sum(a, sizeof(a) / sizeof(int)));

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(void)
00F410C0  push        ebp
00F410C1  mov         ebp,esp
00F410C3  sub         esp,10h
; int a[4] = { 2, 4, 6, 8 };
00F410C6  mov         dword ptr [ebp-10h],2
00F410CD  mov         dword ptr [ebp-0Ch],4
00F410D4  mov         dword ptr [ebp-8],6
00F410DB  mov         dword ptr [ebp-4],8
; printf("%d\n", sum(a, sizeof(a) / sizeof(int)));
00F410E2  push        4
00F410E4  lea         eax,[ebp-10h]         ; 首地址
00F410E7  push        eax
00F410E8  call        00F41080
00F410ED  add         esp,8
00F410F0  push        eax
00F410F1  push        0F43020h
00F410F6  call        00F41040
00F410FB  add         esp,8
; return 0;
00F410FE  xor         eax,eax
00F41100  mov         esp,ebp
00F41102  pop         ebp
00F41103  ret
```

## 信息丢失

考虑如下 C 代码：

```c
void func(int a[]) {
    printf("%d\n", sizeof(a));
}

int main(void) {
    int a[4];
    printf("%d\n", sizeof(a));
    func(a);

    return 0;
}
```

其汇编代码如下：

```assembly
; void func(int a[])
007A1080  push        ebp
007A1081  mov         ebp,esp
; printf("%d\n", sizeof(a));
007A1083  push        4             ; 大小为 4
007A1085  push        7A3024h
007A108A  call        007A1040
007A108F  add         esp,8
007A1092  pop         ebp
007A1093  ret

; int main(void)
007A10A0  push        ebp
007A10A1  mov         ebp,esp
007A10A3  sub         esp,10h
; int a[4];
; printf("%d\n", sizeof(a));
007A10A6  push        10h           ; 大小为 16
007A10A8  push        7A3020h
007A10AD  call        007A1040
007A10B2  add         esp,8
; func(a);
007A10B5  lea         eax,[ebp-10h]
007A10B8  push        eax
007A10B9  call        007A1080
007A10BE  add         esp,4
; return 0;
007A10C1  xor         eax,eax
007A10C3  mov         esp,ebp
007A10C5  pop         ebp
007A10C6  ret
```

可以看到，在将数组当作参数传递其指针时，关于数组元素个数的信息丢失了，因此把数组当作参数时，需要再传递其元素个数作为参数。

# 7 字符串

## 字符串格式

在程序中，一般将字符串当作字符数组来处理，但不同编程语言的字符存储格式是不同的。

### C 字符串

以 ASCII 码为 0 的空字符 `\0` 作为终止符，也叫 ASCIIZ 字符串。

```c
char str[] = { 'h', 'e', 'l', 'l', 'o', 0 };  // 等同于 "hello"
```

### DOS 字符串

以 `$` 作为终止符，只存在于 DOS 中，现已几乎消失。

### Pascal 字符串

没有终止符，但在字符串头部定义了 1 字节的**长度字段**，因此字符串长度不能超过 255，只存在于 Pascal 和 16 位 Delphi 中。

### Delphi 字符串

长度字段为 2 字节或 4 字节的 32 位 Delphi 字符串。

## 字符寻址

x86 支持寄存器直接与间接寻址。与字符指针处理相关的指令有 mov、lea 等。

```assembly
mov eax,[401000h]  ; 直接寻址，把地址 401000h 处的数据放入 eax
mov eax,[ecx]      ; 间接寻址，把 ecx 中的地址数据放入 eax

lea eax,[401000h]  ; 等同于 mov eax,401000h
lea eax,[eax+8]    ; 等同于 add eax,8
```

考虑如下 C 代码：

```c
int main(void) {
    char *str = "abcde";
    for (int i = 0; str[i] != 0; i++)
        str[i] &= 0xDF;

    printf("%s\n", str);

    return 0;
}
```

开启 O2 优化后，其汇编代码如下：

```assembly
; int main(void)
; char *str = "abcde";
; for (int i = 0; str[i] != 0; i++)
003B1040  mov         al,byte ptr ds:[003B2100h]
003B1045  mov         ecx,3B2100h
003B104A  nop         word ptr [eax+eax]
; str[i] &= 0xDF;
003B1050  and         al,0DFh
003B1052  lea         ecx,[ecx+1]
003B1055  mov         byte ptr [ecx-1],al
003B1058  mov         al,byte ptr [ecx]
003B105A  test        al,al
003B105C  jne         003B1050
; printf("%s\n", str);
003B105E  push        3B2100h
003B1063  push        3B2108h
003B1068  call        003B1010
003B106D  add         esp,8
; return 0;
003B1070  xor         eax,eax
003B1072  ret
```

可以看到，对字符串的处理通常采用字符指针的形式，且编译器通常把字符串常量放到数据区域中。

# 14 结构体

结构体和普通的变量没什么区别，但由于其内部成员的大小可能不相等，因此编译器会进行对齐处理。

考虑如下 C 代码：

```c
struct User {
    int id;
    char name[10];
    int age;
};

int main(void) {
    struct User u;
    struct User *pu = &u;
    u.id = 1;
    strcpy(u.name, "ABC");
    u.age = 20;

    printf("id = %d, name = %s, age = %d\n", u.id, u.name, u.age);
    printf("id = %d, name = %s, age = %d\n", pu->id, pu->name, pu->age);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(void)
00B21080  push        ebp
00B21081  mov         ebp,esp
00B21083  sub         esp,18h                       ; 分配内存
; struct User u;                                    ; &u = ebp - 18h
; struct User *pu = &u;                             ; &pu = ebp - 4
00B21086  lea         eax,[ebp-18h]
00B21089  mov         dword ptr [ebp-4],eax
; u.id = 1;
00B2108C  mov         dword ptr [ebp-18h],1         ; &u.id = ebp -18h
; strcpy(u.name, "ABC");
00B21093  mov         ecx,dword ptr ds:[00B23060h]  ; "ABC" = ds:[00B23060h]
00B21099  mov         dword ptr [ebp-14h],ecx       ; &u.name = ebp - 14h
; u.age = 20;
00B2109C  mov         dword ptr [ebp-8],14h         ; &u.age = ebp - 8
; printf("id = %d, name = %s, age = %d\n", u.id, u.name, u.age);
00B210A3  mov         edx,dword ptr [ebp-8]
00B210A6  push        edx
00B210A7  lea         eax,[ebp-14h]
00B210AA  push        eax
00B210AB  mov         ecx,dword ptr [ebp-18h]
00B210AE  push        ecx
00B210AF  push        0B23040h
00B210B4  call        00B21040
00B210B9  add         esp,10h
; printf("id = %d, name = %s, age = %d\n", pu->id, pu->name, pu->age);
00B210BC  mov         edx,dword ptr [ebp-4]
00B210BF  mov         eax,dword ptr [edx+10h]
00B210C2  push        eax
00B210C3  mov         ecx,dword ptr [ebp-4]
00B210C6  add         ecx,4
00B210C9  push        ecx
00B210CA  mov         edx,dword ptr [ebp-4]
00B210CD  mov         eax,dword ptr [edx]
00B210CF  push        eax
00B210D0  push        0B23020h
00B210D5  call        00B21040
00B210DA  add         esp,10h
; return 0;
00B210DD  xor         eax,eax
00B210DF  mov         esp,ebp
00B210E1  pop         ebp
00B210E2  ret
```

可以看到， User 结构有三个成员，按照最小分配，应该是 18 字节，加上一个结构指针 pu 为 4 字节，一共是 22 字节，但是却申请了 24 字节的内存，是因为结构体成员没有按照 4 字节对齐，因此在 name 成员后填充了 2 个字节。还可以看到，变量在栈中是从低地址到高地址排列的。

## 位字段

结构还可以使用位字段的形式，位字段是一个 int、unsigned int 或 _Bool 类型变量中的一组相邻的位。位字段声明为每个字段提供标签 ，并确定该字段的宽度。 

考虑如下 C 代码：

```c
struct RGB {
    unsigned int red   : 16;
    unsigned int green : 16;
    unsigned int blue  : 16;
};

int main(void) {
    struct RGB c = { 0x100, 0x200, 0x300 };
    printf("%d\n", sizeof(c));
    printf("RGB = (%u, %u, %u)\n", c.red, c.green, c.blue);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(void)
009F1080  push        ebp
009F1081  mov         ebp,esp
009F1083  sub         esp,8
; struct RGB c = { 0x100, 0x200, 0x300 };
009F1086  mov         dword ptr [ebp-8],2000100h
009F108D  mov         dword ptr [ebp-4],300h
; printf("%d\n", sizeof(c));
009F1094  push        8
009F1096  push        9F3034h
009F109B  call        009F1040
009F10A0  add         esp,8
; printf("RGB = (%u, %u, %u)\n", c.red, c.green, c.blue);
009F10A3  mov         eax,dword ptr [ebp-4]
009F10A6  and         eax,0FFFFh
009F10AB  push        eax
009F10AC  mov         ecx,dword ptr [ebp-8]
009F10AF  shr         ecx,10h
009F10B2  and         ecx,0FFFFh
009F10B8  push        ecx
009F10B9  mov         edx,dword ptr [ebp-8]
009F10BC  and         edx,0FFFFh
009F10C2  push        edx
009F10C3  push        9F3020h
009F10C8  call        009F1040
009F10CD  add         esp,10h
; return 0;
009F10D0  xor         eax,eax
009F10D2  mov         esp,ebp
009F10D4  pop         ebp
009F10D5  ret
```

可以看到，如果声明的总位数超过了 一个 unsigned int 类型的大小，则会用到下一个 unsigned int 的存储位置，且一个字段不能跨越两个 unsigned int 之间的边界。编译器会自动移动跨界的字段，保持 unsigned int 的边界对齐，因此第 1 个 unsigned int 中会留下一个空洞，可以手动用未命名的字段宽度填充空洞，使用一个宽度为 0 的未命名字段迫使下一个字段与下一个整数对齐，如：

```c
struct Def {
    unsigned int a : 1;
    unsigned int   : 2;
    unsigned int b : 1;
    unsigned int   : 0;
    unsigned int c : 1;
};

struct Def s;
```

字段 a 和 字段 b 之间有 2 位的间隙，但字段 c 将在下一个 unsigned int 中，结构 s 的大小为 8 字节。

字段在一个 unsigned int 中的顺序在不同的机器上可能不同，在小端机器上，先定义的在低位字节，在大端上则相反。

# 15 共用体

共用体是一种和结构体类似的数据类型，能在同一个内存空间中储存不同的数据类型，但不能同时存储。 一个共用体的大小为占据空间最多的成员大小。

考虑如下 C 代码：

```c
union Number {
    char c;
    int i;
    double d;
};

int main(void) {
    union Number n;
    printf("%d\n", sizeof(n));
    printf("&n.c = %p, &n.i = %p, &n.d = %p\n", &n.c, &n.i, &n.d);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(void)
00F21080  push        ebp
00F21081  mov         ebp,esp
00F21083  sub         esp,8
; union Number n;
; printf("%d\n", sizeof(n));
00F21086  push        8
00F21088  push        0F23044h
00F2108D  call        00F21040
00F21092  add         esp,8
; printf("&n.c = %p, &n.i = %p, &n.d = %p\n", &n.c, &n.i, &n.d);
00F21095  lea         eax,[ebp-8]
00F21098  push        eax
00F21099  lea         ecx,[ebp-8]
00F2109C  push        ecx
00F2109D  lea         edx,[ebp-8]
00F210A0  push        edx
00F210A1  push        0F23020h
00F210A6  call        00F21040
00F210AB  add         esp,10h
; return 0;
00F210AE  xor         eax,eax
00F210B0  mov         esp,ebp
00F210B2  pop         ebp
00F210B3  ret
```

可以看到，所有的成员的起始地址是同一个，也就是说，当给一个成员赋完值后，再对其另一个成员赋值，则直接覆盖。此外如果使用了没有被赋值的成员，那么会得到一个不确定的值。

# 16 枚举

枚举也和结构体类似，使用符号名称来表示整型常量，主要用于提高程序的可读性。实际上枚举内部是 int 型数值，因此只要在使用 int 的场合就可以使用枚举。

考虑如下 C 代码：

```c
enum Weekday {
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday
};

int main(void) {
    int day;
    for (day = Monday; day <= Sunday; day++)
        printf("%d\n", day);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(void)
008E1080  push        ebp
008E1081  mov         ebp,esp
008E1083  push        ecx
; int day;
; for (day = Monday; day <= Sunday; day++)
008E1084  mov         dword ptr [ebp-4],0
008E108B  jmp         008E1096
008E108D  mov         eax,dword ptr [ebp-4]
008E1090  add         eax,1
008E1093  mov         dword ptr [ebp-4],eax
008E1096  cmp         dword ptr [ebp-4],6
008E109A  jg          008E10AF
; printf("%d\n", day);
008E109C  mov         ecx,dword ptr [ebp-4]
008E109F  push        ecx
008E10A0  push        8E3020h
008E10A5  call        008E1040
008E10AA  add         esp,8
008E10AD  jmp         008E108D
; return 0;
008E10AF  xor         eax,eax
008E10B1  mov         esp,ebp
008E10B3  pop         ebp
008E10B4  ret
```

可以看到，如果不给枚举赋初值，则默认为从 0 开始的整数。

