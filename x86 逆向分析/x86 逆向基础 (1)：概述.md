> 本文约定如下：
>
> - 若无额外说明，默认在 Windows x64 下，使用 Visual Studio 2019，禁用 SDL 检查和 GS 安全检查，其余为默认设置，以 Release 无优化模式编译
> - 汇编语法为 Intel 语法，以 x86 指代 32 位程序，x64 指代 64 位程序。若 x86 与 x64 在执行逻辑上没有较大区别，则默认以 x86 汇编代码说明
> - 在汇编指令中，`reg`、`reg8`、`reg16`、`reg32` 和 `reg64` 代表不同长度的通用寄存器
> - 在汇编指令中，`mem`、`mem8`、`mem16`、`mem32` 和 `mem64` 代表不同长度的内存单元
> - 在汇编指令中，`imm`、`imm8`、`imm16`、`imm32` 和 `imm64` 代表不同长度立即数
> - 在汇编指令中，不带数字后缀的为适用于当前场合下的所有长度，如 `mov reg,mem8/16`，因为源操作数是 8 或 16 位大小的内存单元，因此目的操作数也只能为对应的 8 或 16 位的寄存器
> - 在汇编指令中，形如 `[reg*n]`、`[reg*n+reg]`、`[reg*n+imm]` 和 `[reg*n+reg+imm]` 这样的操作数，其中 `n` 代表值为 1、2、4 或 8 的立即数
> - 所有数字带有 `A ~ F`、`0x` 前缀或 `h` 后缀的为十六进制数，带 `b` 后缀的为二进制数
> - 一些不重要的代码可能会被省略
> - 不涉及 IA16 平台及其汇编
>
> 参考：
>
> - [加密与解密](https://book.douban.com/subject/30288807/)
> - [逆向分析实战](https://book.douban.com/subject/30466135/)
> - [深入理解计算机系统](https://book.douban.com/subject/26912767/)
> - [程序员的自我修养——链接、装载与库](https://book.douban.com/subject/3652388/)
> - [x86 汇编语言：从实模式到保护模式](https://book.douban.com/subject/20492528/)

# 1 逆向概述

为了逆向分析可执行程序，通常会进行反汇编、反编译等手段。要理解反汇编中的汇编代码，除了需要对计算机系统有相当的了解，还需要对程序的各类代码，如函数、数据类型、流程控制、数学运算等在汇编中的结构特征有相当的敏感度，才能快速定位分析这段汇编代码的功能。

## 逆向平台

面向桌面端的逆向主要有 Windows、Linux 和 macOS，这些平台虽然有差异，但都是基于 IA32 或 AMD64 指令集（以下统称为 x86），在逆向中实际的差异不大，在熟悉某一平台后可快速适应另一平台。

面向移动端的逆向主要有 Android 和 iOS，以及基于 ARM 的 Windows 和 macOS，这些都是基于 ARM 和 ARM64 指令集（以下统称为 ARM），在底层上和 x86 有些许区别，特别是在汇编语法、寄存器使用、指令集等，但与在 x86 下的逆向思路和原理是类似的，熟悉某一平台后也同样可以快速适应。

此外还有面向 IoT 的逆向，如嵌入式设备、工控设备、路由器等。

除了 x86 和 ARM 外，还有 PowerPC、MIPS、RISC-V 等指令集。

> 本主要涉及 x86 下 Windows 逆向，少部分为 Linux 平台。

## 逆向工具

工欲善其事必先利其器，在进行逆向时，利用好工具可以大大提高效率。逆向分析主要分为**静态分析**和**动态分析**两种。

静态分析即不运行程序，直接分析反汇编出来的汇编代码，但如果程序代码进行了压缩加密，就不能直接进行静态分析，而是需要先做脱壳解密处理，对于在程序运行中才生成的值也无法使用静态分析。静态分析主要使用的工具有 [IDA Pro](https://hex-rays.com/ida-pro/) 和 [Ghidra](https://ghidra-sre.org/)。

> IDA Pro 是 Hex Rays 开发的一款专业级逆向分析工具，同时也具有动态调试功能，支持 32 / 64 位程序。其反编译插件可以直接将反汇编出来的汇编代码反编译为 C 语言伪代码，极大的增加了可读性和分析效率，具有丰富的插件和脚本功能，是进行逆向分析特别是静态分析的第一利器，但价格昂贵且正版只授权给公司或组织，不过可以在网上找到泄露版。
>
> Ghidra 是 NSA 开发的一款开源且免费的专业级逆向分析工具，支持 32 / 64 位程序。功能十分强大，也同样具有反编译功能，是除了 IDA Pro 之外的首选，很大程度上可以作为其替代品使用。

动态分析即进行动态调试，通过下关键断点、单步调试、分析关键函数等操作可以快速了解程序功能，但对于加壳处理过的程序也需要先进行脱壳处理，且大多数程序都具有反调试功能，因此进行动态分析还需要具有反反调试的能力。动态分析主要使用的工具有 [OllDbg](https://www.ollydbg.de/)、[x64dbg](https://x64dbg.com/) 和 [WinDbg](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools)，以及针对游戏修改领域的 [Cheat Engine](https://www.cheatengine.org/)，此外编程所使用的各种 IDE 也具有动态调试的功能，如 Microsoft Visual Studio 等。

> OllDbg 是 Oleh Yuschuk 开发的一款免费的 Ring 3 级动态调试器，但不支持 64 位程序。具有丰富的插件和脚本功能，其反汇编引擎 ODDisasm 能识别 Windows 库函数、自动分析函数过程、循环语句、字符串等。目前早已停止更新，虽然后来作者重新开发了 2.0 版本，但插件支持不够丰富、软件不太稳定，且已有替代品，因此也停止了开发，目前最常用的还是 1.10 版本。
>
> x64dbg 是一款开源且免费的 Ring 3 级动态调试器，支持 32 / 64 位程序。其反汇编引擎 BeaEngine 和 Capstone 功能极其强大，也有丰富的插件和脚本功能，且并保持更新，目前已经基本替代了 OllDbg。
>
> WinDbg 是 Microsoft 开发的一款免费的 Ring 0 和 Ring 3 级动态调试器，支持 32 / 64 位程序。不仅可以调试程序，还能够进行内核调试、分析 Dump 文件等，也有丰富的插件和脚本功能，是 Windows 下内核调试领域的首选。[WinDbg Preview](https://www.microsoft.com/store/p/windbg/9pgjgd53tn86) 是具有现代化 UI 的新版本，可以替代老版本。
>
> Cheat Engine 是一款开源且免费的 Ring 0 和 Ring 3 级动态调试器，支持 32 / 64 位程序。虽然在一些功能上不如像 x64dbg 之类的强大，但其针对游戏做了优化，最常被用来进行游戏修改，如内存修改、注入代码等，也有强大的脚本功能，是做游戏辅助的首选。

此外由于在逆向中，会经常对文件进行十六进制查看、分析、编辑、比较等操作，因此一款好用的十六进制编辑器就显得十分重要。

如果仅仅是查看和简单编辑十六进制文件，可以使用 VS Code 插件 Hex Editor 或 [HxD](https://mh-nexus.de/en/hxd/) 等轻量级工具。

如果需要更复杂的功能，可以使用更专业的工具，如 [010 Editor](https://www.sweetscape.com/download/010editor/)、[WinHex](https://www.x-ways.net/winhex/)、[UltraEdit](https://www.ultraedit.com/downloads/ultraedit-download/) 或 [Hex Workshop](http://www.hexworkshop.com/) 等工具。

如果对比较文件的功能有更复杂的需求，可以使用 [Beyond Compare](https://www.scootersoftware.com/download.php) 或 [UltraCompare](https://www.ultraedit.com/downloads/ultracompare-download/) 等工具。

# 2 32 和 64 位

## x86 和 x64

虽然 x86 CPU 同时支持 32 和 64 位运行模式，但是运行在之上的操作系统、应用程序是有区别的。当运行 32 位程序时，CPU 将切换成 32 位模式运行，当运行 64 位程序时，将切换成 64 位模式，**程序只能按照对应模式下的逻辑运行及使用系统资源**。

32 与 64 位程序虽然在使用上对用户是透明的，但是在逆向中是有些许差别的，如函数调用、内存地址等，因此熟悉这两者之间的差别十分重要。

> Intel 首次开发的 8086 是一款基于 IA16 指令集的 16 位 CPU，后来开发的 80386 是第一款基于 IA32 指令集的 32 位 CPU，与 IA16 保持兼容，IA32 指令集也叫 x86。
>
> AMD 开发的 64 位指令集叫 AMD64，与 IA32 保持兼容，也叫 x86-64。由于 Intel 开发的 64 位指令集 IA64 不兼容 x86，后续也停止了开发，重新在 IA32 的基础上开发了 EM64T 指令集，也叫 IA32e，与 AMD64 相互兼容。
>
> 目前 x86 通常指 IA32，而 x86-64 或 x64 通常指兼容 x86 的 64 位指令集（EM64T 和 AMD64），在不严格区分这两者的场合，可以用 x86 来统称。

## 指令集

指令集，也叫指令集架构，即 CPU 所具有的功能集合，包含一系列操作码即机器语言，这些操作码将由 CPU 执行。不同的处理器家族，如 Intel x86、AMD64、PowerPC 和 ARM，有不同的指令集。

指令集架构与指令集微架构不同，后者是前者在具体细节上的设计和实现，不同微架构的 CPU 可以使用相同的指令集，如 Intel 和 AMD 的 CPU，虽然两者用的指令集是相似的，且相互兼容，但在 CPU 内部设计上有本质的区别，虽然功能上基本一致，但也有性能、功耗上的差别。

在 x86 基础上衍生出了许多专门用于特定方面以增强 CPU 性能的指令集，如 x87 FPU 用来处理浮点数据，SIMD 指令集 MMX、3DNow! 和 SSE 等用来更快的处理浮点数据，AVX 和 FMA 用来处理更加复杂的数据，AES 和 SHA 用来计算加密算法，VT-x 和 AMD-V 用来进行虚拟化等等。

逆向不局限于某个平台，也不局限于具体某种指令集的分析，掌握各种不同平台和多种指令集是很有必要的。

# 3 寄存器

寄存器是用来存放数据的地方，CPU 绝大多数时间都在和寄存器打交道，在进行逆向时，弄清楚数据之间的交换逻辑是十分重要的。

## 通用寄存器

通用寄存器及其可用性如下图所示，当位数扩展时，相对应的寄存器也会扩展。需要注意的是，64 位下再增加了 8 个通用寄存器（`r8` ~ `r15`），`si`、`di`、`bp` 和 `sp` 的低 8 位 `sil`、`dil`、`bpl` 和 `spl` 只有在 64 位下才可使用。由于处理器针对 ax 系列寄存器做了优化，因此与 ax 有关的指令效率较高，操作码也较短，在进行指令修改、编写 Shellcode 等操作时可以多加利用。

![通用寄存器](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109142212589.png)

## FPU 寄存器

### x87

x87 FPU 是专门用于执行标量浮点计算的单元，能够增强程序对浮点运算的性能。可以对单精度浮点（32 位）、双精度浮点（64 位）和扩展双精度浮点（80 位）进行计算，并遵循 IEEE 754 标准。

x87 FPU 可以在 32 和 64 位下工作，在这两种模式下，FPU 寄存器的个数都只有 8 个（`r0` ~ `r7`）。对 x87 FPU 寄存器的访问方式与通用寄存器的线性访问有所不同，x87 FPU 为**栈式访问**。当数据放到 x87 FPU 寄存器时，会根据其长度（32 、64 或 80 位）将数据分别看作单精度浮点、双精度浮点和扩展双精度浮点，然后统一转换为扩展双精度（80 位）并放到 FPU 寄存器栈顶。因此 x87 FPU 寄存器的长度为 80 位，且浮点计算都是基于扩展双精度进行的。

如下图所示，在 x87 FPU 栈顶的寄存器为 `st0`，下面一个为 `st1`，以此类推，到栈底为 `st7`，不能对任意单元直接读写，而是使用专门的指令来将数据出栈和入栈。实际上，`st0` ~ `st7` 是 `r0` ~ `r7` 此时在栈中顺序的标志，这个标志是动态变化的。此外，x87 FPU 还有 6 个专用寄存器，分别是操作码寄存器、控制寄存器、状态寄存器、标识寄存器、最后指令指针寄存器和最后数据操作数指针寄存器。

![ST 寄存器](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109142212649.png)

需要注意的是，由于 80 位（10 字节）并不是 32 位（4 字节）的整数倍，为了字节对齐，在某些情况下，在读写数据时会以 96 位（12 字节）为单位进行。

### SIMD

对于 SISD（单指令单数据），每条指令只能处理一个数据，而 SIMD（单指令多数据）一条指令可以处理多个数据。SIMD 通过一个控制器处理多个并行的数据单元，因此从时间上来说，一条指令执行的时间，这两者是差不多的。由于 SIMD 一次可以处理 N 个数据，所以它的处理的时间也就缩短到 SISD 的 1 / N。Intel 的 MMX 和 SSE，以及 AMD 的 3D Now! 都是 SIMD 指令集。

如下如所示，MMX 指令集的 `mm` 寄存器实际上是 x87 FPU 栈寄存器 `st` 的别名，只不过使用的是 st 的低 64 位，**因此 st 和 mm 不能够同时使用，且 MMX 只能用于处理整数而非浮点数，因此需要在两者之间进行切换**。当为 MMX 状态时，st 栈寄存器的高 16 位将被置 1，因此从栈寄存器的角度看，其浮点值为 NaN 或 Inf，这可用于区分寄存器是处于浮点栈状态还是 MMX 状态。**当作为 MMX 寄存器时为线性访问**，而非栈式访问。

![FPU 寄存器](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109142212287.png)

SSE 指令集加入新的 8 个 128 位寄存器（`xmm0` ~ `xmm7`），而 64 位下再增加了 8 个128 位寄存器（`xmm8` ~ `xmm15`），此外还有一个新的 32 位控制和状态寄存器。每个 `xmm` 寄存器可以容纳 4 个 32 位单精度浮点数、2 个 64 位双精度浮点数、4 个 32 位整数、8 个 16 位短整数或 16 个字符。

由于 SSE 加入了浮点数支持，因此 SSE 就比 MMX 更常用。而 SSE2 加入了整数运算支持之后让 MMX 的使用场景变得更少。此外 SSE 还可以与 MMX 并发使用，在某些时候可以提供额外的性能增强。SSE 还不会像 MMX 因为切换浮点模式而产生性能损耗。目前 x87、3DNow! 和 MMX 都已基本被 SSE 指令集取代。

AVX 指令集是 SSE 的衍生，将 128 位 `xmm` 寄存器扩展至 256 位 `ymm`。AVX2 将大多数整数操作也扩展到了 256 位，并引入了 FMA。AVX512 则使用 `EVEX` 前缀编码将 AVX 进一步扩展至 512 位 `zmm`。

## IP 和 FLAGS 寄存器

指令指针和标志寄存器及其可用性如下图所示，当位数扩展时，相对应的寄存器也会扩展。指令指针寄存器的值永远等于当前将要执行的指令地址，且不能被直接修改，但可以被 `jmp`、`call` 和 `ret` 之类的指令间接修改。

标志寄存器主要用于保存运算结果的性质，如进借位、溢出、奇偶、正负等，以及当前对 CPU 的限制信息，如中断、数据复制方向、实模式和保护模式等。

![指令指针和标志寄存器](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109142212729.png)

## 段寄存器

在 IA16 下，寄存器都是 16 位的，能够寻址 64 KB 大小的空间，但 8086 提供了 20 根地址线，理论能够寻址 1 MB 的空间。其段寄存器如下图所示，IA16 使用**内存分段**的模式，用段寄存器存储代码段和数据段的起始地址，用通用寄存器和 IP 寄存器存储偏移地址，在寻址时将段寄存器左移 4 位再与偏移相加，两者共同形成逻辑地址，这样就能够使用全部的 20 根地址线，在不允许段重叠的情况下，1 MB 的内存可以被分成 65536 个段，每个段的大小为 64 KB。IA16 下程序可以自由的访问任意内存位置，并进行修改，没有对这类行为进行限制的措施，因此是不安全的。

![段寄存器](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109162153512.png)

如下图所示，在 x86 下，寄存器可以直接寻址所有的空间，因此内存寻址不再使用分段模式，而是采用线性模式，也叫**平坦模型**。而段寄存器此时将当作**段选择器**来使用，且依然保持 16 位的大小，并新增了 fs 和 gs 段寄存器。段选择器则是用来描述程序要选择的段，每个段寄存器还包括一个不可见的部分，称为**描述符高速缓存器**，里面包含段的起始地址和各种访问属性，程序不可访问，由 CPU 自动使用。在 x86 下，程序在加载时，必须先定义程序所拥有的段，包括基地址、段界限、特权级、类型等属性，程序访问段时，CPU 将进行检查，以防止对内存的违规访问。

![段选择器](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109162153142.png)

### 内存管理寄存器

此外在保护模式下还有 `gdtr`（全局描述符表寄存器）、`idtr`（中断描述符表寄存器）、`ldtr`（局部描述符表寄存器）和 `tr`（任务寄存器）这四个特殊的段寄存器，用于指定内存分段管理所用系统表的基地址和一些段的属性，如段界限、特权级、状态、任务等，CPU 为这些寄存器的加载和保存都提供了特殊的指令。

![GDTR、IDTR、LDTR 和 TR](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202201310846838.png)

gdtr 用于存放 GDT 的 32 / 64 位的线性基地址和 16 位的表长度。在CPU 刚加电或复位后，基地址被默认值为 0，长度值为 FFFFh，在保护模式初始化过程中必须给 GDTR 加载一个新值。

idtr 与 gdtr 的作用类似，用于存放 IDT 的 32 / 64 位线性基地址和 16 位表长度，默认值与 gdtr 也相同。

ldtr 用于存放 LDT 的 32 / 64 位线性基地址、16 位段限长和描述符的属性值，默认值与 gdtr 也相同。包含 LDT 的段必须在 GDT 中有一个段描述符项。

tr 用于存放 TSS 段的 16 位段选择符、32 / 64 位基地址、16 位段长度和描述符属性值。它引用 GDT 中的一个 TSS 类型的描述符，当执行任务切换时，处理器会把新任务的 TSS 的段选择符和段描述符自动加载进 tr 中。

## 调试寄存器

调试寄存器主要用来设置硬件断点，其可用性如下图所示，因为只有 `dr0` ~ `dr3` 能够设置断点地址，因此最多可以设置 4 个硬件断点，断点可以是读、写或执行，长度可以是 1、2、4 字节。当作读、写断点时，只有前 4 个字节起作用；当作执行断点时，只能设置为 1 字节。`dr4` 和 `dr5` 为保留，`dr6` 和 `dr7` 为状态和控制寄存器。当位数扩展时，相对应的寄存器也会扩展，但只有低 32 位有效，在 x64 下，高 32 位会被置 0。**由于调试寄存器是在执行过后才会产生异常，因此在触发断点后，对应的指令或数据已被执行或修改**。

![调试寄存器](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202201310814202.png)

## 控制寄存器

控制寄存器是一些特殊的寄存器，可以设置 CPU 的一些重要特性，与分页机制密切相关，在进程管理及虚拟内存管理中会涉及到这几个寄存器，当位数扩展时，相对应的寄存器也会扩展，其中 `cr1`、`cr5` ~ `cr7` 为保留。

`cr0` 主要用于保护模式、类型扩展、分页机制等功能。`cr2` 是页故障线性地址寄存器，保存最后一次出现页故障的线性地址。`cr3` 是页目录基址寄存器，保存页目录表的物理地址。`cr4` 主要用于控制虚拟 8086 模式、启用 I/O 断点、页大小扩展和等操作。

![控制寄存器](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202201310817692.png)

在 64 位下新增了几个扩展控制寄存器，`efer` 是扩展功能启用寄存器，允许启用 `syscall` 和 `sysret` 指令，以及进入和退出长模式。`cr8` 使用 `rex` 前缀可访问，用于确定外部中断的优先级，也称为任务优先级寄存器 `tpr`。`xcr0` 用于切换特定功能，以启用或禁用处理器的某些功能，如是否开启对 SSE、AVX 指令集的支持。

![扩展控制寄存器](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202201310817270.png)

# 4 地址和数据

32 和 64 位除了存储单元和指令的操作数长度不一样，其可寻址的范围也不一样，这在逆向中需要特别注意。

## 寻址范围

在 32 位下，可寻址的范围是 `0` ~ `FFFFFFFFh`，即 4 GB 的大小；在 64 位下，可寻址的范围扩大到理论 16 EB。但由于多方面的限制，这两者均无法做到纯 64 位指令集的 1 PB（50 位）和 16 EB（64 位）的物理和虚拟内存寻址（而 IA64 可以）。其原因在于 EM64T 和 AMD64 本质上仍是基于 IA32 的指令集，只是 Intel 和 AMD 分别采用不同的技术对 IA32 进行扩展，从而实现对 64 位的支持。这两者都只能实现 1 TB（40 位）的物理内存寻址和 256 TB（48 位）的虚拟内存寻址。不过实际上 64 位程序可寻址的范围是 `0` ~ `00007FFFFFFFFFFFh`，超出这个范围会产生异常。此外，在 32 位上指针的长度是 4 字节，64 位上是 8 字节。

## 虚拟地址

32 位的地址空间在 0 ~ 4 GB 的范围内，平坦模型使每个进程都有自己的虚拟地址空间，程序的代码和数据都放在同一地址空间中，不用像 16 位程序那样区分代码段和数据段。

现代操作系统多为分时多任务系统，CPU 时间被分成一个个时间片段给不同的程序，在这个时间片段中，与该程序无关的内容不会被映射到线性地址中，因此每个程序都有自己独立的 4 GB 寻址空间，互不干扰。

虚拟内存不是真正的内存，通过映射的方法使虚拟地址达到 4 GB，每个应用程序可以分配 2 GB ~ 3 GB 的大小，剩下的为操作系统保留。

在物理内存中，操作系统和系统 DLL 需要供每个程序调用，因此在任意时刻都被映射，应用程序只在自己所属的时间片段被映射，应用程序 DLL 则只在被使用时映射。

当一个应用程序启动时，操作系统就创建一个进程，并分配适合大小的虚拟地址，而不是实际的内存。虚拟内存管理器将应用程序代码映射到虚拟地址的某个位置，并加载到物理内存，虚拟地址和物理地址并没有对应关系。若程序使用了 DLL，则也会被映射到虚拟地址中，在需要时才会被加载到物理内存。程序的数据、堆栈等数据的空间是从物理内存中分配，然后被映射到虚拟地址中。程序从虚拟地址中的位置开始执行，然后虚拟内存管理器把每次内存访问映射到物理地址。

其特性可以总结为：

- 应用程序不会直接访问物理地址；
- 虚拟内存管理器通过虚拟地址的访问请求来控制物理地址的访问；
- 程序之间的地址空间是隔离的；
- DLL 之间没有隔离，因为其总是被加载到不同的应用程序地址空间中，而不能单独运行；
- 应用程序的虚拟地址通常是固定的，但其加载的 DLL 不一定固定。

IA16 下没有虚拟地址的机制，程序可以直接访问物理地址。而在 x86 下，虚拟内存简化了内存的管理，防止了多任务下程序之间的冲突，提高了安全性。

64 位的地址空间变得更大，但其机制和 32 位下的虚拟内存管理也是相同的。

## 数据格式

为了指明操作数据的大小，Intel 汇编格式的字节宽度修饰词如下表所示：

|  修饰词 | 含义           |
| ------: | -------------- |
|    byte | 字节，8 位     |
|    word | 字，16 位      |
|   dword | 双字，32 位    |
|   qword | 四字，64 位    |
|  mmword | 浮点数，64 位  |
| xmmword | 浮点数，128 位 |
| ymmword | 浮点数，256 位 |

## 数据对齐

大多数情况下，计算机对数据对象的起始地址要求必须为 2、4、8 或 16 的倍数，这取决于指令操作数的宽度。这种对齐限制简化了 CPU 和内存系统之间接口的硬件设计，如从内存中读取一个 double 数据，若该数据的地址为 8 的倍数，则只需要进行一次内存访问，否则可能进行两次，因为数据对象可能被放在 2 个 8 字节大小的内存块中，这样就可以提升内存系统的性能。

大多数 x86 指令并不强制内存对齐，无论是否对齐都可以正常工作。部分指令，如 SSE 指令集以 16 字节的长度对数据块进行操作，要求数据的内存起始地址必须为 16 的倍数，否则会产生异常。内存分配函数，如 malloc、calloc 函数等，生成的块的起始地址都为 16 的倍数，大多数函数的栈帧边界也必须为 16 的倍数。

在一些情况下，除了数据要求对齐，指令本身的起始地址也必须对齐。

考虑如下 C 代码：

```c
int main(int argc, char *argv[]) {
    for (int i = 0; i < argc; i++)
        printf("i = %d\n", i);

    return 0;
}
```

开启 O2 优化后，其汇编代码如下：

```assembly
; int main(int argc, char *argv[])
00E31040  push        ebp
00E31041  mov         ebp,esp
00E31043  push        esi
00E31044  push        edi
; for (int i = 0; i < argc; i++)
00E31045  mov         edi,dword ptr [ebp+8]
00E31048  xor         esi,esi
00E3104A  test        edi,edi
00E3104C  jle         00E31063
00E3104E  xchg        ax,ax                 ; 对齐操作
; printf("i = %d\n", i);
00E31050  push        esi
00E31051  push        0E32100h
00E31056  call        00E31010
00E3105B  inc         esi
00E3105C  add         esp,8
00E3105F  cmp         esi,edi
00E31061  jl          00E31050
00E31063  pop         edi
; return 0;
00E31064  xor         eax,eax
00E31066  pop         esi
00E31067  pop         ebp
00E31068  ret
```

实际上在没有开启 O2 优化时，并没有对齐操作。由于循环体的起始地址是跳转指令经常读取的部分，因此在开启优化后会进行对齐处理。此外不同的编译器对内存对齐的处理也有所不同。

对于 C 结构，编译器可能会在其中插入间隙，以保证每个结构体成员都满足对齐要求。考虑如下结构：

```c
struct s1 {
    int i;
    char c;
    int j;
};
```

如下图所示，结构 s1 的成员变量 i 和 c 的起始地址满足对齐要求，但需要在 j 前面填充 3 字节，以满足对齐要求，整个结构被打包为 12 字节。

![结构 s1](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109151552803.png)

再考虑如下结构：

```c
struct s2 {
    int i;
    int j;
    char c;
};

struct s2 a[4];
```

如下图所示，结构 s2 本身三个成员都是字节对齐的，可以打包为 9 字节，但是结构数组 a 包含 4 个元素，如果被打包为 9 字节，那么这些元素的起始地址为 a、a + 9、a + 18 和 a + 27，很明显并不满足字节对齐，因此编译器会在 c 后面填充 3 个字节，最后被打包为 12 字节。这样一来，a 的 4 个元素的起始地址为 a、a + 12、a + 24 和 a + 36，都为 4 的倍数，满足了对齐要求。

![结构 s2](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109151552417.png)

## 字节序

**字节序**表示数据在存储器中的存储和传输顺序，分为大端序和小端序两种：

- 大端序，即高位字节存入低地址，低位字节存入高地址；

- 小端序，即低位字节存入低地址，高位字节存入高地址。

如把数据 `12345678h` 放到内存的 `0x1000h` 处，其状态如下表所示：

| 地址  | 大端序 | 小端序 |
| :---: | :----: | :----: |
| 1000h |  12h   |  78h   |
| 1001h |  34h   |  56h   |
| 1002h |  67h   |  34h   |
| 1003h |  78h   |  12h   |

从视觉上来说，大端序更符合人的习惯。x86 使用小端序，ARM 默认使用小端序，但可以切换为大端序。PowerPC 使用大端序，网络数据也使用大端序来传输。字符串没有字节序，但在表现上是大端序。

如把字符串 `abcd`（ASCII 码为 `61626364h`）放到内存的 `0x1000h` 处，其状态如下表所示：

| 地址  |  数据   |
| :---: | :-----: |
| 1000h | a / 61h |
| 1001h | b / 62h |
| 1002h | c / 63h |
| 1003h | d / 64h |

# 5 可执行程序

在逆向中，通常是直接对可执行程序进行分析，如在 Windows 上，可以将 `.exe` 文件直接用 IDA Pro 打开进行静态分析。除此之外，还可以对库进行分析。

## 库

库是写好的现有的、成熟的、可以复用的代码。实际中每个程序都要依赖很多基础的底层库，不可能每个程序的代码都从零开始，因此库是非常重要的。本质上来说库是一种可执行代码，可以被操作系统载入内存执行。库分为**静态库**和**动态库**，Windows 上对应的是 `.lib` 和 `.dll`，Linux 上则是 `.a` 和 `.so`。

## 静态和动态链接

源代码被编译为可执行文件的过程如下图所示：

![程序的生成](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109170246818.png)

静态库与动态库的区别来自于程序在编译后链接生成可执行程序时是如何处理库的，分为**静态链接**和**动态链接**。

静态链接是在链接阶段，会将汇编生成的目标文件 `.o` 与引用到的库一起链接打包到可执行文件中。静态库可以看成是一组目标文件（`.o` / `.obj`）的集合，即很多目标文件经过压缩后打包后成的一个文件。

静态库最大的两个缺点，一个是空间浪费极大，因为每一个使用该静态库的程序都具有一份拷贝，这些拷贝占据了大量的空间，因此可重用性低。另一个是如果静态库更新了，那么使用它的程序都需要重新编译再发布。

**静态链接的特点：**

- 对库的链接在编译时完成；

- 程序运行时不再依赖库，可移植性强；

- 程序体积较大，因为所有相关的目标文件和库都被链接成一个可执行文件；
- 修改代码后需全部重新编译链接，开发效率较低。

动态链接是在程序编译时库并不会被连接到目标文件中，而是把依赖库的信息写入，在程序运行后根据该信息从系统中载入。动态库把对库的链接载入推迟到程序运行的时期，因此动态库也被称为共享库。不同的程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，避免了空间的浪费。由于动态库在程序运行时才被载入，因此也解决了静态库对程序的更新所带来的问题，只需要更新动态库即可。

**动态链接的特点：**

- 可以实现进程间资源的共享；
- 程序更新方便；
- 程序体积小；
- 库需要在运行的环境下存在，否则会因程序无法加载库而无法运行。

## 可执行文件格式

### PE

PE（Portable Executable，可移植性可执行）是 Windows 下用于可执行文件、目标文件和动态链接库的文件格式，由 UNIX 下的 COFF 格式发展而来，也叫 PE/COFF。32 位为 PE32，64 位为 PE+ 或 PE32+，其分类如下表所示：

|         类型 | 扩展名        |
| -----------: | ------------- |
|   可执行系列 | exe、scr      |
|       库系列 | dll、ocx、cpl |
| 驱动程序系列 | sys           |
| 对象文件系列 | obj           |

### ELF

ELF（Executable and Linkable Format，可执行可链接格式）是 Linux 下用于可执行文件、共享库、目标文件和 Core Dump 的文件格式，因其可扩展性与灵活性，也可应用在其它处理器、计算机系统架构的操作系统上。

# 6 System V ABI

System V ABI 是一组规范，详细说明了调用约定、目标文件格式、可执行文件格式、动态链接语义，以及符合 X / Open 通用应用程序环境规范和 System V 接口定义的系统的更多规范，是 Linux、BSD 和 macOS 等操作系统使用的标准 ABI，ELF 也是 System V ABI 的一部分。

如下图所示，为通用寄存器在 x64 下调用约定时的作用。

![x64 调用约定](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109170307331.png)

在 x86 下，Windows 函数调用约定与 System V ABI 基本一致，但在 x64 下有很大区别，在逆向时，需要特别注意。
