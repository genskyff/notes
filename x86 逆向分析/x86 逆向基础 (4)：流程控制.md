# 1 分支语句

## if 语句

if 语句是分支结构的重要组成部分，根据表达式的真假来跳转到对应的指令执行。真值为非 0 值，假为 0 值。

if 语句的通常汇编形式如下：

```assembly
cmp a,b
jcc address
```

整数用 `cmp` 指令比较，浮点数用 `fcom`、`fcomp`、`comiss`、`comisd` 等指令比较。

比较指令将操作数相减，但不会修改操作数，而是影响标志位，如 ZF、SF、OF、CF。`jcc` 指令是条件跳转指令，根据标志位的结果决定是否跳转，如 jz / jnz / je / jne 等等。

由于逻辑问题，汇编代码会对表达式的结果进行取反，即为假时才跳转，否则顺序执行，如下：

```c
if (a > b) {...}    // 这里是大于
else {...}
```

其汇编代码可能为：

```assembly
cmp a,b
jle else            ; 这里是小于等于
...
jmp if_end
else:
...
end:
```

编译器会尽量使用 `test` 或 `or` 之类的较短的指令来替换 cmp 指令，使用 `cmovcc` 或 `fcmovcc` 之类的条件传输指令来替换转移指令，以提高效率。

test 指令将操作数进行逻辑与运算，根据结果改变标志位，如 `test eax,eax`，若 eax 的值为 0，则 ZF 标志位置 1，否则置 0。

### if

考虑如下 C 代码：

```c
int main(void) {
    int a;
    scanf("%d", &a);
    if (a == 0)
        a++;
    printf("%d\n", a);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(void)
009F1100  push        ebp
009F1101  mov         ebp,esp
009F1103  push        ecx
; int a;
; scanf("%d", &a);
009F1104  lea         eax,[ebp-4]
009F1107  push        eax
009F1108  push        9F3024h
009F110D  call        009F10C0
009F1112  add         esp,8
; if (a == 0)
009F1115  cmp         dword ptr [ebp-4],0
009F1119  jne         009F1124
; a++;
009F111B  mov         ecx,dword ptr [ebp-4]
009F111E  add         ecx,1
009F1121  mov         dword ptr [ebp-4],ecx
; printf("%d\n", a);
009F1124  mov         edx,dword ptr [ebp-4]     ; end
009F1127  push        edx
009F1128  push        9F3020h
009F112D  call        009F1050
009F1132  add         esp,8
; return 0;
009F1135  xor         eax,eax
009F1137  mov         esp,ebp
009F1139  pop         ebp
009F113A  ret
```

**特征：**

- 首先会有一个 jcc 指令用于向下跳转到 end
- if 结尾没有 jmp 指令且为 end

用伪代码表示为：

```
jcc end
{
    ...
}
end:
```

开启 O2 优化后，其汇编代码如下：

```assembly
; int main(void) {
00891080  push        ebp
00891081  mov         ebp,esp
00891083  push        ecx
; int a;
; scanf("%d", &a);
00891084  lea         eax,[ebp-4]
00891087  push        eax
00891088  push        892100h
0089108D  call        00891050
; if (a == 0)
; a++;
00891092  mov         eax,dword ptr [ebp-4]
00891095  mov         ecx,1
0089109A  test        eax,eax               ; a == 0 ? a++
0089109C  cmove       eax,ecx
; printf("%d\n", a);
0089109F  push        eax                   ; end
008910A0  push        892104h
008910A5  mov         dword ptr [ebp-4],eax
008910A8  call        00891020
008910AD  add         esp,10h
; return 0;
008910B0  xor         eax,eax
008910B2  mov         esp,ebp
008910B4  pop         ebp
008910B5  ret
```

可以看到，cmp 指令被优化成了 test 指令，跳转指令被优化成了 cmove 指令。

### if - else

考虑如下 C 代码：

```c
int main(int argc, char *argv[]) {
    if (argc > 10)
        argc++;
    else
        argc--;
    printf("%d\n", argc);

    return 0;
}
```

其汇编代码如下：

```assembly
int main(int argc, char *argv[]) {
00801080  push        ebp
00801081  mov         ebp,esp
; if (argc > 10)
00801083  cmp         dword ptr [ebp+8],0Ah
00801087  jle         00801094                  ; 到 else
; argc++;
00801089  mov         eax,dword ptr [ebp+8]
0080108C  add         eax,1
0080108F  mov         dword ptr [ebp+8],eax
00801092  jmp         0080109D                  ; 到 end
; else
; argc--;
00801094  mov         ecx,dword ptr [ebp+8]
00801097  sub         ecx,1
0080109A  mov         dword ptr [ebp+8],ecx
; printf("%d\n", argc);
0080109D  mov         edx,dword ptr [ebp+8]     ; end
008010A0  push        edx
008010A1  push        803020h
008010A6  call        00801040
008010AB  add         esp,8
; return 0;
008010AE  xor         eax,eax
008010B0  pop         ebp
008010B1  ret

```

**特征：**

- 首先会有一个 jcc 指令用于向下跳转到 else
- if 结尾有一个 jmp 指令用于向下跳转到 end
- else 结尾没有 jmp 指令且为 end

用伪代码表示为：

```
jcc else
{
    ...
    jmp end
}
else:
{
    ...
}
end:
```

### if - else if - else

考虑如下 C 代码：

```c
int main(int argc, char *argv[]) {
    if (argc > 10)
        argc++;
    else if (argc == 10)
        argc = 0;
    else
        argc--;
    printf("%d\n", argc);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(int argc, char *argv[])
00E91080  push        ebp
00E91081  mov         ebp,esp
; if (argc > 10)
00E91083  cmp         dword ptr [ebp+8],0Ah
00E91087  jle         00E91094                  ; 到 else if
; argc++;
00E91089  mov         eax,dword ptr [ebp+8]
00E9108C  add         eax,1
00E9108F  mov         dword ptr [ebp+8],eax
00E91092  jmp         00E910AC                  ; 到 end
; else if (argc == 10)
00E91094  cmp         dword ptr [ebp+8],0Ah
00E91098  jne         00E910A3                  ; 到 else
; argc = 0;
00E9109A  mov         dword ptr [ebp+8],0
00E910A1  jmp         00E910AC                  ; 到 end
; else
; argc--;
00E910A3  mov         ecx,dword ptr [ebp+8]
00E910A6  sub         ecx,1
00E910A9  mov         dword ptr [ebp+8],ecx
; printf("%d\n", argc);
00E910AC  mov         edx,dword ptr [ebp+8]     ; end
00E910AF  push        edx
00E910B0  push        0E93020h
00E910B5  call        00E91040
00E910BA  add         esp,8
; return 0;
00E910BD  xor         eax,eax
00E910BF  pop         ebp
00E910C0  ret
```

**特征：**

- 首先会有一个 jcc 指令用于向下跳转到 else if
- if 结尾有一个 jmp 指令用于向下跳转到 end
- else if 处有一个 jcc 指令用于向下跳转到 else
- else if 结尾有一个 jmp 指令用于向下跳转到 end
- else 结尾没有 jmp 指令且为 end

用伪代码表示为：

```
jcc else if
{
    ...
    jmp end
}
else if:
{
    jcc else
    ...
    jmp end
}
else:
{
    ...
}
end:
```

## switch - case 语句

switch 语句就是多分支选择语句，通常比 if 语句有更高的效率，编译器有多种优化方案，如当分支数小于某数时，会直接使用 if - else 语句，大于某数时才会进行优化。

### 分支数较少

当分支数较少时，考虑如下 C 代码：

```c
int main(int argc, char *argv[]) {
    switch (argc)
    {
    case 1:
        argc++;
        break;
    case 2:
        argc += 2;
        break;
    }
    printf("%d\n", argc);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(int argc, char *argv[])
00061080  push        ebp
00061081  mov         ebp,esp
00061083  push        ecx
; switch (argc)
00061084  mov         eax,dword ptr [ebp+8]
00061087  mov         dword ptr [ebp-4],eax
0006108A  cmp         dword ptr [ebp-4],1
0006108E  je          00061098
00061090  cmp         dword ptr [ebp-4],2
00061094  je          000610A3
00061096  jmp         000610AC
; case 1:
; argc++;
00061098  mov         ecx,dword ptr [ebp+8]
0006109B  add         ecx,1
0006109E  mov         dword ptr [ebp+8],ecx
000610A1  jmp         000610AC                  ; break
; case 2:
; argc += 2;
000610A3  mov         edx,dword ptr [ebp+8]
000610A6  add         edx,2
000610A9  mov         dword ptr [ebp+8],edx
; printf("%d\n", argc);
000610AC  mov         eax,dword ptr [ebp+8]     ; end
000610AF  push        eax
000610B0  push        63020h
000610B5  call        00061040
000610BA  add         esp,8
; return 0;
000610BD  xor         eax,eax
000610BF  mov         esp,ebp
000610C1  pop         ebp
000610C2  ret
```

开启 O2 优化后，其汇编代码如下：

```assembly
; int main(int argc, char *argv[])
00C41040  push        ebp
00C41041  mov         ebp,esp
; switch (argc)
00C41043  mov         ecx,dword ptr [ebp+8]
00C41046  mov         eax,ecx
00C41048  sub         eax,1
00C4104B  je          00C41069              ; argc == 1 ？ 跳转
00C4104D  sub         eax,1
00C41050  jne         00C4106E              ; argc != 2 ？ 跳转
; case 2:
; argc += 2;
00C41052  mov         ecx,4
; printf("%d\n", argc);
00C41057  push        ecx                   ; end_1
00C41058  push        0C42100h
00C4105D  call        00C41010
00C41062  add         esp,8
; return 0;
00C41065  xor         eax,eax
00C41067  pop         ebp
00C41068  ret
; case 1:
; argc++;
00C41069  mov         ecx,2
; printf("%d\n", argc);
00C4106E  push        ecx                   ; end_2
00C4106F  push        0C42100h
00C41074  call        00C41010
00C41079  add         esp,8
; return 0;
00C4107C  xor         eax,eax
00C4107E  pop         ebp
00C4107F  ret
```

可以看到，没有优化时，把 switch 当作 if 处理，使用 cmp 指令比较；开启优化后，将使用算术指令替代。

### 跳转表

若 case 的项数较多、间隔较大，或取值具有一定规律，那么编译器会利用**跳转表**来实现。

考虑如下 C 代码：

```c
int main(int argc, char *argv[]) {
    switch (argc)
    {
    case 1:
        argc++; break;
    case 2:
        argc += 2; break;
    case 3:
        argc += 3; break;
    case 6:
        argc += 4; break;
    case 10:
        argc += 5; break;
    case 100:
        argc += 100; break;
    case 101:
        argc += 101; break;
    }
    printf("%d\n", argc);

    return 0;
}
```

使用 IDA 反汇编后，其代码如下：

```assembly
.text:00401080 ; int __cdecl main(int argc, const char **argv, const char **envp)
.text:00401080 _main proc near               ; CODE XREF: __scrt_common_main_seh+F5↓p
.text:00401080
.text:00401080 var_4= dword ptr -4
.text:00401080 argc= dword ptr  8
.text:00401080 argv= dword ptr  0Ch
.text:00401080 envp= dword ptr  10h
.text:00401080
.text:00401080 push    ebp
.text:00401081 mov     ebp, esp
.text:00401083 push    ecx
.text:00401084 mov     eax, [ebp+argc]
.text:00401087 mov     [ebp+var_4], eax
.text:0040108A mov     ecx, [ebp+var_4]
.text:0040108D sub     ecx, 1                ; switch 101 cases
.text:00401090 mov     [ebp+var_4], ecx
.text:00401093 cmp     [ebp+var_4], 64h
.text:00401097 ja      short $LN2            ; jumptable 004010A3 default case, cases 4,5,7-9,11-99
.text:00401099 mov     edx, [ebp+var_4]
.text:0040109C movzx   eax, ds:byte_40112C[edx]
.text:004010A3 jmp     ds:jpt_4010A3[eax*4]  ; switch jump
.text:004010AA ; ---------------------------------------------------------------
.text:004010AA $LN4:                         ; CODE XREF: _main+23↑j
.text:004010AA                               ; DATA XREF: _main:jpt_4010A3↓o
.text:004010AA mov     ecx, [ebp+argc]       ; jumptable 004010A3 case 1
.text:004010AD add     ecx, 1
.text:004010B0 mov     [ebp+argc], ecx
.text:004010B3 jmp     short $LN2            ; jumptable 004010A3 default case, cases 4,5,7-9,11-99
.text:004010B5 ; ---------------------------------------------------------------
.text:004010B5 $LN5:                         ; CODE XREF: _main+23↑j
.text:004010B5                               ; DATA XREF: _main:jpt_4010A3↓o
.text:004010B5 mov     edx, [ebp+argc]       ; jumptable 004010A3 case 2
.text:004010B8 add     edx, 2
.text:004010BB mov     [ebp+argc], edx
.text:004010BE jmp     short $LN2            ; jumptable 004010A3 default case, cases 4,5,7-9,11-99
.text:004010C0 ; ---------------------------------------------------------------
.text:004010C0 $LN6:                         ; CODE XREF: _main+23↑j
.text:004010C0                               ; DATA XREF: _main:jpt_4010A3↓o
.text:004010C0 mov     eax, [ebp+argc]       ; jumptable 004010A3 case 3
.text:004010C3 add     eax, 3
.text:004010C6 mov     [ebp+argc], eax
.text:004010C9 jmp     short $LN2            ; jumptable 004010A3 default case, cases 4,5,7-9,11-99
.text:004010CB ; ---------------------------------------------------------------
.text:004010CB $LN7:                         ; CODE XREF: _main+23↑j
.text:004010CB                               ; DATA XREF: _main:jpt_4010A3↓o
.text:004010CB mov     ecx, [ebp+argc]       ; jumptable 004010A3 case 6
.text:004010CE add     ecx, 4
.text:004010D1 mov     [ebp+argc], ecx
.text:004010D4 jmp     short $LN2            ; jumptable 004010A3 default case, cases 4,5,7-9,11-99
.text:004010D6 ; ---------------------------------------------------------------
.text:004010D6 $LN8:                         ; CODE XREF: _main+23↑j
.text:004010D6                               ; DATA XREF: _main:jpt_4010A3↓o
.text:004010D6 mov     edx, [ebp+argc]       ; jumptable 004010A3 case 10
.text:004010D9 add     edx, 5
.text:004010DC mov     [ebp+argc], edx
.text:004010DF jmp     short $LN2            ; jumptable 004010A3 default case, cases 4,5,7-9,11-99
.text:004010E1 ; ---------------------------------------------------------------
.text:004010E1 $LN9:                         ; CODE XREF: _main+23↑j
.text:004010E1                               ; DATA XREF: _main:jpt_4010A3↓o
.text:004010E1 mov     eax, [ebp+argc]       ; jumptable 004010A3 case 100
.text:004010E4 add     eax, 64h ; 'd'
.text:004010E7 mov     [ebp+argc], eax
.text:004010EA jmp     short $LN2            ; jumptable 004010A3 default case, cases 4,5,7-9,11-99
.text:004010EC ; ---------------------------------------------------------------
.text:004010EC $LN10:                        ; CODE XREF: _main+23↑j
.text:004010EC                               ; DATA XREF: _main:jpt_4010A3↓o
.text:004010EC mov     ecx, [ebp+argc]       ; jumptable 004010A3 case 101
.text:004010EF add     ecx, 65h ; 'e'
.text:004010F2 mov     [ebp+argc], ecx
.text:004010F5
.text:004010F5 $LN2:                         ; CODE XREF: _main+17↑j
.text:004010F5                               ; _main+23↑j _main+33↑j
.text:004010F5                               ; _main+3E↑j _main+49↑j
.text:004010F5                               ; _main+54↑j _main+5F↑j
.text:004010F5                               ; _main+6A↑j
.text:004010F5                               ; DATA XREF: _main:jpt_4010A3↓o
.text:004010F5 mov     edx, [ebp+argc]       ; jumptable 004010A3 default case, cases 4,5,7-9,11-99
.text:004010F8 push    edx
.text:004010F9 push    offset _Format        ; "%d\n"
.text:004010FE call    _printf
.text:00401103 add     esp, 8
.text:00401106 xor     eax, eax
.text:00401108 mov     esp, ebp
.text:0040110A pop     ebp
.text:0040110B retn
.text:0040110B ; ---------------------------------------------------------------
.text:0040110C jpt_4010A3 dd offset $LN4     ; DATA XREF: _main+23↑r
.text:0040110C dd offset $LN5                ; jump table for switch statement
.text:0040110C dd offset $LN6
.text:0040110C dd offset $LN7
.text:0040110C dd offset $LN8
.text:0040110C dd offset $LN9
.text:0040110C dd offset $LN10
.text:0040110C dd offset $LN2
.text:0040112C byte_40112C db  0, 1, 2, 7, 7, 3, 7, 7, 7, 4, 7, 7, 7, 7, 7
.text:0040112C                               ; DATA XREF: _main+1C↑r
.text:0040112C db  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 ; indirect table for switch statement
.text:0040112C db  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
.text:0040112C db  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
.text:0040112C db  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
.text:0040112C db  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
.text:0040112C db  7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 6
.text:0040112C _main end
```

可以看到，编译器避免使用 if 语句，将所有需要跳转的 case 位置偏移放在一个叫做 case 表的一维数组中，然后把 case 值当成数组下标或从另一个下标数组的表中获取下标来进行跳转。

跳转表的一般形式为：

| 数组下标 | 数组内容         |
| -------: | ---------------- |
|        0 | case 1 语句偏移  |
|        1 | case 2 语句偏移  |
|        2 | case 3 语句偏移  |
|       3+ | case 4 语句偏移+ |

如第 20 和 21 行代码：

```assembly
.text:0040109C movzx   eax, ds:byte_40112C[edx]
.text:004010A3 jmp     ds:jpt_4010A3[eax*4]  ; switch jump
```

`jpt_4010A3` 这个跳转表的下标来自 `byte_40112C` 这个数组，然后才是真正的跳转位置。

### 判定树

编译器对 switch 还有另一种优化方案，当 case 项较多或间隔很大没有规律时，为了减少 if 语句，使用**判定树**来实现。将每个 case 值当作一个节点，从这些节点中找到一个中间值作为根节点，形成一颗平衡二叉树，以每个节点判定值，大于或小于关系分别对应于左右子树，以提高效率。

考虑如下 C 代码：

```c
int main(int argc, char *argv[]) {
    switch (argc)
    {
    case 1:
        argc++;break;
    case 8:
        argc += 2;break;
    case 30:
        argc += 3;break;
    case 65:
        argc += 4;break;
    case 99:
        argc += 5;break;
    case 205:
        argc += 6;break;
    case 500:
        argc += 7;break;
    }

    return 0;
}
```

使用 IDA 反汇编后，其代码如下：

```assembly
.text:00401080 ; int __cdecl main(int argc, const char **argv, const char **envp)
.text:00401080 _main proc near               ; CODE XREF: __scrt_common_main_seh+F5↓p
.text:00401080
.text:00401080 var_4= dword ptr -4
.text:00401080 argc= dword ptr  8
.text:00401080 argv= dword ptr  0Ch
.text:00401080 envp= dword ptr  10h
.text:00401080
.text:00401080 push    ebp
.text:00401081 mov     ebp, esp
.text:00401083 push    ecx
.text:00401084 mov     eax, [ebp+argc]
.text:00401087 mov     [ebp+var_4], eax
.text:0040108A cmp     [ebp+var_4], 41h ; 'A'
.text:0040108E jg      short loc_4010AA
.text:00401090 cmp     [ebp+var_4], 41h ; 'A'
.text:00401094 jz      short loc_4010E5
.text:00401096 cmp     [ebp+var_4], 1
.text:0040109A jz      short loc_4010C4
.text:0040109C cmp     [ebp+var_4], 8
.text:004010A0 jz      short loc_4010CF
.text:004010A2 cmp     [ebp+var_4], 1Eh
.text:004010A6 jz      short loc_4010DA
.text:004010A8 jmp     short loc_40110F
.text:004010AA ; ---------------------------------------------------------------
.text:004010AA loc_4010AA:                   ; CODE XREF: _main+E↑j
.text:004010AA cmp     [ebp+var_4], 63h ; 'c'
.text:004010AE jz      short loc_4010F0
.text:004010B0 cmp     [ebp+var_4], 0CDh
.text:004010B7 jz      short loc_4010FB
.text:004010B9 cmp     [ebp+var_4], 1F4h
.text:004010C0 jz      short loc_401106
.text:004010C2 jmp     short loc_40110F
.text:004010C4 ; ---------------------------------------------------------------
.text:004010C4 loc_4010C4:                   ; CODE XREF: _main+1A↑j
.text:004010C4 mov     ecx, [ebp+argc]
.text:004010C7 add     ecx, 1
.text:004010CA mov     [ebp+argc], ecx
.text:004010CD jmp     short loc_40110F
.text:004010CF ; ---------------------------------------------------------------
.text:004010CF loc_4010CF:                   ; CODE XREF: _main+20↑j
.text:004010CF mov     edx, [ebp+argc]
.text:004010D2 add     edx, 2
.text:004010D5 mov     [ebp+argc], edx
.text:004010D8 jmp     short loc_40110F
.text:004010DA ; ---------------------------------------------------------------
.text:004010DA loc_4010DA:                   ; CODE XREF: _main+26↑j
.text:004010DA mov     eax, [ebp+argc]
.text:004010DD add     eax, 3
.text:004010E0 mov     [ebp+argc], eax
.text:004010E3 jmp     short loc_40110F
.text:004010E5 ; ---------------------------------------------------------------
.text:004010E5 loc_4010E5:                   ; CODE XREF: _main+14↑j
.text:004010E5 mov     ecx, [ebp+argc]
.text:004010E8 add     ecx, 4
.text:004010EB mov     [ebp+argc], ecx
.text:004010EE jmp     short loc_40110F
.text:004010F0 ; ---------------------------------------------------------------
.text:004010F0 loc_4010F0:                   ; CODE XREF: _main+2E↑j
.text:004010F0 mov     edx, [ebp+argc]
.text:004010F3 add     edx, 5
.text:004010F6 mov     [ebp+argc], edx
.text:004010F9 jmp     short loc_40110F
.text:004010FB ; ---------------------------------------------------------------
.text:004010FB loc_4010FB:                   ; CODE XREF: _main+37↑j
.text:004010FB mov     eax, [ebp+argc]
.text:004010FE add     eax, 6
.text:00401101 mov     [ebp+argc], eax
.text:00401104 jmp     short loc_40110F
.text:00401106 ; ---------------------------------------------------------------
.text:00401106 loc_401106:                   ; CODE XREF: _main+40↑j
.text:00401106 mov     ecx, [ebp+argc]
.text:00401109 add     ecx, 7
.text:0040110C mov     [ebp+argc], ecx
.text:0040110F
.text:0040110F loc_40110F:                   ; CODE XREF: _main+28↑j
.text:0040110F                               ; _main+42↑j _main+4D↑j
.text:0040110F                               ; _main+58↑j _main+63↑j
.text:0040110F                               ; _main+6E↑j _main+79↑j
.text:0040110F                               ; _main+84↑j
.text:0040110F mov     edx, [ebp+argc]
.text:00401112 push    edx
.text:00401113 push    offset _Format        ; "%d\n"
.text:00401118 call    _printf
.text:0040111D add     esp, 8
.text:00401120 xor     eax, eax
.text:00401122 mov     esp, ebp
.text:00401124 pop     ebp
.text:00401125 retn
.text:00401125 _main endp
```

可以看到，是通过判定树来进行的，其判定树如下图所示。

![判定树](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109200120748.png)

## goto 语句

在 C 中，goto 语句可以像汇编指令中的 jmp 一样进行无条件跳转。

考虑如下 C 代码：

```c
int main(int argc, char *argv[]) {
    goto label_2;
label_1:
    argc += 5;
    goto label_3;
label_2:
    if (argc == 10)
        goto label_1;
label_3:
    printf("%d\n", argc);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(int argc, char *argv[])
00B01080  push        ebp
00B01081  mov         ebp,esp
; goto label_2;
00B01083  jmp         00B01090
label_1:
; argc += 5;
00B01085  mov         eax,dword ptr [ebp+8]
00B01088  add         eax,5
00B0108B  mov         dword ptr [ebp+8],eax
; goto label_3;
00B0108E  jmp         00B01098
label_2:
; if (argc == 10)
00B01090  cmp         dword ptr [ebp+8],0Ah
00B01094  jne         00B01098
; goto label_1;
00B01096  jmp         00B01085
label_3:
; printf("%d\n", argc);
00B01098  mov         ecx,dword ptr [ebp+8]
00B0109B  push        ecx
00B0109C  push        0B03020h
00B010A1  call        00B01040
00B010A6  add         esp,8
; return 0;
00B010A9  xor         eax,eax
00B010AB  pop         ebp
00B010AC  ret
```

可以看到， goto 指令实际上也是一个无条件跳转指令。

## 多个条件判断

if 语句的条件判断通常不仅仅会只有一个条件，很可能是各种逻辑运算的组合。

考虑如下 C 代码：

```c
int main(void) {
    int x[5] = { 1, 2, 3, 4, 5 };
    if (x[0] == 0 || x[1] < 2 && x[2] >= 4 || (x[3] ^ x[4]) == 0)
        printf("Good\n");
    else
        printf("Bad");

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(void) {
009C1080  push        ebp
009C1081  mov         ebp,esp
009C1083  sub         esp,14h
; int x[5] = { 1, 2, 3, 4, 5 };
009C1086  mov         dword ptr [ebp-14h],1
009C108D  mov         dword ptr [ebp-10h],2
009C1094  mov         dword ptr [ebp-0Ch],3
009C109B  mov         dword ptr [ebp-8],4
009C10A2  mov         dword ptr [ebp-4],5
; if (x[0] == 0 || x[1] < 2 && x[2] >= 4 || (x[3] ^ x[4]) == 0)
009C10A9  mov         eax,4
009C10AE  imul        ecx,eax,0
009C10B1  cmp         dword ptr [ebp+ecx-14h],0     ; x[0] == 0 ?
009C10B6  je          009C10EF                      ; 短路计算
009C10B8  mov         edx,4
009C10BD  shl         edx,0
009C10C0  cmp         dword ptr [ebp+edx-14h],2     ; x[1] < 2 ?
009C10C5  jge         009C10D5                      ; 短路计算
009C10C7  mov         eax,4
009C10CC  shl         eax,1
009C10CE  cmp         dword ptr [ebp+eax-14h],4     ; x[2] >= 4
009C10D3  jge         009C10EF
009C10D5  mov         ecx,4
009C10DA  imul        edx,ecx,3
009C10DD  mov         eax,4
009C10E2  shl         eax,2
009C10E5  mov         ecx,dword ptr [ebp+edx-14h]
009C10E9  xor         ecx,dword ptr [ebp+eax-14h]   ; x[3] ^ x[4] == 0 ?
009C10ED  jne         009C10FE
; printf("Good\n");
009C10EF  push        9C3024h
009C10F4  call        009C1040
009C10F9  add         esp,4
009C10FC  jmp         009C110B
; else
; printf("Bad");
009C10FE  push        9C3020h
009C1103  call        009C1040
009C1108  add         esp,4
; return 0;
009C110B  xor         eax,eax
009C110D  mov         esp,ebp
009C110F  pop         ebp
009C1110  ret
```

可以看到，将会先执行多个逻辑判断，并且由于逻辑运算是短路运算，当满足条件是，会直接跳转到对应的分支中。

# 2 循环语句

一般的分支语句如 if 通常是从低地址转移到高地址，而循环通常会从高地址转移到低地址。通常使用 jcc 指令来判断是否继续循环，或者用寄存器来计数。

## while 循环

### while

while 语句具有先进行表达式判断后执行的特点。

考虑如下 C 代码：

```c
int main(int argc, char *argv[]) {
    int i = 0;
    while (i < argc)
        printf("%d\n", i++);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(int argc, char *argv[])
00011080  push        ebp
00011081  mov         ebp,esp
00011083  sub         esp,8
; int i = 0;
00011086  mov         dword ptr [ebp-4],0
; while (i < argc)
0001108D  mov         eax,dword ptr [ebp-4]
00011090  cmp         eax,dword ptr [ebp+8]
00011093  jge         000110B7              ; 到 end
; printf("%d\n", i++);
00011095  mov         ecx,dword ptr [ebp-4]
00011098  mov         dword ptr [ebp-8],ecx
0001109B  mov         edx,dword ptr [ebp-8]
0001109E  push        edx
0001109F  push        13020h
000110A4  call        00011040
000110A9  add         esp,8
000110AC  mov         eax,dword ptr [ebp-4]
000110AF  add         eax,1
000110B2  mov         dword ptr [ebp-4],eax
000110B5  jmp         0001108D              ; 到 while
; return 0;
000110B7  xor         eax,eax               ; end
000110B9  mov         esp,ebp
000110BB  pop         ebp
000110BC  ret
```

**特征：**

- 首先会有一个 jcc 指令用于向下跳转到 end
- while 结尾有一个 jmp 指令用于向上跳转到 while。

用伪代码表示为：

```
while:
jcc end
{
    ...
}
jmp while
end:
```

### do - while

do - while 语句具有先执行后判断表达式的特点。

考虑如下 C 代码：

```c
int main(int argc, char *argv[]) {
    int i = 0;
    do {
        printf("%d\n", i++);
    } while (i < argc);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(int argc, char *argv[])
00151080  push        ebp
00151081  mov         ebp,esp
00151083  sub         esp,8
; int i = 0;
00151086  mov         dword ptr [ebp-4],0
; do
; printf("%d\n", i++);
0015108D  mov         eax,dword ptr [ebp-4]
00151090  mov         dword ptr [ebp-8],eax
00151093  mov         ecx,dword ptr [ebp-8]
00151096  push        ecx
00151097  push        153020h
0015109C  call        00151040
001510A1  add         esp,8
001510A4  mov         edx,dword ptr [ebp-4]
001510A7  add         edx,1
001510AA  mov         dword ptr [ebp-4],edx
; while (i < argc);
001510AD  mov         eax,dword ptr [ebp-4]
001510B0  cmp         eax,dword ptr [ebp+8]
001510B3  jl          0015108D              ; 到 do
; return 0;
001510B5  xor         eax,eax               ; end
001510B7  mov         esp,ebp
001510B9  pop         ebp
001510BA  ret
```

**特征：**

- 首先 do 结尾没有跳转指令
- while 处有一个 jcc 用于向上跳转到 do

用伪代码表示为：

```
do:
{
    ...
}
while:
jcc while
end:
```

## for 循环

for 语句由初始化、条件和步长这三条语句组成，其中初始化只会执行一次。

考虑如下 C 代码：

```c
int main(int argc, char *argv[]) {
    for (int i = 0; i < argc; i++)
        printf("i = %d\n", i);

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(int argc, char *argv[])
004D1080  push        ebp
004D1081  mov         ebp,esp
004D1083  push        ecx
; for (int i = 0; i < argc; i++)
004D1084  mov         dword ptr [ebp-4],0
004D108B  jmp         004D1096                  ; 到 if
004D108D  mov         eax,dword ptr [ebp-4]     ; step
004D1090  add         eax,1
004D1093  mov         dword ptr [ebp-4],eax
004D1096  mov         ecx,dword ptr [ebp-4]     ; if
004D1099  cmp         ecx,dword ptr [ebp+8]
004D109C  jge         004D10B1                  ; 到 end
; printf("%d\n", i);
004D109E  mov         edx,dword ptr [ebp-4]
004D10A1  push        edx
004D10A2  push        4D3020h
004D10A7  call        004D1040
004D10AC  add         esp,8
004D10AF  jmp         004D108D                  ; 到 step
; return 0;
004D10B1  xor         eax,eax                   ; end
004D10B3  mov         esp,ebp
004D10B5  pop         ebp
004D10B6  ret
```

**特征：**

- 首先会有一个 jmp 指令用于向下跳转到 if
- if 处有一个 jcc 指令用于向下跳转到 end
- for 结尾有一个 jmp 指令用于向上跳转到 step；
- step 中没有跳转指令

用伪代码表示为：

```
jmp if:
step:
{
    ...
}
if:
jcc end
{
    ...
}
jmp step
end:
```

## break 和 continue

break 和 continue 都可以用在循环中，前者直接退出循环，后者不执行之后循环体中的语句，而是开始新的循环。

考虑如下 C 代码：

```c
int main(int argc, char *argv[]) {
    while (argc > 0) {
        if (argc == 1)
            break;
        if (argc-- > 5)
            continue;
        printf("%d\n", argc--);
    }

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(int argc, char *argv[])
00031080  push        ebp
00031081  mov         ebp,esp
00031083  sub         esp,8
; while (argc > 0)
00031086  cmp         dword ptr [ebp+8],0
0003108A  jle         000310CD              ; 到 end
; if (argc == 1)
0003108C  cmp         dword ptr [ebp+8],1
00031090  jne         00031094
; break;
00031092  jmp         000310CD              ; 到 end
; if (argc-- > 5)
00031094  mov         eax,dword ptr [ebp+8]
00031097  mov         dword ptr [ebp-4],eax
0003109A  mov         ecx,dword ptr [ebp+8]
0003109D  sub         ecx,1
000310A0  mov         dword ptr [ebp+8],ecx
000310A3  cmp         dword ptr [ebp-4],5
000310A7  jle         000310AB
; continue;
000310A9  jmp         00031086              ; 到 while
; printf("%d\n", argc--);
000310AB  mov         edx,dword ptr [ebp+8]
000310AE  mov         dword ptr [ebp-8],edx
000310B1  mov         eax,dword ptr [ebp-8]
000310B4  push        eax
000310B5  push        33020h
000310BA  call        00031040
000310BF  add         esp,8
000310C2  mov         ecx,dword ptr [ebp+8]
000310C5  sub         ecx,1
000310C8  mov         dword ptr [ebp+8],ecx
000310CB  jmp         00031086              ; 到 while
; return 0;
000310CD  xor         eax,eax               ; end
000310CF  mov         esp,ebp
000310D1  pop         ebp
000310D2  ret
```

可以看到，break 直接向下跳到 end 处，而 continue 向上跳到 while 处。

## 循环比较

以上三种循环实现的功能逻辑是一样的，但在细节上中有一些的差别。while 循环有 2 条转移指令，do - while 循环只有 1 条转移指令，因此 do - while 的效率比 while 高。for 循环在最初有一条用于跳过 step 的 jmp 指令，实际循环体中的转移指令是 2 条因此效率和 while 相同。在实际的程序中，编译器通常会将这三者优化成同等效率。

对以上三种循环，开启 O2 优化后，其汇编代码分别如下：

```assembly
; while 循环
; int main(int argc, char *argv[])
00611040  push        ebp
00611041  mov         ebp,esp
00611043  push        esi
00611044  push        edi
; int i = 0;
; while (i < argc)
00611045  mov         edi,dword ptr [ebp+8]
00611048  xor         esi,esi
0061104A  test        edi,edi
0061104C  jle         00611063              ; argc == 0 ? 到 end
0061104E  xchg        ax,ax                 ; 对齐操作
; printf("%d\n", i++);
00611050  push        esi
00611051  push        612100h
00611056  call        00611010
0061105B  inc         esi
0061105C  add         esp,8
0061105F  cmp         esi,edi
00611061  jl          00611050              ; 到 while
00611063  pop         edi                   ; end
; return 0;
00611064  xor         eax,eax
00611066  pop         esi
00611067  pop         ebp
00611068  ret

; do while 循环
; int main(int argc, char *argv[])
00EE1040  push        ebp
00EE1041  mov         ebp,esp
00EE1043  push        esi
00EE1044  push        edi
; int i = 0;
00EE1045  mov         edi,dword ptr [ebp+8]
00EE1048  xor         esi,esi
00EE104A  nop         word ptr [eax+eax]    ; 对齐操作
; do
; printf("%d\n", i++);
00EE1050  push        esi
00EE1051  push        0EE2100h
00EE1056  call        00EE1010
00EE105B  inc         esi
00EE105C  add         esp,8
; while (i < argc);
00EE105F  cmp         esi,edi
00EE1061  jl          00EE1050              ; 到 do
; return 0;
00EE1063  pop         edi                   ; end
00EE1064  xor         eax,eax
00EE1066  pop         esi
00EE1067  pop         ebp
00EE1068  ret

; for 循环
; int main(int argc, char *argv[])
00C91040  push        ebp
00C91041  mov         ebp,esp
00C91043  push        esi
00C91044  push        edi
; for (int i = 0; i < argc; i++)
00C91045  mov         edi,dword ptr [ebp+8]
00C91048  xor         esi,esi
00C9104A  test        edi,edi
00C9104C  jle         00C91063              ; argc == 0 ? 到 end
00C9104E  xchg        ax,ax                 ; 对齐操作
; printf("%d\n", i);
00C91050  push        esi
00C91051  push        0C92100h
00C91056  call        00C91010
00C9105B  inc         esi                   ; step
00C9105C  add         esp,8
00C9105F  cmp         esi,edi
00C91061  jl          00C91050              ; if
00C91063  pop         edi                   ; end
; return 0;
00C91064  xor         eax,eax
00C91066  pop         esi
00C91067  pop         ebp
00C91068  ret
```

可以看到，除了 while 和 for 开始有一条跳转指令，这三者位于循环体中的跳转指令都只有一条，经过优化后三者效率几乎相同。

## 循环嵌套

循环可以进行多层嵌套，下面的程序将输出乘法口诀表，其 C 代码如下：

```c
int main(void) {
    for (int i = 1; i <= 9; i++) {
        for (int j = 1; j <= i; j++)
            printf("%d*%d=%d\t", j, i, i * j);
        printf("\n");
    }

    return 0;
}
```

其汇编代码如下：

```assembly
; int main(void)
000C1080  push        ebp
000C1081  mov         ebp,esp
000C1083  sub         esp,8
; for (int i = 1; i <= 9; i++)
000C1086  mov         dword ptr [ebp-4],1
000C108D  jmp         000C1098
000C108F  mov         eax,dword ptr [ebp-4]
000C1092  add         eax,1                     ; 外层 step
000C1095  mov         dword ptr [ebp-4],eax
000C1098  cmp         dword ptr [ebp-4],9
000C109C  jg          000C10E6                  ; 外层 if
; for (int j = 1; j <= i; j++)
000C109E  mov         dword ptr [ebp-8],1
000C10A5  jmp         000C10B0
000C10A7  mov         ecx,dword ptr [ebp-8]
000C10AA  add         ecx,1                     ; 内层 step
000C10AD  mov         dword ptr [ebp-8],ecx
000C10B0  mov         edx,dword ptr [ebp-8]
000C10B3  cmp         edx,dword ptr [ebp-4]
000C10B6  jg          000C10D7                  ; 内层 if
; printf("%d*%d=%d\t", j, i, i * j);
000C10B8  mov         eax,dword ptr [ebp-4]
000C10BB  imul        eax,dword ptr [ebp-8]
000C10BF  push        eax
000C10C0  mov         ecx,dword ptr [ebp-4]
000C10C3  push        ecx
000C10C4  mov         edx,dword ptr [ebp-8]
000C10C7  push        edx
000C10C8  push        0C3024h
000C10CD  call        000C1040
000C10D2  add         esp,10h
000C10D5  jmp         000C10A7
; printf("\n");
000C10D7  push        0C3020h                   ; 内层 end
000C10DC  call        000C1040
000C10E1  add         esp,4
000C10E4  jmp         000C108F
; return 0;
000C10E6  xor         eax,eax                   ; 外层 end
000C10E8  mov         esp,ebp
000C10EA  pop         ebp
000C10EB  ret
```

开启 O2 优化后，其汇编代码如下：

```assembly
; int main(void)
00091040  push        ebx
00091041  push        esi
00091042  push        edi
; for (int i = 1; i <= 9; i++)
00091043  mov         esi,1
; for (int j = 1; j <= i; j++)
00091048  mov         edi,1
0009104D  mov         ebx,esi
0009104F  nop
; printf("%d*%d=%d\t", j, i, i * j);
00091050  push        ebx
00091051  push        esi
00091052  push        edi
00091053  push        92100h
00091058  call        00091010
0009105D  inc         edi       ; 内层 step
0009105E  add         esp,10h
00091061  add         ebx,esi
00091063  cmp         edi,esi
00091065  jle         00091050  ; 内层 if
; printf("\n");
00091067  push        9210Ch    ; 内层 end
0009106C  call        00091010
00091071  inc         esi       ; 外层 step
00091072  add         esp,4
00091075  cmp         esi,9
00091078  jle         00091048  ; 外层 if
; return 0;
0009107A  pop         edi       ; 外层 end
0009107B  pop         esi
0009107C  xor         eax,eax
0009107E  pop         ebx
0009107F  ret
```

可以看到，无论是优化前还是优化后的代码，嵌套循环始终遵循内层循环的代码在外层循环的内部的原则。在优化后，许多不必要的转移指令被消除了，但是整体依然还是按照单层循环时的逻辑。

# 3 转移分类

## 相对短转移

无条件和条件转移的机器码均为 2 字节，转移范围为 -128 ~ 127 字节。

有如下汇编代码：

```assembly
.text:401000 EB 08        jmp 40100A<A>
...
.text:401010 EB EE        jmp 401000<F0>
```

无条件转移的机器码为 `EBxx`，其中 xx 为偏移量，`EB00` ~ `EB7F` 为向后转移，`EB80` ~ `EBFF` 为向前转移。偏移量的计算公式为：

> 偏移量 = 目的地址 - 起始地址 - 跳转指令长度

在这个例子中，第一个跳转指令的目的地址为 40100A，起始地址为 401000，指令长度为 2，由于是向后转移，因此其机器码为 EB08。第二个跳转指令的目的地址为 401000，起始地址为 401010，指令长度为 2，由于是向前转移，因此其机器码为 EBEE。

## 相对长转移

无条件转移的机器码为 5 字节，其中 1 字节表示转移指令机器码，4 字节表示偏移量。条件转移的机器码为 6 字节，其中 2 字节表示转移指令机器码，4 字节表示偏移量。可以在 -2 GB ~ 2GB 的范围内转移。

有如下汇编代码：

```assembly
.text:401000 E9 9B00 0000        jmp 4010A0<A0>
...
.text:401100 E9 FBFE 0000        jmp 401000<FF00>
```

无条件转移的机器码为 `E9xxxxxxxx`，`E900000000` ~ `E97FFFFFFF` 为向后转移，`E980000000` ~ `E9FFFFFFFF` 为向前转移，长转移偏移量计算公式与短转移相同。

在这个例子中，第一个跳转指令的目的地址为 4010A0，起始地址为 401000，指令长度为 5，由于是向后转移，且为小端表示，因此其机器码为 E99B000000。第二个跳转指令的目的地址为 401000，起始地址为 401100，指令长度为 5，由于是向前转移，且为小端表示，因此其机器码为 E9FBFE0000。

## 函数调用

函数调用即 call 指令，机器码为 `E8xxxxxxxx`。分为两类，第一类和长转移类似，第二类涉及寄存器和栈，如 `call [eax+edx*4]`、`call [esp+4]`。

有如下汇编代码：

```assembly
; 第一类
.text:401000 E8 9B00 0000     call 4010A0<A0>

; 第二类
.text:401000 FF1490           call [eax+edx*4]
...
.text:401010 FF5424 04        call [esp+4]
```

第一类 call 指令和相对转移指令没什么区别，都是操作码加偏移量形成的指令。第二类涉及寄存器和栈的 call 指令具有专门的机器码。

## 绝对转移

x86 和 x64 在相对转移指令上没有太大区别，但是在绝对转移指令上 x64 是不同的。

有如下汇编代码：

```assembly
; x86 绝对转移
.text:401000     FF15   A010 4000        call ds:4010A0

; x64 相对转移
.text:0`00401000 FF15   9A00 0000        call ds:4010A0<rip+9A>

; x64 绝对转移
.text:0`00401000 FF1425 A010 4000        call ds:4010A0
```

在 x86 上，`FF15` 代表绝对转移操作码，后跟绝对地址，但是在 x64 上，地址是 8 字节，如果依然看作绝对地址，指令的长度就会增加，因此虽然操作码相同，但是解释成相对转移，x64 上的绝对转移使用的是另外的指令。

## 常用转移指令及其机器码

| 指令            | 标志位            | 含义                       | 短转移机器码 | 长转移机器码 |
| --------------- | ----------------- | -------------------------- | ------------ | ------------ |
| call            |                   | 函数调用                   | E8xxxxxxxx   | E8xxxxxxxx   |
| jmp             |                   | 无条件转移                 | EBxx         | E9xxxxxxxx   |
| jo              | OF = 1            | 溢出                       | 70xx         | 0F80xxxxxxxx |
| jno             | OF = 0            | 无溢出                     | 71xx         | 0F81xxxxxxxx |
| jc / jb / jnae  | CF = 1            | 进位 / 小于 / 不大于等于   | 72xx         | 0F82xxxxxxxx |
| jnc / jnb / jae | CF = 0            | 无进位 / 不小于 / 大于等于 | 73xx         | 0F83xxxxxxxx |
| je / jz         | ZF = 1            | 等于 / 等于零              | 74xx         | 0F84xxxxxxxx |
| jne / jnz       | ZF = 0            | 不等于 / 不等于零          | 75xx         | 0F85xxxxxxxx |
| jbe / jna       | CF = 1 \| ZF = 1  | 小于等于 / 不大于          | 76xx         | 0F86xxxxxxxx |
| jnbe / ja       | CF = 0 & ZF = 0   | 不小于等于 / 大于          | 77xx         | 0F87xxxxxxxx |
| js              | SF = 1            | 正数                       | 78xx         | 0F88xxxxxxxx |
| jns             | SF = 0            | 负数                       | 79xx         | 0F89xxxxxxxx |
| jp / jpe        | PF = 1            | 偶数                       | 7Axx         | 0F8Axxxxxxxx |
| jnp / jpo       | PF = 0            | 奇数                       | 7Bxx         | 0F8Bxxxxxxxx |
| jl / jnge       | SF ≠ OF           | 小于 / 不大于等于          | 7Cxx         | 0F8Cxxxxxxxx |
| jnl / jge       | SF = OF           | 不小于 / 大于等于          | 7Dxx         | 0F8Dxxxxxxxx |
| jle / jng       | SF ≠ OF \| ZF = 1 | 小于等于 / 不大于          | 7Exx         | 0F8Exxxxxxxx |
| jnle / jg       | SF = OF & ZF = 0  | 不小于等于 / 大于          | 7Fxx         | 0F8Fxxxxxxxx |

# 4 条件指令

## 条件设置指令

条件设置指令的形式是 `setcc reg8/mem8`，其测试指定标志位，并把结果放入操作数中，满足条件时置 1，否则置 0，条件设置指令可以减少转移指令以提高效率。

| 指令                  | 机器码 |
| --------------------- | ------ |
| seto                  | 0F90xx |
| setno                 | 0F91xx |
| setc / setb / setnae  | 0F92xx |
| setnc / setnb / setae | 0F93xx |
| sete / setz           | 0F94xx |
| setne / setnz         | 0F95xx |
| setbe / setna         | 0F96xx |
| setnbe / seta         | 0F97xx |
| sets                  | 0F98xx |
| setns                 | 0F99xx |
| setp / setpe          | 0F9Axx |
| setnp / setnpo        | 0F9Bxx |
| setl / setnge         | 0F9Cxx |
| setnl / setge         | 0F9Dxx |
| setle / setng         | 0F9Exx |
| setnle / setg         | 0F9Fxx |

考虑如下 C 代码：

```c
int main(void) {
    int a;
    scanf("%d", &a);
    if (a)
        return 1;
    else
        return 5;
}
```

开启 O2 优化后，其汇编代码如下：

```assembly
; int main(void)
002D1040  push        ebp
002D1041  mov         ebp,esp
002D1043  push        ecx
; int a;
; scanf("%d", &a);
002D1044  lea         eax,[ebp-4]
002D1047  push        eax
002D1048  push        2D2100h
002D104D  call        002D1010
; if (a)
002D1052  xor         eax,eax
002D1054  add         esp,8
002D1057  cmp         dword ptr [ebp-4],eax     ; eax == 0 ?
002D105A  sete        al                        ; eax = ZF
002D105D  lea         eax,[eax*4+00000001h]     ; eax = 5
002D1064  mov         esp,ebp
002D1066  pop         ebp
002D1067  ret
```

可以看到，使用 sete 来替代了转移指令。

## 条件传输指令

条件传输指令的形式是 `cmovcc reg,reg/mem`，其测试指定标志位，并把结果放入操作数中，满足条件时传送，否则跳过。浮点数可用 `fcmovcc` 系列指令。

| 指令                     | 机器码 |
| ------------------------ | ------ |
| cmovo                    | 0F40xx |
| cmovno                   | 0F41xx |
| cmovc / cmovb / cmovnae  | 0F42xx |
| cmovnc / cmovnb / cmovae | 0F43xx |
| cmove / cmovz            | 0F44xx |
| cmovne / cmovnz          | 0F45xx |
| cmovbe / cmovna          | 0F46xx |
| cmovnbe / cmova          | 0F47xx |
| cmovs                    | 0F48xx |
| cmovns                   | 0F49xx |
| cmovp / cmovpe           | 0F4Axx |
| cmovnp / cmovnpo         | 0F4Bxx |
| cmovl / cmovnge          | 0F4Cxx |
| cmovnl / cmovge          | 0F4Dxx |
| cmovle / cmovng          | 0F4Exx |
| cmovnle / cmovg          | 0F4Fxx |

条件传输指令和条件设置指令一样，可以减少转移指令来提高效率。

考虑如下 C 代码：

```c
int main(void) {
    int a, b, c;
    scanf("%d%d", &a, &b);
    c = a < b ? a : b;
    printf("%d\n", c);

    return 0;
}
```

开启 O2 优化后，其汇编代码如下：

```assembly
; int main(void)
00761080  push        ebp
00761081  mov         ebp,esp
00761083  sub         esp,8
; int a, b, c;
; scanf("%d%d", &a, &b);
00761086  lea         eax,[ebp-4]
00761089  push        eax
0076108A  lea         eax,[ebp-8]
0076108D  push        eax
0076108E  push        762100h
00761093  call        00761050
; c = a < b ? a : b;
00761098  mov         ecx,dword ptr [ebp-4]
0076109B  cmp         dword ptr [ebp-8],ecx
0076109E  cmovl       ecx,dword ptr [ebp-8]
; printf("%d\n", c);
007610A2  push        ecx
007610A3  push        762108h
007610A8  call        00761020
007610AD  add         esp,14h
; return 0;
007610B0  xor         eax,eax
007610B2  mov         esp,ebp
007610B4  pop         ebp
007610B5  ret
```

可以看到，使用 cmovl 指令替代了转移指令。

# 5 算法实现逻辑

编译器在进行优化时，会尽量在不改变原有逻辑的情况下，使用数学技巧把部分逻辑分支或循环指令替换成算术操作，以减少比较指令和转移指令，从而提高效率。

考虑如下 C 代码：

```c
int isOdd(int i) {
    if (i % 2 == 0)
        return 0;
    else
        return 1;
}

int main(void) {
    int a;
    scanf("%d", &a);
    if (isOdd(a))
        return 1;
    else
        return 5;
}
```

开启 O2 优化后，其汇编代码如下：

```assembly
; int main(void)
00071040  push        ebp
00071041  mov         ebp,esp
00071043  push        ecx
; int a;
; scanf("%d", &a);
00071044  lea         eax,[ebp-4]
00071047  push        eax
00071048  push        72100h
0007104D  call        00071010
; if (isOdd(a))
00071052  mov         eax,dword ptr [ebp-4]
; int a;
; scanf("%d", &a);
00071055  add         esp,8
; if (isOdd(a))
00071058  and         eax,80000001h
0007105D  jns         00071064              ; a > 0 ?
0007105F  dec         eax
00071060  or          eax,0FFFFFFFEh
00071063  inc         eax
00071064  neg         eax
00071066  sbb         eax,eax
00071068  and         eax,0FFFFFFFCh
0007106B  add         eax,5
0007106E  mov         esp,ebp
00071070  pop         ebp
00071071  ret
```

可以看到，isOdd 函数直接被优化成了一系列算术运算指令，比较指令和转移指令也没有了，通过算术运算提高了效率。在这个例子中，neg 指令检测 eax 是否为 0，并将结果保存在 CF 中，用伪代码表示为：

```c
CF = eax ? 1 : 0;
```

接下来的 and 和 add 指令根据 eax 的值来决定最后的结果。
