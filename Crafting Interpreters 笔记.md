# 2 A Map of the Territory

## 2.1 The parts of a Language

### 2.1.1 Scanning

第一步**扫描**（Scanning），即**词法分析**（Lexing，Lexical analysis）。

扫描器（词法分析器）接收线性字符流，切分成由类似单词形式组成的**词法单元**。如符号（`(`、`,`）、数字（`0`、`123`）、字符串（`"haha"`）、标识符（`foo`）。

![字符流](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202404202359178.png)

源文件中的一些字符没有任何意义，如空格、注释等。扫描器会丢弃这些字符，只留下由意义的词法单元序列。

![词法单元序列](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202404202359809.png)

### 2.1.2 Parsing

然后是**语法分析**（Parsing），解析器（Parser）将由词法分析得到的词法单元序列转化为树形结构，也叫**解析树**（Parse tree）或**抽象语法树**（Abstract syntax tree，AST），该结构能够反映语法的嵌套关系。此外，解析器还会分析词法单元序列中的语法错误。

![AST](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202404202359566.png)

### 2.1.3 Static analysis

在前两个阶段中，可以获知语法结构及之间的关系，但也仅限于此。如 `a + b` 这样的表达式，通过语法分析，仅能知道 `a` 和 `b` 需要相加，但是 `a` 和 `b` 这些标识符到底指代什么，是局部还是全局变量？在哪里被定义？这些都是不清楚的。

许多语言会做绑定（Binding）或决议（Resolution）——对于每一个标识符，都需要找出定义该名称的位置，并将两者连接起来。这就是作用域的作用——在源代码的某个区域中，某个名字可以用来引用某个声明。

若语言是静态类型的，在进行绑定时，还可以借此机会进行类型检查，知道了标识符的定义位置，那么也可以知道其类型，若该类型不支持相加操作，则可报类型错误。

在上面的分析中，所有的语义信息都会存储在某个地方：

-   存储在 AST 本身的属性中，属性是树中节点的额外字段，这些字段在解析时不会初始化，而是在之后进行填充；
-   存储在外部的查找表中，通常该表的关键字是标识符，也称为**符号表**，实际上就是一系列键值对，其值表示该标识符所指；
-   将树转化为全新的数据结构并存储在其中，这更能表达代码的语义。

### 2.1.4 Intermediate representations

词法分析、语法分析、静态分析这些都称为实现的**前端**，还有中端和后端。

编译器实际上就是一条流水线，每个阶段的工作就是将上一阶段的结果进行加工，使下一阶段的实现更简单。前端部分主要针对源代码字符串的文本处理，后端关注的则是程序最终运行的部分。

在处理过程中，代码结果可能被存储在**中间代码**（Intermediate representation，IR）中，这些中间代码与源文件或最终运行部分没有紧密联系，而是作为一种中间层，充当两种语言之间接口，并可以支持多种目标平台。

若编译器要支持多种语言及目标平台，需要分别为这些组合实现，而现在只需要为每种语言实现一个前端统一转化为 IR，再为每个平台写一个后端，就可以将 IR 转为为各个目标平台的程序。

### 2.1.5 Optimization

源文件经由前端语义分析转化为 IR，而可能还存在语义相同但是生成的 IR 更加高效的情况。**优化**则是对具有相同语义但实现更高的程序来进行替换。

如常量折叠，若某个表达式求值得到的始终是完全相同的值，则可以在编译时进行求值，而非在运行时进行计算，并用其结果替换该表达式的代码。

```c
a = 10 + 20 + (30 / 2);
// 替换为
a = 45;
```

更进一步，对更为复杂的表达式也同样可以进行优化：

```c
sum = 0;
for (int i = 1; i <= 100; i++)
    sum += i;
// 替换为
sum = 5050;
```

这种编译期优化可以极大的提高运行时的性能，但实际要找到一个具有更高效率且具有相同语义的过程是十分困难的。如 Lua、Python 这种解释型语言不会生成特别优化后的字节码。

### 2.1.6 Code generation

从源文件开始，对源代码进行向上的抽象处理，最后又向下接近机器可以理解的形式进一步处理。这就是前端和后端的处理过程。在最终的代码生成阶段，实际上这也是编译型语言和解释型语言的分水岭。

当为真实的 CPU 生成指令，那么会得到某个特定 CPU 平台的可执行文件，然后操作系统可以加载该程序然后直接运行。这意味着编译器与特定架构绑定，为 x86 生成的程序当然无法在 ARM 上运行。

而为虚拟的 CPU 生成指令，这实际上就是为虚拟机生成指令，也叫做**字节码**（Bytecode）。这种指令是可移植的，只要目标平台上安装了对应的虚拟机就可以执行。

### 2.1.7 Virtual machine

编译器虽然生成了字节码，但没有真实的 CPU 可以解析执行这些字节码，因此还需要进一步的翻译。可以为每个目标平台编写一个小型编译器，并将这些字节码转化为目标平台可执行的指令。这仍然需要为每个所支持的平台做单独的适配，这时候字节码实际上就相当于一种 IR。

或者可以由虚拟机（VM）去执行这些字节码。VM 可在运行时模拟支持虚拟架构的虚拟 CPU，VM 会最终将这些字节码转化为目标指令去执行。由于每条指令执行时都必须在运行时模拟，因此在 VM 中运行字节码比提前将其编译成目标代码要慢，但这种实现具有简单性和更好的可移植性。

### 2.1.8 Runtime

最后一步则是运行该程序，若编译成机器码，则只需要告诉操作系统加载该程序运行即可。若编译成字节码，则需要启动 VM 并将程序加载到其中，由 VM 来运行。

在这两种情况下，除了最基本的底层语言外，通常语言还会在程序运行时提供一些服务。如语言支持自动管理内存，则需要一个 GC。如需要运行时反射，就需要动态跟踪执行过程中每个对象的类型；如需要运行时进行类型检查，如下标越界、整数溢出检查，就需要在每个这种操作前插入检查代码；如需要支持异常处理，则也是同理。

这些服务都是在运行时进行的，所以被称为**运行时**（Runtime）。在编译型语言中，如 Go，实现运行时的代码会直接插入到生成的可执行文件中。在解释执行或在 VM 内运行的语言中，如 Python、JavaScript，运行时将驻留于 VM 中。

## 2.2 Shortcuts and Alternate Routes

### 2.2.1 Single-pass compilers

一些简单的编译器将词法分析、语法分析和代码生成交织在一起，这样就可以直接在解析器中生成输出代码，而无需分配任何语法树或 IR。这些**单遍编译器**（Single-pass compilers）实现限制了语言的设计。没有中间数据结构来存储程序的全局信息，也不会重新访问任何之前被解析过代码的部分。这意味着一旦看到某个表达式，就需要足够的信息来正确地对其进行编译。

Pascal 和 C 就是围绕这个限制而设计的。在早期内存很小，一个编译器可能连整个源文件都无法存放在内存中，更别说整个程序了。这也是为什么 Pascal 要求类型声明要先出现在一个块中，在 C 中不能在定义函数之前调用函数，除非有一个明确的前向声明，以让编译器生成调用后面函数的代码。

### 2.2.2 Tree-walk interpreters

有些语言在将代码解析为 AST 后就开始执行代码（可能应用了一点静态分析）。为了运行程序，解释器每次都会遍历语法树的一个分支和叶子节点，并在运行过程中计算每个节点。

这种**树遍历解释器**（Tree-walk interpreters）实现在学生项目和小型语言中很常见，但在通用语言中并不常见，因为执行效率很低，不过早期的 MRI Ruby 就是用的这种实现。

### 2.2.3 Transpilers

为语言编写一个完整后端的工作量是巨大的。若已经有通用的 IR，如 LLVM IR，那么可以将前端转换到该 IR 上，然后使用该 IR 的后端将代码转化成可执行代码。

IR 不一定非得是某种特定的中间代码，还可以是其它语言的源代码。前端处理完后，后端生成一份与自己语言级别差不多的其它语言的有效源代码，而不是将所有代码降低到原始目标语言的语义。

这种方式称为**源到源编译器**、**转换编译器**或**转译器**（Transpilers）。以 C 为编译目标，可以运行在各个体系架构上，以 JavaScript（WebAssembly） 为目标，可以运行在浏览器上。转译器的前端（扫描器和解析器）和一般的编译器前端是类似的。若源语言只是在目标语言在语法方面的换皮版本，则可能会完全跳过分析，并直接输出目标语言中的类似语法。若两种语言的语义差异较大，则会包含编译器的更多典型阶段，甚至包括优化。

### 2.2.4 Just-in-time compilation

执行代码最快的方法是将代码编译成目标机器代码，但不是什么时候都知道最终用户的机器支持什么架构的。像 JVM、CLR 和 JavaScript 解释器，在终端用户的机器上，当程序加载时（无论是源代码还是字节码），都可以将其编译为对应的本地代码，以适应本机支持的体系结构，这被称为**即时编译**。

复杂的 JIT 将性能分析 Hook 插入到生成的代码中，以检测那部分对性能更为敏感，并且会随着运行时间的变化动态优化并重新编译热点代码。

## 2.3 Compilers and Interpreters

**编译**是一种实现技术，将源语言翻译成其它语言——通常是指较低级的形式，但无论是生成字节码、机器码还是另一种语言，都叫做编译。**编译器**是一种将源代码转化为其它形式的程序，只将结果输出，但不进行实际的执行，而**解释器**除了接受源代码，还会执行。

如 GCC 和 Clang 就是接受 C 代码然后编译为机器码，最终用户可执行生成的文件。而早期的 MRI Ruby 会在遍历语法树时就解析执行，期间没有其它转换。CPython 会将源代码解析转换为字节码，然后在 VM 中执行，所以这两种都可以看做解释器，虽然 CPython 在内部也做了一些编译的工作。实际上在很多语言中，这两种是同时存在的。

![编译器和解释器](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202404202358866.png)