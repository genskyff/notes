# 1 前言

我们有时会遇到打开某些文件时会出现乱码、方块字等现象，特别是在跨平台、跨操作系统时，比如从 macOS 系统上拷贝了一个文件到 Windows 电脑上，或者打开一个从网上下载的文件时这种现象时有发生，而且会经常看到诸如 ASCII、GB2312、Unicode、UTF-8 之类的术语，对此可能一头雾水。为了了解文件为什么会出现这种现象，以及这些术语代表的含义，首先要明白信息在计算机中是如何存储的。

# 2 信息存储

计算机最小信息单位称为**位**（Bit），最小的存储单位由 8 个位组成，称为**字节**（Byte），即：

>   8 Bit = 1 Byte

![字节的位表示](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109190053802.png)

一个字节的 8 个位从左到右依次编号为 7 ~ 0，7 为最高位，0 为最低位，一个位有 0 和 1 两种状态，可以表示两种信息，而一个字节有 2<sup>8</sup> 种状态，可以表示 256 种信息。

# 3 ASCII 编码

由于计算机最开始只在美国使用，在处理字符时，只需要考虑大小写字母、数字和一些符号，所以一个字节即可表示所有的字符信息且还有剩余。

一个字节的 256 种状态被编码为 0x00 ~ 0xFF，编码从 0x00 ~ 0x1F 的被规定为特殊用途，通常是键盘无法输入或肉眼不可见的，计算机向显示设备输出字符时，一旦遇到这些编码对应的字符，就立刻做出相应动作，如：

- 遇上 7（`\a` 蜂鸣器），就发出“嘟嘟嘟”的蜂鸣声。
- 遇上 8（`\b` 退格符），就把光标移至上一个字符前。
- 遇上 10（`\n` 换行符），就把光标移至下一行。

这种字符被称为**控制字符**，剩下的大小写字母、数字、空格、标点符号等从 0x20 开始继续编码，一直编到了 0x7F。这样仅仅用了 1 个字节不到的空间就已经能够表示所有英文字符了。于是 **ANSI**（American National Standards Institute，美国国家标准学会）把该编码标准称为 **ASCII**（American Standard Code for Information Interchange，美国信息交换标准代码），ASCII 编码是 7 位编码，剩下的一位用 0 补足。

后来又有一些地区开始使用计算机了，但并不是所有地区的语言都是英语，有些语言的字符是 ASCII 里没有的，为了能在计算机中表示更多的字符，一些地区决定用剩余的 0x80 ~ 0xFF 来表示这些新的字符，就这样一直编到了最后一个编码 0xFF。从 0x00 ~ 0x7F 这一范围的字符被称为 **ASCII 基本字符集**，而 0x80 ~ 0xFF 这一范围的字符被称为 **ASCII 扩展字符集**。**标准 ASCII 只规定了一个字节的前 7 位，对于扩展则没有统一标准**。

对于大于 0x80 的编码，规定 0x80 ~ 0x9F 为保留控制块，因此字符通常会从 0xA0 / 0xA1 开始。

# 4 Latin-1 编码

又称 **ISO 8859-1** 或**西欧语言**。它以 ASCII 为基础，在空置的 0xA0 ~ 0xFF 的范围内，加入包括西欧语言、希腊语、泰语、阿拉伯语、希伯来语等对应的文字符号。

由于 Latin-1 使用了整个单字节空间，在支持该编码的系统中传输和存储其它编码的字节序列都会被正常处理，输入什么字节序列就存储什么字节序列，读取时出依然是原输入的字节序列，至于该字节序列是否是其它编码并不重要，MySQL 数据库默认编码是 Latin-1 也是因为如此。但如果原字节序列是其它编码的话，按照 Latin-1 解析就不会被正常处理，如统计字符数和显示。

# 5 汉字编码

## GB2312

再之后，中国、日本等地区也开始使用计算机了，但这时单字节中已经没有可以利用的字节信息来表示汉字、假名了，况且汉字有几千个字，于是 **GB**（Guobiao，中国国家标准）把 ASCII 扩展字符集直接取消，并规定：**ASCII 基本字符集的意义与原来相同，但当两个编码大于 127 的字符连在一起时，就表示一个汉字字符**。即 1 个汉字字符用 2 个字节来表示，第 1 个字节称为**高位字节**，第一个字节范围是 0xA1 ~ 0xF7，第 2 个字节称为**低位字节**，范围是 0xA1 ~ 0xFE，共收录 6763 个汉字。除此之外，还把拉丁字母、希腊字母、日文假名和俄语西里尔字母在内的 682 个字符全部收录，同时标点符号也给重新编码，这些字符被称为**全角字符**，而 ASCII 基本字符集中的字符被称为**半角字符**。该编码标准被称为 **GB2312**，GB2312 是对 ASCII 基本字符集的中文扩展。

## GBK

GB2312 基本满足了汉字的使用需求，它所收录的汉字已经覆盖了中国大陆 99.75% 的使用频率，但汉字实在是太多了，特别是对于人名、古汉语等方面出现的生僻字，即使是 GB2312 也不能完全囊括，于是继续把 GB2312 剩余的编码全部用上，但后来发现还是不够用，于是不再要求低位字节必须是 127 之后的编码，**只要高位字节是大于 127 的，就表示这是一个汉字的开始**。该编码标准被称为 **GBK**（汉字内码扩展规范），GBK 完全兼容 GB2312 ，共收录 21000 余个字符。

## GB18030

再后来少数民族也开始使用计算机了，于是再扩展，又增加了少数民族的汉字字符，GBK 扩展成了 **GB18030**，共收录汉字 70000 余个。

GB18030 对 GB 2312 完全向后兼容，与 GBK 基本向后兼容，并支持 Unicode 的所有码位。

主要有以下特点：

-   采用变长多字节编码，每个字符可以由 1 个、2 个或 4 个字节组成。
-   编码空间庞大，最多可定义 161 万个字符。
-   完全支持 Unicode，无需动用造字区即可支持少数民族文字、CJK 文字以及 emoji 等字符。

## DBCS

这一系列汉字编码标准被称为 **DBCS**（Double-byte Character Set，双字节字符集），实际上 DBCS 不仅仅指中文编码，还指其它一系列使用双字节编码的字符，如日文和韩文。在 DBCS 标准中，最大的特点是 2 字节长的汉字字符和 1 字节长的英文字符并存于同一套编码标准里，因此在程序中处理字符时，必须要注意字符串中每个字节的值，如果这个值比 127 大，那么就认为一个双字节字符集里的字符出现了。

# 6 Unicode 与 UTF

各个地区都像各自搞出一套编码标准，日本搞出了 **Shift-JIS** 编码标准，繁体中文也搞出了 **Big5**（大五码）编码标准，而每种语言环境下的所使用的编码被称为 **ANSI** 编码，其并不是指某种特定的编码，在不同的环境下 ANSI 编码的意义不同。在中文环境下，ANSI 指 GBK；在日文环境下，ANSI 指 Shift-JIS；在英文环境下，ANSI 指 ASCII。假设文本的编码方式是 ANSI，但如果是在中文环境下创建的，当把它移植到日文环境下，此环境下的 ANSI 就不是指 GBK 了，就会造成乱码。这样的话各个地区的编码都互不相通，如果要处理其它语言的字符，就需要额外安装一套编码系统，这样一来就非常麻烦。

## Unicode

这时，一个叫 **ISO**（International Organization for Standardization，国际标准化组织）的组织决定解决这个问题，即废弃了所有地区性的编码标准，提出了一种包含目前所有已知语言的字符集，称之为 **UCS**（Universal Character Set，通用字符集），后来也被称为 **Unicode**（统一码），目前已收录超过 14 万个字符，并不断更新中。

Unicode 是字符集，它有多种编码标准，如 **UCS-2** 使用 2 个字节来表示所有字符，**UCS-4** 使用 4 个字节来表示所有字符。对于 ASCII 里的那些半角字符，Unicode 保持其原编码不变，只是将其长度由原来的 8 位根据编码标准扩展，多余的位设为 0，而其他语言的字符则全部重新编码。

### 区分字符集和编码标准

- **字符集**：为每一个字符分配一个唯一的 ID，也叫做**码点**（Code Point），字符和码点为一一对应关系。

- **编码标准**：将码点转换为字节序列的规则，即以怎样的方式去解读这个码点。

ASCII、GB2312、GBK 等都属于字符集，但由于它们都只有一种编码标准，所以可以不用严格的区分这两者的关系，而 Unicode 字符集有多种编码标准，所以需要区分开来。拿数学函数的概念来类比，一个函数  `f(x)`，`x` 代表码点，而 `f` 就代表编码标准，`f` 不同，解读出来的结果也不同。

### Unicode 值的表示

在表示一个字符的 Unicode 值时，通常使用 `U+` 加**该字符的码点**，如汉字 `你` 的码点为 `4F60`，则该字符的 Unicode 值通常写为 `U+4F60`，在某些场合会用 `\u` 替换 `U+`， 即 `\u4f60`，且无论哪种场合，大小写都并不敏感。

### Unicode 平面

Unicode 被分成 17 个平面，每平面拥有 2<sup>16</sup> 个码点，目前只用了少数平面。

Unicode 标准规定了从 U+0000 ~ U+FFFF 范围内的字符集合为 **BMP**（Basic Multilingual Plane，基本多文种平面），又称 **0 号平面**（Plane 0），BMP 内的字符可以用 2 个字节表示。从 U+10000 ~ U+10FFFF 范围内的字符集合为辅助平面，一共有 16 个辅助平面。

|     平面      |   始末 Unicode 值   |            中文名称            |                     英文名称                      |
| :-----------: | :-----------------: | :----------------------------: | :-----------------------------------------------: |
|   0 号平面    |   U+0000 ~ U+FFFF   |       **基本多文种平面**       |      Basic Multilingual Plane，简称 **BMP**       |
|   1 号平面    |  U+10000 ~ U+1FFFF  |       **多文种补充平面**       |  Supplementary Multilingual Plane，简称 **SMP**   |
|   2 号平面    |  U+20000 ~ U+2FFFF  |      **表意文字补充平面**      |   Supplementary Ideographic Plane，简称 **SIP**   |
|   3 号平面    |  U+30000 ~ U+3FFFF  |      **表意文字第三平面**      |     Tertiary Ideographic Plane，简称 **TIP**      |
| 4 ~ 13 号平面 |  U+40000 ~ U+DFFFF  |          **尚未使用**          |                                                   |
|   14 号平面   |  U+E0000 ~ U+EFFFF  |      **特别用途补充平面**      | Supplementary Special-purpose Plane，简称 **SSP** |
|   15 号平面   |  U+F0000 ~ U+FFFFF  | 保留作为**私人使用区（A 区）** |        Private Use Area-A，简称 **PUA-A**         |
|   16 号平面   | U+100000 ~ U+10FFFF | 保留作为**私人使用区（B 区）** |        Private Use Area-B，简称 **PUA-B**         |

## UTF

直接使用 Unicode 会产生两个问题。

首先是**空间占用**。在使用 ASCII 时用 1 个字节就够了，如果使用 Unicode，会极大的浪费空间，文本文件的大小会因此变大很多，特别是在网络传输时，会极大的浪费带宽。

其次是**解析**。即如何才能区分 Unicode 和 ASCII，计算机如何知道要使用多个字节表示 1 个字符，而不是分别表示多个字符。

对于空间占用问题，**UTF**（Unicode Transformation Format，Unicode 转换格式）编码标准可以很好的解决，这是一种针对 Unicode 的可变长度字符编码，在传输过程中可以起到很好的作用。UTF 有 UTF-7、UTF-8、UTF-16 和 UTF-32 等编码标准，UTF-8 以 8 位为一个单位进行编码和传输，UTF-16 以 16 位为一个单位进行编码和传输，UTF-32 以 32 位为一个单位进行编码和传输，目前最常用的是 UTF-8 和 UTF-16。

### UTF-32

UTF-32 把一个 Unicode 字符编码成 4 个字节，且直接使用该字符的 Unicode 值，多余的位设为 0。UTF-32 和 UCS-4 能表示的字符是相同的，这两者基本等价。

![UTF-32 编码](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109190114836.png)

UTF-32 由于每个字符的长度相同，因此可以很容易的检索和统计字符的位置与数量，但每个字符都占据 4 个字节，空间浪费严重，且存在字节序的问题，目前除了在程序内存中使用，几乎不存在其他使用场合。

### UTF-8

UTF-8 把一个 Unicode 字符编码成 1 ~ 6 个字节，ASCII 被编码成 1 个字节，汉字通常是 3 个字节，只有很生僻的字符才会被编码成 4 ~ 6 个字节，其它语言的字符也是同理。这样的话，包含大量 ASCII 字符的文件，用 UTF-8 编码就能节省空间。ASCII 可以看成 UTF-8 的一个子集，一些只支持 ASCII 编码的历史遗留软件可以在 UTF-8 编码下正常工作。

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20210213090333.png" alt="各编码之间的兼容性" style="zoom:85%;" />

对于解析问题，以 UTF-8 为例：

- 单字节的字符，最高位设为 0，其余空位填充该字符码点，UTF-8 只占用 1 个字节，和 ASCII 码完全相同。
- n 个字节的字符（n > 1），第 1 个字节的前 n 位设为 1，第 n + 1 位设为 0，后面字节的前 2 位都设为 10，其余空位填充该字符码点，高位用 0 补足。

于是 UTF-8 可以表示为：

|    单字符字节数 | 位表示                                                |
| --------------: | ----------------------------------------------------- |
| 单字节（ASCII） | 0xxxxxxx                                              |
|          双字节 | 110xxxxx 10xxxxxx                                     |
|          三字节 | 1110xxxx 10xxxxxx 10xxxxxx                            |
|          四字节 | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx                   |
|          五字节 | 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx          |
|          六字节 | 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx |

这相当于给每个字节前加上一个标记，计算机在读取时，就会知道以哪种方式去读取，UTF-16 等其它编码标准同理。

UTF 编码标准既包含了更多的字符，又不会占用太多空间，至于现在依然普遍使用 GB2312 和 GBK 等编码标准，主要是为了更加节省空间和带宽。

![同一本网络小说使用不同编码的大小对比](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20210214221147.png)

有以下文本：

```
abcd
你好
```

以 UTF-8 编码后，在内存中表示为：

```
0x61 62 63 64 0d 0a e4 bd a0 e5 a5 bd
```

第 1 行的 `abcd` 四个字符的编码为 `61 62 63 64`，最后一个换行符 `\r\n` 编码为 `0d 0a`（在 Windows 中换行由两个字符 `CRLF` 组成，在 Unix 类系统中为单字符  `LF`），可以看出 UTF-8 对单字节字符的编码标准和 ASCII 是相同的。

![UTF-8 编码](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109190122807.png)

第 2 行的汉字 `你好` 可以很明显的看出是以三字节编码的，首先把十六进制化为二进制：

```
‭你：11100100 10111101 10100000 好：11100101 10100101 10111101‬
```

根据上面的规则，第 1 个字节的前 3 位有 3 个 1，第 4 位为 0，表示它为一个三字节字符，后面 2 个字节的前 2 位为 10。

UTF-8 在某些情况如中文环境下会比较占空间，且由于是变长字符，所以在检索和统计时会有额外的性能开销，但其有着兼容 ASCII、能够很好的处理 C 库中以 `\0` 结尾的字符、没有字节序、良好的多语种支持、适应网络传输、容错性高等优点，目前来说是最优选，也是普及得最广的。

### UTF-7

UTF-7 使用 7 位为一个单位来存储和传输 Unicode 字符，其范围相当于 ASCII 基本字符集。该编码存在的主要原因是，在早期，SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）作为电子邮件的传输标准之一，其指明了传输编码为 ASCII，并且不允许超过 ASCII 所定义的字符范围以外的值，即 8 位的字符串将无法被正常传输。虽然 MIME（Multipurpose Internet Mail Extension，多用途互联网邮件扩展）扩展了网络邮件以支持不同的媒体类型以及字符集，包括 UTF-8 和 UTF-16 皆可被指定使用，但由于 MIME 并未明确将 Unicode 定义为可支持的字符集，也没有说明其应如何编码，这使得既有的 SMTP 传输架构下仍旧无法保证可正确的处理 8 位的数据。

简单来说就是 SMTP 出现时，Unicode 还未推广，为了兼容邮件传输，于是诞生了 UTF-7，不过目前邮件传输已经能够很好的支持 UTF-8 了，使用 UTF-7 的场景几乎消失。

### UTF-16

UTF-16 把一个 Unicode 字符编码成 2 或 4 个字节，绝大部分字符被编码成 2 字节，较生僻的字符才会被编码成 4 个字节。UTF-16 可以说是 UCS-2 的超集，UTF-16 中以 2 个字节编码的字符等同于 UCS-2 中的字符，超出 2 个字节编码的字符，则无法用 UCS-2 表示。

由于 Unicode 标准规定 U+D800 ~ U+DFFF 范围的值不对应于任何字符，于是对于在 U+0000 ~ U+D7FF 以及 U+E000 ~ U+FFFF 范围内的字符，可以用 2 字节表示，其 UTF-16 编码等价于该字符对应的码点，多余的位设为 0。

![码点 ≤ 0xFFFF 字符的 UTF-16 编码](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109190127392.png)

`你` 的 Unicode 值为 `U+4F60`，因为其值 ≤ 0xFFFF，所以其 UTF-16 值等同于码点值。

对于 Unicode 值 ≥ U+10000 的字符，由于长度超出 2 字节，需要用 4 个字节表示，其 UTF-16 编码的计算方法为：

-   码点减去 0x10000，得到一个 20 位的值，范围为 0 ~ 0xFFFFF。
-   高位 10 比特的值（范围为 0 ~ 0x3FF）加上 0xD800 得到第一个码元，称作**高位代理**，范围为 0xD800 ~ 0xDBFF。
-   低位 10 比特的值（范围为 0 ~ 0x3FF）加上 0xDC00 得到第二个码元，称作**低位代理**，范围为 0xDC00 ~ 0xDFFF。

![码点 ≥ 0x10000 字符的 UTF-16 编码](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/202109190155196.png)

以 emoji 表情 😅 为例，其 Unicode 值为 `U+1F605`，则 UTF-16 计算过程为：

1.  用码点减 `0x10000`：`0x1F605 - 0x10000` 得 `0xF605`；
2. 分割其**二进制值**的高 10 位和低 10 位：得高位代理 `0x3D` 和低位代理 `0x205`；
3. 高位代理加 `0xD800`，以形成高位：`0x3D + 0xD800` 得 `0xD83D`；
4. 低位代理加 `0xDC00`，以形成低位：`0x205 + 0xDC00` 得 `0xDE05`。

UTF-16 也有着容易的检索和统计字符的位置与数量的优点，并且大多数操作系统都内置 UTF-16，且没有 UTF-32 那么占用空间，但是其存在不兼容 ASCII、字节序、容错率低等问题。

# 7 陷阱 BOM

在谈 BOM 之前，先来谈谈什么是大小端。

设一个大小为 **w** 位的整数 **x**，其位表示为 **[x<sub>w-1</sub>, x<sub>w-2</sub>, ..., x<sub>1</sub>, x<sub>0</sub>]**，其中 **x<sub>w-1</sub>** 为最高有效位，**x<sub>0</sub>** 为最低有效位。设 w 为 8 的倍数，则这些位能被分组为字节，其中最高有效字节包含位 **[x<sub>w-1</sub>, x<sub>w-2</sub>, ..., x<sub>w-8</sub>]**，最低有效字节包含位 **[x<sub>7</sub>, x<sub>6</sub>, ..., x<sub>0</sub>]**，其它有效字节包含中间的位。有些机器在内存中按照从最低到最高有效字节顺序存储，而有些又反过来。前一种规则——最低有效字节在前面的方式，称为**小端**（Little Endian），而后一种称为**大端**（Big Endian）。

大端地址由小到大增加，数据从高字节到低字节存储，这和阅读习惯一致，如十六进制整数 0x12345678 的大端存储方式为：

```
地址 0x00 01 02 03
数据 0x12 34 56 78
```

小端地址由小到大增加，数据从低字节到高字节存储，这和阅读习惯相反，如十六进制整数 0x12345678 的小端存储方式为：

```
地址 0x00 01 02 03
数据 0x78 56 34 12
```

目前绝大部分机器都使用小端，但大小端对以 ASCII 编码的字符串没有影响，字符串全部以大端存储，如字符串 `"abcd"` 无论是在大端还是小端的机器上，在内存中的表示都为：

```
0x61 62 63 64
```

大小端可能会影响一个文件的读取方式，若是一个大端存储的文件以小端方式读取，那么读取出来的东西就会完全错误，尤其是在网络传输过程中，如果两台机器的表示不一样，那么就会接收到错误的信息，于是乎，BOM 诞生了。

**BOM**（Byte Order Mark，字节顺序标记），通常出现在文本文件头部，在 Unicode 编码中用于标识文件是采用哪种格式的编码，即是大端还是小端。在实际传输中，先传输字符 BOM，这样如果接收者收到 0xFEFF，就表明这个字节流是大端的，如果收到 0xFFFE，就是小端的。

UTF-8 是字节顺序无关的，它的字节顺序在所有系统中都是一样的，因此它不需要 BOM 来表明字节顺序，但可以用 BOM 来表明编码方式。BOM 在 UTF-8 编码的文件开头，占据 3 个字节，用 0xEFBBBF 表示：

```
0xef bb bf
```

如果接收者收到以此开头的字节流，就知道这是 UTF-8 编码了。

类似 Windows 自带的记事本等软件，在存储一个以 UTF-8 编码的文件时，会自动的在文件开始的地方插入 BOM。BOM 是一串隐藏字符，用于让记事本等编辑器识别这个文件是否以 UTF-8 编码。

由于 UTF-8 一般是不需要 BOM 的，通常软件并不会识别开头这几个字节，但如果加了 BOM，那么这些软件会把前几个字节当成普通字符来看待，造成乱码，反过来也是一样，如文本：

```
abcd
你好
```

以 UTF-8 with BOM 编码后，在内存中的表示为：

```
0xef bb bf 61 62 63 64 0d 0a e4 bd a0 e5 a5 bd
```

可以看到，前 3 个字节变为了 ef bb bf。

UTF-16 分为 UTF-16 BE 和 UTF-16 LE 两种，即大端字节序和小端字节序。对 UTF-16 来说，就需要使用 BOM 来标记字节顺序了，如文本：

```
abcd
你好
```

以 UTF-16 BE 和 UTF-16 LE 编码后，在内存中分别表示为：

```
UTF-16 BE:
0xfe ff 00 61 00 62 00 63 00 64 00 0d 00 0a 4f 60 59 7d

UTF-16 LE:
0xff fe 61 00 62 00 63 00 64 00 0d 00 0a 00 60 4f 7d 59
```

可以看到，大端和小端的 BOM 不同。

在 Windows 和 Linux 中，通常使用小端；在 macOS 和网络传输中，通常使用大端，因此大端也叫做**网络字节序**。

# 8 CJK 文字

对于中日韩等使用汉字的地区来说，有很多汉字其实有着相同的含义，甚至写法只是略有不同，但是如果给这些汉字也分别编码就会占据大量 Unicode 空间，于是 **CKJ** 出现了。

**中日韩统一表意文字**（CJK Unified Ideographs），也称**统汉码**（Unihan），目的是要把分别来自中文、日文、韩文等文字中，起源相同、语义相同、外形相似的表意文字，在 Unicode 中赋予相同的编码。

所谓起源相同、本义相同、外形相似的表意文字，主要为汉字，包括简繁体汉字、日本汉字、韩国汉字等文字。

这样就极大的节省了空间，如果需要显示这些地区的汉字，就不需要专门装一套对应地区的编码系统。但是对于语义或外形等有较大差异的汉字，还是需要使用对应地区的编码系统，不然同样会出现乱码等无法显示的情况。

# 9 代码页

代码页是字符编码的别名，也称**内码表**，是特定语言字符集的一张表。在早期，代码页是 IBM 称呼 BIOS 本身支持的字符编码所使用的名称。当时通用的操作系统大都是命令行界面，这些操作系统使用 BIOS 提供的字符绘制功能来显示字符，操作系统对编码的支持也就依赖 BIOS 的编码。这些 BIOS 代码页也被称为 **OEM 代码页**。后来图形操作系统解决了此问题，图形操作系统使用自己字符呈现引擎，可以支持多种字符编码。其中微软根据 ANSI 草案，针对不同的地区，定义了一系列支持不同语言字符集的代码页，称作 **Windows 或 ANSI 代码页**，这也就是为什么 ANSI 在不同的环境下，实际所代表的编码不同。

早期 IBM 和微软内部使用**数字**来标记不同的编码，不同的厂商对同一个编码各自使用不同的名称，如 UTF-8 在 IBM 称作代码页 1208，在微软称作代码页 65001。虽然图形操作系统可以支持很多编码，但很多微软程序依然使用数字来指定编码。

| OEM 代码页 | 含义                | Windows 代码页 | 含义                |
| :--------: | :------------------ | :------------: | :------------------ |
|    437     | ASCII               |      1250      | 东欧拉丁字母        |
|    850     | 西欧语言（Latin-1） |      1252      | 西欧语言（Latin-1） |

Windows-1252 与 Latin-1 并不完全一致。在 Latin-1 中，0x80 ~ 0x9F 范围内的控制字符，在 Windows-1252 中被可打印字符替代。由于在 Web 中，ASCII 控制字符不起作用，所以网页一般用 Windows-1252 替代 Latin-1。

| 中日韩语言代码页 | 含义                            |
| ---------------: | :------------------------------ |
|              932 | 日文（Shift-JIS / Windows_31J） |
|              936 | 简体中文（GBK）                 |
|              949 | 韩文（EUC-KR）                  |
|              950 | 繁体中文（Big5）                |
|            54936 | 简体中文（GB18030）             |

中日韩语言代码页既是 OEM 代码页，又是 Windows 代码页。

| 其他代码页 | 含义  |
| :--------: | ----- |
|   65000    | UTF-7 |
|   65001    | UTF-8 |

默认情况下，Windows 上的 **GUI**（Graphical User Interface，图形用户界面）程序使用 ANSI 代码页，而控制台程序使用 OEM 代码页。

程序 GUI 上的字符由于默认使用 ANSI 代码页，在另一种语言环境下由于代码页的改变，造成 ANSI 对应编码不同，就会导致乱码。

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20210214173959.png" alt="不同语言环境下创建的程序在另一语言系统上可能会出现问题" style="zoom:85%;" />

对于文本文件，在命令行中用 `type` 命令显示文本文件的内容，将使用 OEM 代码页，在 GUI 和控制台这两种情况下的文本显示有可能不一致。

![GUI 和控制台使用不同的代码页导致文本乱码](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20210214173242.png)

对于 Windows 操作系统中的命令行窗口，`chcp` 命令在没有参数时，显示当前窗口代码页；命令带一个参数，则改变当前窗口为参数所指定的代码页。若要把 UTF-8 编码的文本直接写到控制台，必须先将代码页改为 65001。

```bash
chcp 65001
```

在简体中文环境下，可以看到，默认编码是 GBK，OEM / ANSI 代码页为 936。

![chcp 命令查看和改变当前终端代码页](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20210214170459.png)

![控制台的默认代码页](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20210214171028.png)

注意在命令行窗口中使用 `chcp` 命令只能临时改变当前窗口的代码页，其它窗口的代码页不受影响，关闭并重开窗口后会恢复为默认代码页。

如果要改变系统默认代码页，需要在 Windows 的【控制面板】-【时间和区域】-【区域】的【管理】页面，【更改系统区域设置】选项中，选择要使用的代码页或者使用 UTF-8 支持，然后重启系统即可，但是不建议这么做，由于程序 GUI 使用 ANSI 编码，因此很可能导致部分软件界面显示错误。

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20210214172107.png" alt="永久改变系统默认代码页" style="zoom:90%;" />

# 10 字体

字符是一个抽象的概念，在计算机上是以字符编码的形式来存储的，是字符在计算中的代号，但具体要如何在屏幕上显示，并没有做规定，如果要在屏幕上显示对应的文字，仅仅靠字符编码是不够的，还需要**字体文件**。

**字体**（Typeface / Font Family），是由一种或多种**字型**（Font）组成的集合，每种字型由具有相同特征的**字形**（Glyph）组成。字体的每一种字型都有特定的尺寸、字重、宽度、倾斜、风格、装饰等特性。

## 区分字体、字型、与字形

早期计算机使用点阵字，对同一风格的字型需要设计不同像素的尺寸，因此字型也就不同，如 16 号宋体和 18 号宋体是两种不同的字型。矢量字型出现后，同一风格的字型已不用再制作不同尺寸的字型，只需制作一套即可随意缩放，但依然存在字重、宽度、倾斜等差异，如 16 号宋体和 16 号加粗宋体是两种不同的字型。目前可以不用严格区分字体与字型。

不同的字型可能属于同一种字体，如 16 号加粗宋体和 16 号粗斜宋体不是同一个字型，但都属于宋体这个字体，宋体与黑体才是不同字体。

字形指单个字的形体，一个可以辨认的抽象的图形符号，它不依赖于任何特定的设计，同一个字可以有不同的字形，而不影响其表达的意思，如汉字中的 `強/强` 和 `戶/户/戸`。相同的字形可用于不同语言文字的字符，如汉字 `私` 既可用于中文也可用于日文，即使两者表达的意思可能不同。

需要注意的是，字型的字重，即粗细，与倾斜，和在编辑文字时利用编辑器对其进行加粗和倾斜是不一样的，前者在设计上就已经如此，后者是利用软件，在算法上对字符进行空间上的变换，与专门制作的加粗、倾斜字体是不一样的。

## 字体特征

字体有衬线、宽度比例、字体度量、视觉字号、数字变体、反对比字体等特征。这里仅用最常见的衬线和宽度比例来说明。

### 衬线

一些字体中的字母笔画首尾具有装饰性的细节，称为**衬线**。具有衬线的字体称为**衬线体**，不具有衬线的字体称为**无衬线体**。

![无衬线和衬线字体对比](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20210214212309.png)

### 宽度比例

**比例字体**字形的宽度富有变化，**等宽字体**中的字形具有相同的宽度。一些字体中，西文字母为等宽，而符号和汉字等正好是西文的两倍宽，这类字体称为等宽字体。

比例字体看起来更漂亮，更容易阅读，因此它们在专业出版的印刷材料中更常见。计算机应用程序往往也使用比例字体。但许多比例字体也包含等宽的数字，以方便表格处理时对齐数值。打字机和早期的电子屏幕为了处理方便通常使用等宽字体；在终端、集成开发环境和一部分文字编辑器中，命令或代码会用等宽字体来显示，以便程序员能更轻松地区分字符。

![比例字体和等宽字体对比](https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20210214212936.png)

### 连字字体

**连字**（Ligature），也称**合字**，即某些相邻的字符会连在一起，在书写中为了阅读和书写的流畅而把多个字符连成了一个字符。

在计算机中，使用连字可以提高可读性，但并不是每种字体都支持连字，且用于显示的编辑器也不一定支持。

<img src="https://raw.githubusercontent.com/genskyff/image-hosting/main/images/20210215110736.png" alt="连字和非连字对比" style="zoom:85%;" />

左边使用了非连字的 Fira Mono 字体，右边使用了带连字的 Fira Code 字体，且编辑器也支持连字功能。

## 选择适合的字体

对程序员而言，应当选择等宽、高识别度（易区分 1lI、0Oo 等容易引起混淆的字符）、支持绝大多数西欧语言、能够在各平台上显示清晰的字体，对中文用户而言，还应当覆盖 GBK 全区段、汉字宽度最好是西文的两倍。此外，选择的字体最好能够免费用于商用，避免不必要的版权问题。

基于这些要求推荐的字体为：

-   中文：[霞鹜文楷](https://github.com/lxgw/LxgwWenKai/releases)；
-   西文：[Fira Code](https://github.com/tonsky/FiraCode/releases)。

## 字体与字符编码的关系

字体规定了字符如何显示，在字体文件中，包含了其支持的字符的显示信息。

一个字体文件包含一个或者多个**字符映射表**（Charmap），它的作用就是把一个字符从它的字符编码映射到字形索引，即该字符在字体文件中的位置。字符映射表一般使用 Unicode 作为字形的编码。

一般一个字符的渲染步骤为：

1.  加载字体文件；
2.  确定要输出的字体大小；
3.  输入这个字符的编码值；
4.  根据字体文件里面的字符映射表，把编码值转换成字形索引；
5.  根据索引从字体中加载这个字形；
6.  将这个字形渲染成位图，有可能进行加粗、倾斜等变换。

在选择字符映射表时，如果和输入的字符编码不一样，输出的字形要么是错的，要么就根本找不到对应的字形，屏幕上就会显示一个方块字。

Windows 上可以通过按下 `Win` + `R`，输入 `charmap` 后回车，打开【字符映射表】工具，就可以查看不同字体的字符所对应的字形以及字符编码。

一个字体文件所包含的字符数量是有限的，如仿宋 GB2312 字体，该字体并不是指用 GB2312 编码，而是指其字形包括了 GB2312 编码所支持的字符，对于超出范围的字符，该字体就无法正常渲染，会出现显示错误，通常情况下为方块字。

## 字体格式

字体文件有多种格式，目前比较常用的有 TTF、OTF 和 WOFF。

### TTF

TTF（TrueType Font）字体格式是由苹果和微软为 PostScript 而开发的字体格式。在 Windows 和 macOS 系统上，TTF 一直是最常见的格式，所有主流浏览器都支持它。

TTF 允许嵌入最基本的数字版权管理标志——内置标志可以告诉我们字体作者是否允许该字体用于商业场合，所以可能会有版权问题。另一个缺点是，TTF 和 OTF 字体是无压缩的，因此大小更大，加载速度更慢。

### OTF

OTF（OpenType Font）由 TTF 演化而来，是 Adobe 和微软共同努力的结果。OTF 字体包含一部分屏幕和打印机字体数据。OTF 有几个独家功能，包括支持多平台和扩展字符集。OTF 字体可以在 Windows 和  macOS 系统上使用。

OTF 也允许多达 65000 个字符的存储，这个额外的空间让设计师可以自由地添加附加元素。

### WOFF

WOFF（Web Open Font Format）本质上是 Metadata + 基于 SFNT 的字体（如 TTF、OTF 或其他开放字体格式）。该格式完全是为了 Web 而创建，由 Mozilla 基金会、微软和 Opera 软件公司合作推出。 WOFF 字体均经过 WOFF 的编码工具压缩，文件大小一般比 TTF 小 40%，加载速度更快，可以更好的嵌入网页中。Metadata 允许在字体文件中包含许可数据，以解决版权问题。这是万维网联盟提倡的，所以毫无疑问的是字体格式的未来。目前主流的浏览器几乎都支持 WOFF。

WOFF2 是 WOFF 的下一代，其在原有的基础上提升了 30% 的压缩率，但是目前还没有广泛支持。

### 静态字体

静态字体（Static Fonts）的字符被设计和数字化，然后存储在字体文件中。每次进行打印时，相同的字符将以相同的形状出现。静态字体的每种字型都需要单独的字体文件，因此其性能和灵活度不及可变字体。

### 可变字体

OpenType 可变字体（Variable Fonts）是一种 OpenType 字体格式，由苹果、微软、谷歌和 Adobe 联合开发，支持这一规范的计算机字体可以储存轮廓变化数据，在初始字形轮廓的基础上自动生成丰富的变化造型，使用户可以自由调整文字的外观。一个可变字体文件可以储存一个设计的多个变体，相当于包含了一个含有无数个字型的字体。因此可变字体的性能、灵活性和响应能力都更加优秀。

