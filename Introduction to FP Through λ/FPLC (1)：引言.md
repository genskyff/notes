>   主要参考：
>
>   -   [An Introduction to Functional Programming Through Lambda Calculus](https://book.douban.com/subject/6887111/)

# 1 引言

## 1.1 编程中的名称与值

为了不硬编码**值**（Value），需要使用一个**名称**（Name）来指代。就算值被改变，程序也能够通过名称来找到这个值。而命令式与函数式语言之间的主要区别在于**管理名称和值之间关联的规则**。

## 1.2 命令式和函数式语言中的名称与值

传统语言基于**变量**（Variable）这一概念构建，其中变量是指名称和值之间**可变的关联**（Changeable association）。这些语言被称为**命令式的**（Imperative），因为由一系列**命令**（Command）组成。

```
<command1>;
<command2>;
<command3>;
...
```

通常，每条命令都包含一个**赋值**（Assignment）操作，该操作会改变一个变量的值。这涉及计算一个**表达式**（Expression）的值，并将结果与一个名称关联起来。

```
<name> := <expression>
```

程序中每条命令中的表达式可能引用其它变量，而这些变量的值可能已被前面的命令改变过。这使得值可以从一个命令传递到另一个命令。

命令式的重要特征是命令之间的**顺序依赖性**。变量值可以被一个命令修改，然后被后续命令使用，形成了一种通过变量状态变化来传递信息的方式。

**函数式语言**（Functional language）基于结构化的**函数调用**（Function call）。函数式程序是一个由函数调用组成的表达式，其中一个函数会依次调用其它函数。每个函数都从调用它的函数接收值，并将新值返回给调用函数。

```
<func1>(<func2>(<func3>...)...)
```

函数式编程的重要特征是强调的函数调用的**嵌套**（Nesting）或**组合**（Composition），而不是顺序执行的命令，结构化则体现了函数调用之间的层次关系。

在命令式中，命令可以改变先前命令与名称关联的值，因此同一个名称可以与不同的值关联。

在函数式中，名称只能作为函数的形式参数引入，并通过带有实际参数的函数调用来赋值。一旦形式参数与实际参数值关联，就无法让其与新值重新关联，因此一个名称一旦关联了一个值，则永远只与该值关联。

这两种范式最本质的区别之一为：命令式允许通过赋值改变值与名称关联，而函数式则强调**不变性**（Immutability），一旦建立名称与值的关联就不能改变。

## 1.3 命令式和函数式语言中的执行顺序

在命令式中，命令的顺序通常至关重要，若顺序变了，那么程序的行为就很可能改变。如 `T` 的值取决于 `X` 的值，`X` 的值取决于 `Y` 的值，`Y` 的值取决于 `T` 的值，因此序列中的任何变化都会影响最后的结果。

```
T := X;
X := Y;
Y := T;
```

并非所有的命令序列都有固定的执行顺序。一些命令式语言可能没有定义执行表达式的顺序，因此对于包含函数调用的表达式，可以不定义调用函数的顺序。函数体有命令块，因此不同命令块的执行顺序可能没有定义。

当命令式语言允许**副作用**（Side effect）时，即可以通过表达式更改变量，则可能会导致问题。如当函数通过对其参数之一或全局变量赋值来更改非局部变量时，若计算子表达式的顺序是不可预测的，那副作用发生的顺序也是不可预测的，这使得调试程序变得十分困难。

若命令的表达式之间不相互引用，那么命令的顺序的确无关紧要，但通常**命令式语言有固定的执行顺序**。

函数式语言没有赋值，函数调用不会更改与名称关联的值，因此没有副作用，这意味着执行嵌套函数调用的顺序并不重要，函数之间可以随意组合。**通常函数式语言没有固定的执行顺序**，当然函数式程序必须以某种顺序执行，但顺序并不影响最终结果。

```ruby
def f(x, y, z); end
def g(x); end
def h(x); end
def l(x); end

f(g(a), h(a), l(a))
```

`g(a)`、`h(a)` 和 `l(a)` 的执行顺序并不重要，因为共同参数 `a` 无法被改变。

## 1.4 命令式和函数式语言中的重复

在命令式中，由于变量的可变性，每条新命令并不一定要引入一个新的名称。为了多次执行，没有必要重复编写。如计算数组元素的和，通常**不会**这么写：

```
sum0 := a[0];
sum1 := sum0 + a[1];
sum2 := sum1 + a[2];
...
```

在命令式语言中，**通过命令重复，如循环，重复改变与名称关联的值**：

```
i := 0;
sum := 0;
while i < N
  i := i + 1;
  sum := sum + a[i]
end
```

在函数式语言中，由于名称的值是不可变的，因此**通过嵌套函数调用来为新值创建名称的新版本**。同样，由于不能使用命令重复来更改与名称关联的值，因此**通过递归函数调用来创建与新值关联的名称的新版本**。函数调用自己来创建其形式参数的新版本，然后将其绑定到新的实际参数中。

```ruby
def sum(a, i, n)
  if i >= n
    0
  else
    a[i] + sum(a, i + 1, n)
  end
end
```

如对于函数调用：

```ruby
sum(a, 0, n)
```

通过连续递归调用，每次都会创建 `a`、`i`、`n` 的新版本，之前的版本则无法访问了。每次递归调用结束时，新的局部变量将丢失，部分和将返回给前一次调用，并且之前的局部变量将重新使用。

```ruby
a[0] + sum(a, 1, n)
a[0] + a[1] + sum(a, 2, n)
a[0] + a[1] + a[2] + sum(a, 3, n)
...
a[0] + a[1] + a[2] + ... + a[n] + sum(a, n + 1, n)
a[0] + a[1] + a[2] + ... + a[n] + 0
```

因此**在函数式语言中，通过递归函数调用嵌套将新值与新名称关联起来**。

## 1.5 函数式语言的数据结构

命令式中的数据结构如数组（Array）通过连续赋值来改变**子结构**（Substructures），但函数式没有赋值操作，自然也就无法逐个改变子元素，相反每次修改都需要创建新的完整数据结构，数据结构的构建和操作是更加透明和直接的。

```ruby
# 命令式
array = [1, 2, 3]
array[1] = 5  # 隐式地修改了数据结构

# 函数式
list = [1, 2, 3]
new_list = [1, 5, 3] # 显式创建新的数据结构
```

函数式没有数组，而是使用列表（List）这种基于递归的嵌套数据结构，这与嵌套函数调用类似。这带来了许多优势：

-   标准化：数据结构有统一的显示和存储格式
-   简化调试：不需要为不同结构写特殊的打印程序
-   数据流清晰：函数间的数据传递更加明确

另一个区别是命令式语言具有全局变量，可以不通过函数参数传递来直接修改外部变量。而函数式没有全局变量，必须显式作为函数参数传递，更改整个结构后再完整的返回。虽然这会导致参数变多，但也让程序逻辑更加清晰。

## 1.6 函数作为值

在许多命令式语言中，函数可以作为参数传递，但很少可以作为返回值。而在函数式语言中，函数也可以作为返回值，并传递给其它函数，即函数本身也是值。

```typescript
type OpType = 'ADD' | 'SUB' | 'MUL' | 'QUO';
type ArithmeticFn = (x: number, y: number) => number;

function arith(op: OpType): ArithmeticFn {
    function sum(x: number, y: number): number {
        return x + y;
    }

    function diff(x: number, y: number): number {
        return x - y;
    }

    function times(x: number, y: number): number {
        return x * y;
    }

    function divide(x: number, y: number): number {
        return x / y;
    }

    switch(op) {
        case 'ADD':
            return sum;
        case 'SUB':
            return diff;
        case 'MUL':
            return times;
        case 'QUO':
            return divide;
    }
}
```

这将允许使用像这样的方式来进行函数调用：

```typescript
arith('ADD')(1, 2);
arith('MUL')(3, 4);
```

这在许多命令式语言中是非法的，因为无法构造函数类型。而在函数式语言中，函数可以作为一种值，被当做参数或返回，从而赋予了更灵活的表达能力。这个特性也被称为**高阶函数**（Higher-order function），是函数式的核心特征之一，体现了函数作为**一等公民**（First-class citizens）的概念。

## 1.7 函数式语言的起源

函数式编程的理论基础源于 19 世纪中期的数理逻辑。哈密顿、德摩根和布尔建立了现代形式化逻辑体系，包括命题演算和谓词演算。命题演算处理真假值和基本逻辑运算，而谓词演算则扩展到处理数字、集合等非逻辑值。这一时期，皮亚诺还发展了形式化数论，引入了类似递归的数学归纳思想。

20 世纪初，罗素和怀特黑德试图用逻辑构建数学基础，希尔伯特则提出了完备性计划。虽然这个计划最终被哥德尔的不完备性定理否定，但促进了可计算性理论的发展。1936 年是一个重要的转折点，三种重要的可计算性理论相继提出：图灵的**图灵机**、邱奇的 **λ 演算**和克莱尼的**递归函数理论**。

在这三种理论中，图灵机侧重于基于赋值和顺序执行的机械化计算，而 λ 演算和递归函数理论则强调结构化的函数应用，其特点是求值顺序无关。邱奇-图灵论题认为所有可计算性描述都是等价的，而邱奇-罗瑟定理则证明了在 λ 演算中不同求值顺序的等价性。这些特性为现代函数式编程提供了重要的理论基础，也为并行计算提供了可能性。

这些早期的理论工作，特别是 λ 演算和递归函数理论，构成了现代函数式编程语言的基石。不仅影响了编程语言的设计，也深刻影响了整个计算机科学领域的发展。如今的函数式编程语言仍然体现着这些基础理论的核心思想：**不变性**、**无副作用**和**时序独立性**。

## 1.8 计算与计算理论

函数式编程的理论基础源于 λ 演算和递归函数理论。1963 年麦卡锡创造的 Lisp 语言首次将这些理论实现为编程语言，引入了**无类型变量**和**程序即数据**的核心概念。60 年代中期，兰丁的 SECD 机器和斯特雷奇的指称语义学，结合斯科特的数学理论，为函数式编程奠定了完整的理论框架。这期间涌现出 ML、SASL 等重要语言。1978 年，巴克斯提出函数式编程的概念，强调了其数学基础和时序独立性，推动了函数式编程在实践领域的广泛应用，形成了现代函数式编程的理论与实践体系。

>   **指称语义学**（Denotational semantics）是一种描述编程语言语义的数学方法，其基本原则为：每个程序结构都映射到一个数学对象（通常是一个函数），这个数学对象就是该程序的含义或指称。
>
>   如：
>
>   -   变量的指称是值
>   -   表达式的指称是计算该表达式得到的结果
>   -   程序的指称是将输入状态映射到输出状态的函数
>
>   其重要性在于：
>
>   -   提供了一种精确的、不依赖于具体实现的方式来描述程序的含义
>   -   使得程序的正确性证明变得更加规范和严谨
>   -   为不同编程语言提供了一个统一的数学基础
>
>   这种方法在形式化验证和语言设计中发挥着关键作用。

## 1.9 λ 演算

λ 演算是一个简单而强大的形式系统，基于**函数抽象**——通过引入名称来泛化表达式和**函数应用**——通过给名称特定值来评估泛化表达式这两个核心概念。λ 演算能作为编程语言的通用基础，其求值顺序无关性使其能够研究不同语言的求值策略，以及完善的证明技术也能应用于语言描述。正是由于这种简单性和数学基础，λ 演算可以作为实现原型和构建更复杂语言特性的基石，为现代函数式编程提供了理论框架。

## 总结

基本结构：

-   命令式：基于赋值序列
-   函数式：基于嵌套函数调用

变量特性：

-   命令式：一个名称可关联多个值（可变）
-   函数式：一个名称只关联一个值（不可变）

求值顺序：

-   命令式：求值顺序固定
-   函数式：求值顺序不固定

状态更新方式：

-   命令式：通过命令重复来更新同一名称的值
-   函数式：通过递归函数调用嵌套，用新名称关联新值

独特性：

-   函数式语言提供显式的数据结构表示
-   函数式语言中函数被视为值（一等公民）

理论基础：

-   命令式语言源于冯·诺依曼体系结构
-   函数式语言源于数学逻辑、计算理论、λ 演算和递归函数理论
