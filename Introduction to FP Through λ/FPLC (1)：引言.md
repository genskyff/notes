> 参考：
>
> - [An Introduction to Functional Programming Through Lambda Calculus](https://book.douban.com/subject/6887111/)

# 1 引言

## 1.1 编程中的名称与值

为了不硬编码**值**（Value），需要使用一个**名称**（Name）来指代。就算值被改变，程序也能够通过名称来找到这个值。而命令式与函数式语言之间的主要区别在于**管理名称和值之间关联的规则**。

## 1.2 命令式和函数式语言中的名称与值

命令式语言（Imperative Languages）：

-   基于**变量**（Variable）的概念，即名称和值之间**可变的关联**（Changeable association）。

-   程序由一系列**命令**（Command）组成，通常是**赋值**（Assignment）语句，用于改变变量的值。

    ```
    <cmd1>
    <cmd2>
    <cmd3>
    ...
    
    <name> = <expr>
    ```

-   状态传递：值通过共享变量从一个命令传递到下一个命令，后续命令的行为依赖于先前命令对变量状态的修改。

-   一个名称可以关联多个值：在程序运行期间，同一个名称（变量）可以与不同的值相关联。

函数式语言（Functional language）：

-   基于结构化的**函数调用**（Function call）。程序是一个由函数调用组成的**表达式**（Expression），由层层嵌套的函数调用构成，也称为**函数组合**（Function Composition）。

    ```
    <func1>(<func2>(<func3>...)...)
    ```

-   **不可变性**（Immutability）：名称只在函数定义时作为形式参数引入，并在函数调用时绑定到实际参数的值上。一旦绑定，这种关联就不可更改。

-   一个名称只关联一个值：在一个作用域内，一个名称永远只与一个值相关联。

## 1.3 命令式和函数式语言中的执行顺序

命令式语言：

-   执行顺序至关重要。由于命令通过修改共享变量来传递值，改变命令的执行顺序会彻底改变程序的行为。如变量交换：`t = x; x = y; y = t;`，序列的任意变动都会导致完全不同的结果。
-   命令式语言通常允许函数修改非局部变量或全局变量，这被称为**副作用**（Side Effect）。若表达式（尤其是函数调用）的求值顺序不确定，那么副作用发生的顺序也不可预测，这会使程序的理解、开发和调试变得异常困难。

函数式语言：

-   没有固定的执行顺序。由于不存在赋值和副作用，函数调用之间不会相互影响。
-   求值顺序无关性：对于一个函数调用 `f(a(x), b(x), c(x))`，由于函数 a、b、c 无法改变它们的共同参数 x，所以这三个函数调用的执行顺序不影响最终结果。这种特性是函数式语言的一大优势，为并行计算等优化提供了理论可能。

## 1.4 命令式和函数式语言中的重复

在命令式中，由于变量的可变性，每条新命令并不一定要引入一个新的名称。为了多次执行，没有必要重复编写。如计算数组元素的和，通常**不会**这么写：

```
sum0 = a[0]
sum1 = sum0 + a[1]
sum2 = sum1 + a[2]
...
```

在命令式语言中，通过**命令重复**，也叫**迭代**（Iteration），如循环，重复改变与名称关联的值：

```ruby
i = 0
sum = 0
while i < N
  i += 1
  sum += a[i]
end
```

在函数式语言中，由于值的不可变性，无法通过迭代修改旧值。因此，通过**递归**（Recursion）来实现重复。

```ruby
def sum(a, i, n)
  if i >= n
    0
  else
    a[i] + sum(a, i + 1, n)
  end
end
```

函数调用自身，创建形式参数的新版本，并为这些新名称绑定上新值，如对于函数调用：

```ruby
sum(a, 0, n)
```

通过连续递归调用，每次都会创建 `a`、`i`、`n` 的新版本，之前的版本则无法访问了。每次递归调用结束时，新的局部变量将丢失，部分和将返回给前一次调用，并且之前的局部变量将重新使用。

```ruby
a[0] + sum(a, 1, n)
a[0] + a[1] + sum(a, 2, n)
a[0] + a[1] + a[2] + sum(a, 3, n)
...
a[0] + a[1] + a[2] + ... + a[n] + sum(a, n + 1, n)
a[0] + a[1] + a[2] + ... + a[n] + 0
```

## 1.5 函数式语言的数据结构

命令式语言：

-   数据结构（如数组、记录）的**子结构**（Substructures）可以通过赋值被独立修改。
-   隐式数据流：命令式语言具有全局变量，可以不通过函数参数传递来直接修改外部变量。

函数式语言：

-   整体替换：由于没有赋值操作，不能单独修改数据结构的某个部分。任何修改都需要创建一个全新的数据结构，其中包含已修改的部分。
-   列表（List）优于数组（Array）：函数式语言通常不提供数组，因为无法方便地修改单个元素。取而代之的是基于递归定义的嵌套数据结构。
-   显式数据流：任何数据结构都必须作为参数显式地传递给函数，函数处理后将整个更新后的结构返回。这使得数据在程序中的流动非常清晰。

```ruby
# 命令式
array = [1, 2, 3]
array[1] = 5  # 隐式修改数据结构

# 函数式
list = [1, 2, 3]
new_list = [1, 5, 3] # 显式创建新的数据结构
```

## 1.6 函数作为值

函数是**一等公民**（First-class citizens）：这是函数式语言的一个核心特征，函数可以被当作值来处理。

-   作为参数传递给其他函数

-   作为另一个函数的返回值

-   存储在数据结构中

**高阶函数**（Higher-order function）：能够操作其他函数（接收函数作为参数或返回一个函数）的函数。

```typescript
type OpType = "ADD" | "SUB" | "MUL" | "QUO";
type ArithmeticFn = (x: number, y: number) => number;

function arith(op: OpType): ArithmeticFn {
  function sum(x: number, y: number): number {
    return x + y;
  }

  function diff(x: number, y: number): number {
    return x - y;
  }

  function times(x: number, y: number): number {
    return x * y;
  }

  function divide(x: number, y: number): number {
    return x / y;
  }

  switch (op) {
    case "ADD":
      return sum;
    case "SUB":
      return diff;
    case "MUL":
      return times;
    case "QUO":
      return divide;
  }
}
```

这将允许使用像这样的方式来进行函数调用：

```typescript
arith("ADD")(1, 2);
arith("MUL")(3, 4);
```

这在许多命令式语言中是非法的，因为无法构造函数类型。而函数式语言则可以，这赋予了其更灵活的表达能力。

## 1.7 函数式语言的起源

理论基石：函数式编程根植于数理逻辑。

-   19 世纪：布尔、德摩根等人形式化了**命题演算**和**谓词演算**，这些系统中的名称与值的关联是固定的，且表达式没有固定的求值顺序。

-   20 世纪初：罗素和怀特海德试图从逻辑推导数学，希尔伯特的计划推动了**可计算性理论**的发展。

-   1936 年：诞生了三种等价的可计算性形式系统。
    -   图灵（Turing）的图灵机：基于赋值和时序的机械化符号操作模型

    -   克莱尼（Kleene）的递归函数理论：强调结构化的函数应用

    -   邱奇（Church）的 λ 演算：同样强调结构化的函数应用，且求值顺序无关


重要理论：

-   邱奇论题（Church's thesis）：所有关于可计算性的描述都是等价的

-   停机问题（Halting problem）：图灵证明了无法判断任意图灵机是否会停机，这同样适用于 λ 演算

-   Church-Rosser 定理：对于 λ 演算，若不同的求值顺序都能终止，其结果必然相同

这些早期的理论工作，构成了现代函数式编程语言的基石。如今的函数式编程语言仍然体现着这些基础理论的核心思想：**不变性**、**无副作用**和**时序独立性**。

## 1.8 计算与计算理论

 理论对实践的影响：计算理论深刻影响了编程语言的设计和发展。

-   LISP：1963年，McCarthy 受 λ 演算和递归函数理论启发，创造了 LISP 语言。其基于递归函数，其核心特点是**程序即数据**，即程序本身也是一个列表结构。

-   λ 演算的应用：
    -   Landin：使用 λ 演算构建了 SECD 抽象机来解释 Algol 60，为函数式语言的实现提供了模型
    -   Strachey：发展了**指称语义学**，用基于 λ 演算的函数来描述命令式语言的含义
    -   现代函数式语言：ML、Haskell 等

> **指称语义学**（Denotational semantics）是一种描述编程语言语义的数学方法，其基本原则为：每个程序结构都映射到一个数学对象（通常是一个函数），这个数学对象就是该程序的含义或指称。
>
> 如：
>
> - 变量的指称是值
> - 表达式的指称是计算该表达式得到的结果
> - 程序的指称是将输入状态映射到输出状态的函数
>
> 其重要性在于：
>
> - 提供了一种精确的、不依赖于具体实现的方式来描述程序的含义
> - 使得程序的正确性证明变得更加规范和严谨
> - 为不同编程语言提供了统一的数学基础
>
> 这种方法在形式化验证和语言设计中起着关键作用。

## 1.9 λ 演算

λ 演算是一个简单而强大的形式系统，基于两个核心概念：

-   **函数抽象**：通过引入名称来泛化表达式

-   **函数应用**：通过为名称赋予具体值来特化（求值）表达式

λ 演算能作为编程语言的通用基础，其求值顺序无关性使其能够研究不同语言的求值策略，以及完善的证明技术也能应用于语言描述。正是由于这种简单性和数学基础，λ 演算可以作为实现原型和构建更复杂语言特性的基石，为现代函数式编程提供了理论框架。

## 总结

基本结构：

- 命令式：基于赋值序列
- 函数式：基于嵌套函数调用

变量特性：

- 命令式：一个名称可关联多个值（可变）
- 函数式：一个名称只关联一个值（不可变）

求值顺序：

- 命令式：求值顺序固定
- 函数式：求值顺序不必固定

状态更新方式：

- 命令式：通过命令重复来更新同一名称的值
- 函数式：通过递归函数调用嵌套，用新名称关联新值

函数式独特性：

- 显式的数据结构表示
- 函数被视为值（一等公民）

理论基础：

- 命令式：基于冯·诺依曼体系结构
- 函数式：数理逻辑、计算理论、λ 演算和递归函数理论
