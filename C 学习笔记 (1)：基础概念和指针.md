>   主要参考：
>
>   -   《C Primer Plus 中文版》第 6 版
>   -   《C 陷阱与缺陷》
>   -   《C 和指针》
>   -   《深入理解计算机系统》第 3 版

# 1 C 概述

## 语言标准

C 语言最初并没有官方标准，最早是其创始人所著的 *The C Programming Language* 一书成为大家接受的标准，被称为 **K&R C**。

美国国家标准化组织（ANSI）在 1983 年成立了一个委员会（X3J11）以发展一个新标准，该标准于 1989 年正式采用。这个新标准（ANSI C）定义了 C 语言和 C 标准库。国际标准化组织（ISO）于 1990 年采用了这个 C 标准（ISO C），所以 ANSI C 和 ISO C 是同一个标准，而 ANSI C / ISO C 标准的最终版本被称为 **C89 / C90**。

1999 年发布的修订后的 C 标准被称为 **C99**，目前绝大多数编译器都已支持 C99 标准，目前最新的是 2011 年发布的 **C11** 标准。

## 编程机制

编写程序时，编写的内容被称为**源代码**，源代码保存在一个被称为**源文件**的文本文件中。C 语言的源文件名后缀为 `.c` ，如 `main.c` ，`.` 号前面部分为**基本名**，后半部分为**扩展名**，组合起来是**文件名**。main.c 中的内容以**字节序列**的方式存储在文件中，每个字节都有一个整数值，该整数对应于某个字符，通常为 **ASCII** **字符**，只由 ASCII 字符构成的文件为**文本文件**，否则是**二进制文件**。

编程的基本策略是使用**编译器**将源代码文件转换为**可执行文件**，编译器是一种将高级语言编写的程序解释成计算机能够理解的机器语言的程序，此文件包含可以运行的机器语言代码，编译器分两步完成这项工作——**编译**和**链接**。

编译器将源代码文件转换成**中间代码**，链接器将中间代码和其它代码（启动代码和库代码）合并生成可执行文件。这样可以使程序便于模块化，当有多个模块需要编译时，可以分别编译各个模块，然后用链接器将编译后的模块合并起来。如果需要更改某个模块，只需重新编译此模块，然后重新链接，不必把所有的模块都重新编译。

中间文件通常是将源代码转换成机器语言代码，并把结果放在一个被称为**目标代码**的文件中，此文件还不能运行，原因是缺少**启动代码**和**库代码**。

启动代码相当于程序和操作系统之间的**接口**（API），因为不同的系统对程序的处理方式不同，所以不同系统的启动 代码不同。

库代码是 C 标准库中所包含的代码，如 `printf` 函数使用了头文件 `stdio.h` 中所声明的代码，而定义这个函数的代码在另一个库文件中，目标文件不包含定义此函数的代码。

链接器的作用是将这三个元素（目标代码、启动代码和库代码）合并在一起，并生成可执行文件。链接器只从库代码 中提取程序中所用到的函数所需要的代码，并不会全部提取。

目标文件和可执行文件都是由机器语言指令组成的，但目标文件只包含所编写的代码转换成的机器代码，而可执行文件则包含启动代码和程序所使用的库代码所转换成的机器代码。

## 程序示例

```c
/* 文件 main.c */
#include <stdio.h>

int main(void)                          // 主函数开始
{
    int num = 1;                        // 声明一个名为 num 的 int 型变量，并赋初值为 1
    printf("The number is %d.\n", num); // 调用 printf 函数
    return 0;
}
```

运行结果：

> The number is 1.

## 示例说明

第 1 行为**注释**，范围在 `/*` 和 `*/` 之间，可以跨越多行。以 `//` 开头的是 C99 新增的注释方式，只能注释单行。注释只是方便自己和别人理解代码，在编译时会被编译器忽略。

第 2 行为**预处理指令**，这使编译器在编译前要对源代码做一些准备工作，`#include` 指令表示在该程序中的该行引入头文件 `stdio.h` 中的完整内容。`stdio.h` 文件为 C 标准库所提供，表示**标准输入输出头文件**，它提供了有关输入输出函数的信息，如 `printf()` 和 `scanf()`。头文件还包含了建立最终可执行程序时编译器所用到的信息，如定义常量、声明函数等，但里面函数的定义代码通常在被包含在另一个**预编译代码**的库文件中，编译器的链接部分负责找到所需要的库代码。出现在文件顶部的信息的集合称为**头**。

第 3 行为 `main` 函数，C 总是且只从 main 函数开始执行，一个 C 程序有且仅有一个 main 函数存在。圆括号表示它是一个函数，int 指明了该函数的返回值类型，在此返回一个整型的数给操作系统。圆括号里面表示要传递给该函数的信息，void 表示不传递任何信息。

第 4 ~ 8 行用大括号括起来的部分划定了 main 函数的界限，中间的代码称为**代码块**。

第 5 行是一条**声明**，它声明了一个**变量**，并通过赋值运算符 `=` 把值赋给变量。int 是 C 中的一个**关键字**，表示一种**基本数据类型**。`num` 为**标识符**，标识符不能为 C 中的关键字。`;` 表示这是一条**语句**。所有的变量在使用前都必须先声明，声明后编译器才会为变量分配内存空间。

C99 允许一个标识符最多有 63 个字符，外部标识符最多有 31 个字符，C90 分别为 31 个和 6 个。可以使字符数量超过限制，但编译器不会识别超出之后的字符。标识符只能以**英文字母**或**下划线**开头，除开头之外的字符可以是英文字 母、数字或下划线，且**区分大小写**。

程序第 6 行调用了 C 中的一个标准函数，圆括号中的内容为 main 函数传递给 printf 函数的信息，称为**参数**。双引号表示这是一个字符串，这个字符串为第一个参数，而后面的 num 为第二个参数，参数与参数之间用逗号分隔。

第一个参数中的 `%d` 是一个**占位符**，作用是指出第二个参数 num 的位置，`%` 号表示**格式化输出**，`d` 表示把 num 的值以十进制整数形式输出，占位符可以看作是引用 num 的值，并把它放到这个位置上。`\n` 是一个**转义字符**，表示输出一个换行符。

在 C 中调用一个函数只需输入函数名字，把所需的参数放进圆括号中，当程序运行到这一行时，控制权将交给该函数，当函数完成了它所做的工作后，控制权移交给原来的函数。在这个例子中，main 函数为**调用函数**， printf 函数为**被调函数**。

第 7 行是返回语句，所有具有返回值的函数都需要有 return 语句。

C 语言的基本模块是**函数**，**一个程序由一个或多个函数组成，其中有且仅有一个** **main** **函数**。函数由**函数头**和**函数体**组成，函数头包括**函数名**、**传入该函数的参数**和**函数的返回值类型**，函数体由一对大括号和位于大括号中的语句组成，每条语句以一个分号结束。

## 关键字和保留标识符

关键字是 C 语言的词汇，**不能把关键字当作标识符，关键字用于指定不同的类型和控制程序执行的过程**。保留标识符是 C 语言已经指定了它们的用途或保留它们的使用权，操作系统和 C 标准库里经常使用以下划线开头的标识符，这 些都可以视为保留标识符。把关键字当作标识符编译器会报错，而保留标识符不会，但可能导致一些潜在问题。

| **关键字** | **关键字** | **关键字** | **关键字**            |
| ---------- | ---------- | ---------- | --------------------- |
| auto       | extern     | short      | while                 |
| break      | ﬂoat       | signed     | _Alignas（C11）       |
| case       | for        | sizeof     | _Alignof（C11）       |
| char       | goto       | static     | _Atomic（C11）        |
| const      | if         | struct     | _Bool（C99）          |
| continue   | inline     | switch     | _Complex（C99）       |
| default    | int        | typedef    | _Generic（C99）       |
| do         | long       | union      | _Imaginary（C99）     |
| double     | register   | unsigned   | _Noreturn（C99）      |
| else       | restrict   | void       | _Static_assert（C99） |
| enum       | return     | volatile   | _Thread_local （C99） |

## 编译过程

程序编写好了以后需要编译执行，用 GCC 编译器，以上面的 `main.c` 文件为例，其编译过程如下。

### 单步编译

编译为可执行文件 `main`：

```bash
gcc main.c -o main
```

### 分步编译

实际上编译过程分为四步——**预处理**、**编译**、**汇编**、**链接**。

#### 预处理

 ```bash
 gcc -E main.c -o main.i
 ```

预处理器根据 `#` 开头的预处理指令修改源程序，此时 `main.i` 还是文本文件。

#### 编译

```bash
gcc -S main.i -o main.s
```

编译器将文本文件 main.i 转换成由**汇编语言**组成的文本文件 `main.s`。

#### 汇编

 ```bash
 gcc -c main.s -o main.o
 ```

汇编器将 main.s 转换成由机器语言指令组成的**可重定位目标程序** `main.o`（即目标文件），此时它还缺少启动代码。

#### 链接

```bash
gcc main.o -o main
```

因为程序调用了 printf 函数，而其存在于一个名为 `printf.o` 的单独预编译好了的目标文件中，链接器把这个文件合并到 main.o 的程序中，再把启动代码合并到程序中，从而得到 main 文件，它是一个可执行文件，能被加载到内存中，由系统执行。

#### 产生所有中间文件

使用 `-save-temps` 选项相当于同时执行了以上几个步骤：

```bash
gcc -save-temps main.c
```

### 运行

最后在终端中运行该程序：

 ```bash
 ./main
 ```

### 多文件编译

设一个由 `file_1.c` 和 `file_2.c` 两个源文件组成的程序，为了对它们一起进行编译，并最终生成可执行程序 main ，可以使用如下命令：

 ```bash
 gcc file_1.c file_2.c -o main
 ```

这个过程仍然会按照预处理、编译、汇编和链接的过程依次进行，上面这条命令相当于依次执行以下三条命令：

```bash
gcc -c file_1.c -o file_1.o
gcc -c file_2.c -o file_2.o
gcc file_1.o file_2.o -o main
```

## 常用 GCC 编译选项

### 以特定标准编译

通常编译器默认以 C90 标准来编译，若需要指明用哪一个标准，可以使用 `-std` 选项。

以 C99 标准编译：

 ```bash
 gcc -std=c99 main.c -o main
 ```

以 C11 标准编译：

  ```bash
  gcc -std=c11 main.c -o main
  ```

### 编译为 32 / 64 位的程序

编译为 32 位程序：

```bash
gcc -m32 main.c -o main
```

编译为 64 位程序：

```bash
gcc -m64 main.c -o main
```

### 开启编译优化

通常编译器并没有开启编译优化，开启编译优化后，编译器会试图生成更快更小的代码，但这可能会增加编译时间，并使编译后的程序变得更大更耗内存，甚至会引发一些错误，需要谨慎使用。

使用 `-O` 选项来开启编译优化，有 `O0 ~ O3` 这几个优化等级。`-O0` 为默认值，即不优化，`-O3` 优化程度最高，但很容易出现问题。

以 `-O2` 优化编译：

```bash
gcc -O2 main.c -o main
```

### 启用所有警告

```bash
gcc -Wall main.c -o main
```

启用这条选项以后，包括未初始化的变量也会产生警告。

### 将警告视为错误

```bash
gcc -Werror main.c -o main
```

 `-Werror` 选项会把警告升级成错误。

### 链接共享库

不能被编译器自动链接的共享库，可以使用 `-l` 选项手动链接。

```bash
gcc main.c -o main -lm
```

此时编译器会链接 `libm.so`，并产生可执行文件 `main`。

### 生成位置无关的代码

当生成共享库的时，应生成位置无关的代码，这会让共享库使用任意的地址而不是固定的地址，需要使用 `-fPIC` 选项。

```
gcc -c -fPIC main.c
gcc -shared main.o -o main.so
```

`-shared` 选项表示生成共享库，此时编译器会生成 `main.so` 动态库。

### 生成静态链接的文件

`-static` 选项把动态库的函数和其它依赖都编译进最终文件：

```bash
gcc -static main.c -o main -lm
```

相反 `-shared` 选项使用动态库链接。

### 静态链接 libstdc++

如果没有使用 `-static`，则默认使用 libstdc++ 共享库，而 `-static-libstdc++` 可以指定使用 libstdc++ 静态库。

```bash
gcc -static-libstdc++ main.c -o main
```

# 2 数据类型

## 数据类型

数据分为**常量**和**变量**，而数据类型分为**整数类型**和**浮点数类型**。整数类型可以在范围内精确表示，而浮点数只能近似表示。

C 使用关键字来声明不同的数据类型。

| **关键字**        | **类型**       | **关键字**         | **类型**       |
| ----------------- | -------------- | ------------------ | -------------- |
| void              | 空类型         | void*              | 指针类型       |
| signed            | 有符号型       | unsigned           | 无符号型       |
| char              | 字符型（整型） | short              | 短整型         |
| int               | 整型           | long               | 长整型         |
| long long（C99）  | 长长整型       | ﬂoat               | 单精度浮点型   |
| double            | 双精度浮点型   | long double（C99） | 长双精度浮点型 |
| _Bool（C99）      | 布尔类型       | _Complex（C99）    | 复数类型       |
| _Imaginary（C99） | 虚数类型       |                    |                |

## 存储机制

计算机存储信息的**基本单位**是**位**（Bit），8 位为 1 **字节**（Byte），计算机使用字节作为最小的的**可寻址的**存储单位。计算机将存储器视为一个非常大的**字节数组**，称为**虚拟存储器**。存储器的每个字节都由一个唯一的数字来表示，称为**地址**，所有可能地址的集合称为**虚拟地址空间**。每台计算机都有一个**字长**，32 位系统的字长为 4 字节，64 位系统的字长为 8 字节。字长指明了整数和指针的标称大小，且决定了虚拟地址空间的最大大小。

不同的数据类型使用不同的方法来存储数据，占用不同大小的空间。对于不同位数的机器来说，分配的字节数也可能不同。一般来说，int 存储在计算机的一个字中（通常是 4 个字节），而 long 使用机器的全字长，指针也使用机器的全字长。

## 类型表示

在 32 / 64 位机器上，整数的典型占用大小和表示范围如下（方括号为可选项）：

| **类型**                  | **大小**        | **范围**                                                     |
| ------------------------- | --------------- | ------------------------------------------------------------ |
| [signed] char             | 1 Byte          | -128 ~ 127                                                   |
| unsigned char             | 1 Byte          | 0 ~ 255                                                      |
| [signed] short [int]      | 2 Byte          | -32768 ~ 32767                                               |
| unsigned short [int]      | 2 Byte          | 0 ~ 65535                                                    |
| [signed] int              | 4 Byte          | -2<sup>31</sup> ~ 2<sup>31</sup> - 1                         |
| unsigned [int]            | 4 Byte          | 2<sup>32</sup> - 1                                           |
| long [int]                | 4 Byte / 8 Byte | -2<sup>31</sup> ~ 2<sup>31</sup> - 1 / -2<sup>63</sup> ~ 2<sup>63</sup> - 1 |
| unsigned long [int]       | 4 Byte / 8 Byte | 0 ~ 2<sup>32</sup> - 1 / 0 ~ 2<sup>64</sup> - 1              |
| [signed] long long  [int] | 8 Byte          | -2<sup>63</sup> ~ 2<sup>63</sup> - 1                         |
| unsigned long long [int]  | 8 Byte          | 0 ~ 2<sup>64</sup> - 1                                       |

在 32 / 64 位机器上，浮点数的典型占用大小和表示范围如下：

| **类型**    | **大小** | **范围**                                       | **有效位数** |
| ----------- | -------- | ---------------------------------------------- | ------------ |
| ﬂoat        | 4 Byte   | 3.4×10<sup>-38</sup> ~ 3.4×10<sup>38</sup>     | 6            |
| double      | 8 Byte   | 1.7×10<sup>-308</sup> ~ 1.7×10<sup>308</sup>   | 15           |
| long double | 16 Byte  | 1.2×10<sup>-4932</sup> ~ 1.2×10<sup>4932</sup> | 18           |

在 32 / 64 位机器上，指针的典型存储大小和范围如下：

| **类型** | **大小**        | **范围**                               |
| -------- | --------------- | -------------------------------------- |
| void*    | 4 Byte / 8 Byte | 从地址 0 开始 ~ 虚拟地址空间的最大大小 |

以上只表示通常范围，C 标准只做以下几点保证：

-   short 和 int 至少 16 位长，long 至少 32 位长，long long 至少 64 位长，且 short ≤ int ≤ long ≤ long long；

-   当使用一个整数时，默认以 int 表示，当 int 不能表示时，使用 unsigned int ，当 unsigned int 不能表示时，使用 long，当 long 不能表示时，使用 unsigned long，当 unsigned long 不能表示时，使用 long long，当 long long 不能表示时，使用 unsigned long long；

-   当使用一个浮点数时，默认以 double 表示；

-   int 默认为计算机处理起来最高效的整数类型。

可以使用不同的前缀和后缀来表示不同的数。

```c
037, 0x71a3f                    // 八进制数，十六进制数
12345u, 9876L, 10000LL, 2223UL  // 无符号整数，长整数，长长整数，无符号长整数
123.123f, 100.00L               // 单精度浮点数，长双精度浮点数
-1.23e10                        // 指数表示法
.234, .07e-5, -.6               // 省略整数部分
0xc1.6dP8                       // 十六进制浮点数表示法（C99）
```

## 字符表示

C 中 char 类型用于存储单个字符，包括但不限于字母、数字、标点符号等。通常使用 1 字节的存储大小，但出于表示基本字符集的需要，它也可以为 2 字节。C 把 1 字节定义为一个 char 类型所占大小，而不是 8 Bit。

在用 char 存储字符时，C 将字符视为 int 类型，因为 char 的取值范围在 int 的范围内，而系统使用 int 的效率最高，通常也用 char 来存储数值较小的整数。

字符用一对单引号括起来，有且只能有一个字符，如 `'a'`、`'\n'`。

### 转义字符

有些字符无法通过键盘输入，或者是 ASCII 字符打印不出来的，如回车、换行、退格、制表符等。在 C 中，使用**转义字符**来表示这些字符。

| **转义字符** | **含义**                               | **转义字符** | **含义**               |
| ------------ | -------------------------------------- | ------------ | ---------------------- |
| \a           | 蜂鸣                                   | \b           | 退格                   |
| \n           | 换行                                   | \r           | 回车                   |
| \t           | 水平制表符                             | \v           | 垂直制表符             |
| \\           | 反斜杠 \                               | \'           | 单引号 '               |
| \"           | 双引号 "                               | \?           | 问号 ?                 |
| \0oo         | o 表示一个八进制数字（可以省去前缀 0） | \xhh         | h 表示一个十六进制数字 |

这些转义字符不一定适用于所有设备，有些符号可能没有任何作用。

## 整数类型

整数类型包括 char、short、int、long 和 long long。C99 提供了一个可选名字集合，以确切的描述有关信息，使用头文件 `inttypes.h` 可以使用诸如 `unint32_t`、`int8_t` 等**确切长度类型**，但是它在某些系统上可能不支持。可以使用此头文件中定义的**最小长度类型**，保证所表示的类型至少大于指定长度的最小类型，如 `int_least8_t`。还定义了一组可以使计算达到最快的类型，称为**最快最小长度类型**，如 `int_fast8_t` 为系统中对 8 位有符号数而言计算最快的类型的别名。此外还有一组系统最大可能的整数类型，如 `intmax_t` 为最大有符号整数，它可能比 long 或 long long 还大。

对于无符号整数，当一个数超过它所能表示的最大值时，会溢出到起始点。而对于有符号数，C 没有标准定义，但计算机通常使用**补码**来表示有符号数。

## 布尔类型

布尔类型由 C99 引入，关键字为 `_Bool`，用于表示布尔值，即逻辑值**真**和**假**，C 用整数 1 表示真，用整数 0 表示假，所以 _Bool 类型也是一种无符号整数类型。在 C 中，任何非零值都被视作真值。

可以使用头文件 `stdbool.h` 来用 `bool` 替代 _Bool，用 `true` 和 `false` 来替代 1 和 0。

## 浮点类型

C 标准规定，float 必须至少有 6 位有效数字，double 必须至少有 10 位有效数字（通常有 15 位）。系统通常使用 32 位存储一个单精度浮点数，其中 8 位用于表示指数和符号，24 位用于表示有效数字。double 使用 64 位存储，在一些系统上，多出来的 32 位全部用于尾数部分，这将增加它的精度，在另一些系统上，将部分位分配给指数部分，以容纳更大的数，每种分配方法都至少保证数值具有 13 位有效数字。

对于浮点数来说，当计算结果是一个大得不能表示的数时，会发生**上溢**，此时会得到一个代表无穷大的特殊值 `INF`。还有一种特殊浮点值 `NaN`，如 `asin()`，其接收一个正弦值作为参数，但正弦值不能大于 1，如果参数不正确，将返回 NaN 值。

当除以一个十分小的数（指数部分已经到达最小）时，再把这个数除以 10，则计算机只能将尾数部分的位进行**逻辑右移**，如一个有 4 位有效数字 `0.1234e-37 / 10 = 0.0123e-37`，这称为**下溢**，但并不适用于所有系统。

由于浮点数不能精确表示某个数，所有可能会出现一些意想不到的情况，如浮点数 7.0 在内部可能存储为 `6.99999`，`2.0e20 + 1 - 2.0e20` 的结果并不等于 1。

## 其它类型

在 C99 中还增加了**复数**和**虚数**类型，复数类型有 3 种，分别是 `float_Complex`，`double_Complex`，`long double_Complex`。它包含两个值，一个表示复数的实部，一个表示复数的虚部。虚数类型也有 3 种，分别是 `float_Imaginary`，`double_Imaginary`，`long double_Imaginary`。

可以使用头文件 `complex.h` 来使用 `complex` 替代 `_Complex`，用 `imaginary` 替代 `_Imaginary`，使用符号 `I` 表示 -1 的平方根。

## 常量和预处理器

可以使用**预处理器**创建一个常量：

```c
#define PI 3.14
```

预处理器通常放在程序开头，这样在程序中就可以使用 PI 来替代 3.14 了，这样定义的常量被称为**符号常量**，这仅仅是一个替换机制，在程序编译之前的预处理过程中，所有使用 PI 的的地方会被 3.14 所替代。

在 C99 中还可以使用关键字 `const` 来定义常量：

```c
const double PI = 3.14;
```

使用 #define 和 const 定义的常量并不完全具有相同的性质。#define 是替换机制，可以使用如 `#define CHAR abc` 的形式，而使用 `const double CHAR = abc;`，编译器会报错。实际上 const 定义的是变量，但它是只读的，可以当常量来使用。在定义常量时，通常使用大写字母。

头文件 `limits.h` 和 `float.h` 分别提供了有关整型和浮点型的大小限制信息，定义了一系列的符号常量。

### limits.h 定义

| **常量**  | **含义**                    | **常量**   | **含义**                        |
| --------- | --------------------------- | ---------- | ------------------------------- |
| CHAR_BIT  | char 类型的位数             | CHAR_MAX   | char 类型的最大值               |
| CHAR_MIN  | char 类型的最小值           | UCHAR_MAX  | unsigned char 类型的最大值      |
| SHRT_MAX  | short 类型的最大值          | SHRT_MIN   | short 类型的最小值              |
| USHRT_MAX | unsigned short 类型的最大值 | INT_MAX    | int 类型的最大值                |
| INT_MIN   | int 类型的最小值            | UINT_MAX   | unsigned int 类型的最大值       |
| LONG_MAX  | long 类型的最大值           | LONG_MIN   | long 类型的最小值               |
| ULONG_MAX | unsigned long 类型的最大值  | LLONG_MAX  | long long 类型的最大值          |
| LLONG_MIN | long long 类型的最小值      | ULLONG_MAX | unsigned long long 类型的最大值 |

### float.h 定义

| **常量**       | **含义**                               | **常量**       | **含义**                  |
| -------------- | -------------------------------------- | -------------- | ------------------------- |
| FLT_MANT_DIG   | ﬂoat 类型的尾数位数                    | FLT_DIG        | ﬂoat 类型最少有效数字位数 |
| FLT_MIN_10_EXP | ﬂoat 类型负指数的最小值                | FLT_MAX_10_EXP | ﬂoat 类型正指数的最大值   |
| FLT_MIN        | ﬂoat 类型正数的最小值                  | FLT_MAX        | ﬂoat 类型正数的最大值     |
| FLT_EPSILON    | 比 1.00 大的最小 ﬂoat 类型值之间的差值 |                |                           |

把 `FLT` 替换为 `DBL` 和 `LDBL` 就变成了 double 和 long double 相对应的值。

# 3 表达式和语句

## 基本运算符

C 使用**运算符**表示算术运算，基本运算符有 `+`、`-`、`*`、`/` 和 `=`，运算符所操作的数据对象被称为**操作数**。

操作数可以为数值、变量或表达式，操作数也可以为多个。此外，加减运算符还可以用作正负运算符，一个正负运算符只能有一个操作数。

除法运算的**除数**不能为 0，只有操作数都为整数，结果才为整数。若操作数中既有整数又有浮点数，那么编译器会先把整数转化为浮点数再进行计算，得到的结果为浮点数。

如果操作数都为整数，但是做除法时不能整除，那么结果为去掉小数部分后所得到的结果，而不是四舍五入，这一过程被称为**截断**。

## 其它运算符

### 关系运算符

将表达式之间作比较的运算符称为**关系运算符**，由关系运算符所构成的表达式称为**关系表达式**。

| **运算符** | **含义** |
| ---------- | -------- |
| <          | 小于     |
| <=         | 小于等于 |
| >          | 大于     |
| >=         | 大于等于 |
| ==         | 等于     |
| !=         | 不等于   |

注意等于运算符 `==` 和赋值运算符 `=` 完全不同，赋值运算符是把右值赋给左值，而等于运算符是判断两边的值是否相等。

关系表达式所得的结果只有两种，**真**或**假**，在 C 中即 1 或 0，实际上任何不等于 0 的值都为真值。如果表达式逻辑正确，则为真值，否则为假值。

### 逻辑运算符

将多个表达式组合起来得出关系结果的运算符称为逻辑运算符。

| **运算符** | **含义**     |
| ---------- | ------------ |
| &&         | 逻辑与（且） |
| \|\|       | 逻辑或       |
| !          | 逻辑非       |

对于逻辑运算符 `&&` 和 `||`，它们是按照**短路**的方式运算的：在一个完整表达式中，如果第一个操作数已经能够确定整个表达式的值，则后面的操作数都不会再进行运算。

```c
if(a && x / a)
```

如果 a 是 0，则后面的子表达式 `x / a` 则不会进行运算，避免了除数为 0 的情况。

### sizeof 运算符

`sizeof` 运算符以字节为单位返回运算对象的大小，运算对象可以是具体的数据对象或类型：

```c
int n = 0;
size_t intsize = sizeof(int);                                                               // 类型必须加上括号
printf("n = %d, size of int = %zd bytes, size of n = %zd bytes.\n", n, intsize, sizeof n);  // 数值可以不加括号
```

运行结果：

> n = 0, size of int = 4 bytes, size of n = 4 bytes.

C 标准规定，sizeof 返回 `size_t` 类型的值。这不是一种新类型，而是一种无符号整型的别名，在格式化输出时用 `%zd` 转换说明符来表示该类型，如果编译器不支持，则可用 `%lu` 或 `%u` 代替。

### 求模运算符

求模运算符 `%` 只用于整数运算，结果为左操作数除以右操作数所得的余数。对于负数的求模，C 标准规定，其结果的正负只取决于第一个操作数是否为正数，且和除法运算一样，第二个操作数不能为 0。


实际上，对于所有的求模运算 `a % b`，都可以用 `a - (a / b) * b` 来计算。

### 自增自减运算符

自增运算符 `++` 和自减运算符 `--` 都是使其操作数的值加 1 或减 1，但自增自减运算符**只能作用于单个变量**。在变量前面出现为**前缀模式**，在变量后面出现为**后缀模式**。两种模式的区别在于，前缀模式在使用变量之前改变值，后缀模式在使用变量之后改变值。

在一条语句中最好不要同时使用多个自增自减运算符，也最好不要在一个复杂的表达式中使用，因为不仅会导致代码的可读性降低，而且可能会发生一些问题。

```c
// 设以下两行 n 的初始值开始都为 3
n/2 + 5*(1 + n++);
printf("%d %d %d\n", n, n++, n*n++);
```


第 2 行看上去没有问题，先计算 n ÷ 2，值为 1，再计算 5 × (1 + n++)，值为 20，然后 n 的值加 1，再合并，最终结果为 21。但编译器不一定会按照这个顺序，有可能先计算 5 * (1 + n++) ，值为 20，然后 n 的值加 1 变为 4，得到的值再计算 n ÷ 2，值为 2，最终结果为 22，这样一来由于 n 先自增了，再计算 n ÷ 2 就会得到不同的结果。

编译器会根据当前机器和系统，来自行选择效率最高的运算方式，C 标准并未规定编译器一定要按照某种方式运算，这种行为是**未定义**的，所以结果是不确定的，编译器只保证在执行完一条语句后能够确定 n 的值。

### 复合运算符

复合运算符就是把赋值运算符和其它的一些运算符相结合来形成的一种更加简洁的一种表达方式。

```c
n += 1;         // 等同于 n = n + 1
n *= n + m - l; // 等同于 n = n * (n + m - l)
```

### 逗号运算符

逗号运算符，把多个表达式连接成一个逗号表达式，并保证最左边的表达式最先被求值，整个逗号表达式的值为最右侧表达式的值。

```c
x = (y = 3, z = ++y);   // 先计算 y = 3，再计算 z = y++，最后 x = z
n = (300, 500);         // n = 500
n = 300, 500;           // n = 300
```

逗号运算符也可以做分隔符，这时它就不是逗号运算符了，如 printf 函数中的就是分隔符，编译器对其中的参数并不一定是按照从左往右的顺序来计算的。

### 强制转换类型运算符

C 中有时候会对数据类型进行自动转换，有时候数据之间在进行运算时由于类型不匹配会导致许多问题。要精确的进行类型转换，可以使用强制类型转换运算符，格式为在需要转换的数据前面使用 `(type)`，其中 type 为要进行转换的类型。

```c
(int)3.3;
(float)6.0;
```

强制类型可能会损失精度或者会使数据溢出。如把 double 转换为 ﬂoat，由于 double 的有效数字位数比 ﬂoat 多， 转换成 ﬂoat 可能会损失精度；而浮点数转换为整数，由于浮点数表示的范围比整数大得多，可能会导致整数溢出从而得到错误的结果。由浮点数转换为整数时，其小数部分会进行截断而不是四舍五入。

## 优先级和结合性

如果一个表达式中有多个运算符，那么就会根据其优先级来进行计算。根据运算符所操作对象的的数目分为**一元**、**二元**、**三元**运算符，如正运算符只有一个操作数，为一元运算符，加法运算符有两个操作数，为二元运算符，条件运算符有三个操作数，为三元运算符。

运算符具有优先级和结合性，优先级越高，越先得到计算。在优先级上，**一元 > 二元 > 三元，简单运算符 > 复合运算符，算术运算符 > 关系运算符 > 位运算符 > 逻辑运算符**，如果想让某个优先级较低的表达式得到优先计算，只需要在表达式两边加上括号即可。

结合性表示在相同优先级的情况下，表达式计算的顺序，但仅限于共用操作数的情况下。

```c
6 * 20 + 5 * 20;
12 / 3 * 2;
```

第 1 行由于乘法的优先级比加法高，所以先计算乘法，但是 C 并没有规定到底是先计算 6 × 20 还是先计算 5 × 20 ，但是无论哪种，都不影响最终结果。

第 2 行由于乘法和除法的优先级相同，而操作数 3 是它们共用的，这时就按照从左到右的结合性，先计算 12 ÷ 3 ，得到的结果为 4，再计算 4 × 2 ，得到的结果为 8；如果先计算 3 × 2 ，得到的结果为 6，再进行 12 ÷ 6 ，得到的结果为 2，那么最终结果就不一致了。

### 部分优先级和结合性表

| 运算符（优先级从高到底）                                     | 结合性       |
| ------------------------------------------------------------ | ------------ |
| `[]`（数组下标）、`()`（表达式、函数）、`.`、`->`            | 从左到右     |
| `++`、`--`、`+`（正）、`-`（负）、`!`、`~`、`sizeof`、`*`（取值）、`&`（取地址）、`(type)` | **从右到左** |
| `*`（乘）、`/`、`%`                                          | 从左到右     |
| `+`（加）、`-`（减）                                         | 从左到右     |
| `<<`、`>>`                                                   | 从左到右     |
| `<`、`<=`、`>`、`>=`                                         | 从左到右     |
| `!=`、`==`                                                   | 从左到右     |
| `&`（按位与）                                                | 从左到右     |
| `^`（按位异或）                                              | 从左到右     |
| `|`（按位或）                                                | 从左到右     |
| `&&`（逻辑与）                                               | 从左到右     |
| `||`（逻辑或）                                               | 从左到右     |
| `?:`（条件运算符）                                           | **从右到左** |
| `*=`、`/=`、`%=`、`+=`、`-=`、`<<=`、`>>=`、`&=`、`^=`、`|=` | **从右到左** |
| `,`（逗号运算符）                                            | 从左到右     |


## 表达式和语句

### 表达式概念

表达式由运算符和操作数组成。

```c
4
2 + 8
b = 10 / 2
a + b / c
i > 3
```

特别注意以上表达式结尾没有 `;` 号。表达式可以是常量和变量的组合。一些表达式由**子表达式**组成，如第 4 行 `a + b / c` 中的子表达式为 `b = 10 / 2`。

**表达式最重要的特性是每个表达式都有一个值**，这个值根据操作数和运算符按照相应的规则来产生。

```c
c = 3 + 8
6 + (c = 2 - 1)
```

第 2 行也是一个合法的表达式，因为它的子表达式 `c = 2 - 1` 会产生一个值 1，这个值和前面的 `6 +` 形成的新的表达式也会产生一个值 7。

### 语句概念

语句是 C 程序的基本模块，一条语句相当于一条完整的计算机指令，**语句会改变值或调用函数**。所有以 `;` 结尾的都是语句，但并不是所有语句都以此结尾，如声明和控制语句。表达式不是语句，但在表达式后面加上分号则变成了**表达式语句**。表达式语句和语句是两个不同的概念，比如 if 就是一条语句，但由于不是表达式，所以不能称之为表达式语句。在 C 中，赋值和函数调用都是表达式，而不是语句，两者实际上只能被称为表达式语句。

```c
3 + 4               // 表达式
3 + 4;              // 表达式语句
;                   // 空语句
x = 6 + (y = 5);    // 表达式语句
int num;            // 声明（不是语句）
printf("OK!\n");    // 函数调用（表达式语句）
if(x > 2)           // 控制语句
    i = i + 1;      // 表达式语句
```

第 4 行是一条表达式语句，其中子表达式y = 5 是一条完整的指令，但它仅仅是语句中的一部分。

第 5 行是一条声明，C 标准规定，声明不是语句。如果把; 去掉，它也不是一条表达式，虽然创建了标识符和类型， 并为其分配了内存，但没有产生值，所以不是表达式。

### 数据对象、左值和右值

赋值语句的目的是把值存储到某个数据对象上，而数据对象（如变量）又代表存储区域的某个位置，所以赋值运算实际上是把值放到某个存储区域中，用于存储值的存储区域被称为**数据对象**。数据对象的名称或表达式被称为**左值**，左值并不一定能被修改，如使用 const 关键字创建的变量，由于它是只读的，虽然它也属于数据对象，但并不能被修改。对于赋值运算符而言，它的左值应该是可修改的。右值指能赋给可修改的左值的量，可以是常量、变量或可以**产生值**的表达式。


### 复合语句

有许多种语句，如赋值语句把值赋给一个变量，它改变了值；函数引起函数的执行，也改变了值。对于一个用大括号括起来的函数，如 main 函数，它包含了多个语句，称为**复合语句**，也叫做**代码块**。复合语句用一对大括号括起来以限定范围。结构化语句如 if，它也包含了一个代码块。

### 副作用和序列点

**副作用**表示对数据对象的修改。

```c
num = 50;   // 副作用是将 num 的值变为 50
```

**序列点**是程序执行的一个点，在该点处，所有的副作用都在进入下一步前被发生。在 C 中，语句的分号标识了一个序列点。任何一个完整表达式的结束也是一个序列点，完整表达式即其本身不是另一个更大的表达式的子表达式，如表达式语句和 if 中的条件表达式都为完整表达式。

```c
a = b + c;
if(i++ > 10)
```


第 1 行的分号都标识了一个序列点，所以按照顺序执行。if 里的是一个完整的表达式，也是一个序列点，所以在执行大括号中的语句之前，i 的值会被加 1。

```c
printf(“%d, %d\n”, a, a * a++);
y = (4 + x++) + (6 + x++);
```

第 1 行，序列点是 printf 函数后的分号，但是括号内的参数并没有标记序列点，所以编译器可以选择计算参数的顺序，结果是不定的，只能保证在这条语句执行后 a 的值增加 1。

第 2 行，表达式 `(4 + x++)` 不是一个完整表达式，所以 C 无法保证 x 在子表达式 `(4 + x++)` 求值后立即加 1，其结果有多种可能，只能保证在执行下一条语句之前，x 自增两次。对于一个变量，不要在同一个表达式里多次使用自增自减运算符。

```c
// 不要这样使用
++i + i++;
j-- + ++j;
```

# 4 流程控制

## 分支

### if 语句

if 语句通过判断表达式的真假来执行下面的流程，可以嵌套多层 if 语句。

```c
if (表达式 1)
{
    语句
}
else if (表达式 2)
{
    if (表达式 3)
    {
        语句
    }
    else
    {
        语句
    }     
}
else
{
    语句
}
```

如果 if 语句部分只有一条语句，则可以不用加上大括号。

### 条件运算符

C 提供**条件表达式**作为表达 if else 语句的一种便捷方式，使用条件运算符 `?:` 来表示，其通用形式如下：

```c
表达式 1 ? 表达式 2 : 表达式 3
```

如果表达式 1 的值为真，则整个条件表达式的值为表达式 2，否则为表达式 3。

```c
if (a > b)
    printf("%d\n", a);
else
    printf("%d\n", b);
```

以上代码用条件表达式可以表示为：

```c
printf("%d\n", a > b ? a : b);
```

### switch 语句

对于某些选择分支，使用 switch 语句更为方便，其通用形式如下：

```c
switch (整型表达式)
{
case 常量 1:
    语句 1
case 常量 2:
    语句 2
    // ...
case 常量 n:
    语句 n
default:
    语句 default
}
```

switch 语句首先对**整型表达式**求值，然后逐一扫描标签 `case`，直到发现一个匹配项然后跳转至该行。如果没有匹配项，且含有 `default` 标签，则会跳转至该行，如果没有此标签，则什么都不执行。

和 if 语句不同的是，switch 语句的判断条件只能是整型表达式，其 case 标签也只能使用整型**常量**或**常量表达式**。除了第 1 个标签外，其余的都是可选项。

switch 语句的执行关键在于跳转，而不是选择。如果匹配，则会跳转至该标签，然后一直顺序执行。如果此标签下面还有标签，则 switch 会一直不断执行，直到全部执行完毕为止。如果只想执行对应标签，则需要使用 `break` 语句：

```c
switch (ch)
{
case 'a':
    ch++;
case 'b':
    ch += 2;
    break;
case 'c':
    ch += 3;
    break;
default:
    ch += 5;
}
```

以上代码如果 ch 的值为字符 `a`，则会选择第 1 个标签，ch 的值加 2，但是这里并没有使用 break 语句，所以会接着执行下个标签中的 `ch += 2` 语句，于是 ch 的值又被加了 2。由于第 2 个标签含有 break 语句，所以会直接跳出 switch 语句，不再执行下面标签的语句。

## 循环

### while 语句

while 语句的通用形式如下：

```c
while (表达式)
{
    语句
}
```

如果表达式的值为真，则执行语句部分一次，然后再次判断表达式是否为真。在表达式的值为假之前，循环的判断和语句的执行一直重复进行，每次循环都被称为一次**迭代**，代码块部分被称为**循环体**。循环语句需要有终止条件，如果表达式的值始终为真，则会陷入**无限循环**。

### for 语句

在使用循环时，通常会遵循**初始化、判断表达式、执行循环体、更新**四个步骤，用 while 语句表示出来即：

```c
n = 1;                  // 初始化
while (n < 10)          // 判断表达式
{                       // 执行循环体
    printf("%d\n", n);
    n++;                // 更新
}
```

而 for 语句则是把这四者合一，从而写出更加简洁明朗的程序，而且在效率上也比 while 语句和 do while 语句更加高效。

for 语句的通用形式如下：

```c
for (初始化; 判断; 更新)
{
    语句
}
```

for 语句使用 3 个表达式控制循环过程，分别用分号隔开。初始化表达式在执行 for 语句之前只执行一次，然后判断表达式，如果为真，则执行循环体一次，接着更新表达式，然后再判断表达式。

以上程序用 for 语句可以写为：

```c
for (n = 1; n < 10; n++)
    printf("%d\n", n);
```

可以省略一个或多个表达式，但不能省略分号：

```c
for (;;)        // 全部省略
for (n = 1;;)   // 省略第 2、3 个表达式
for (; n < 3;)  // 省略第 1、3 个表达式
```

如果省略了第二个表达式，则**默认为真值**。

### do while 语句

while 语句和 for 语句都是入口条件循环，即在循环的每次迭代之前检查表达式，所以有可能根本不执行循环体中的内容，而 do while 语句为出口条件循环，即在循环的每次迭代之后检查表达式，这保证了至少执行循环体一次。do while 语句的通用形式如下：

```c
do
{
    语句
} while (表达式);
```

do while 语句会首先执行循环体一次，然后判断表达式，若为真，则再次迭代一次，否则结束循环。这里需要注意的是，**do while** **语句的** **while** **后需要加一个分号**。

### 选择循环方式

首先确定是入口循环还是出口循环，如果是出口循环，则选择 do while 语句。如果选择入口循环，涉及初始化和更新时，用 for 语句比较好，而一些简单的循环方式则用 while 语句。实际上 while 语句和 do while 语句能做的，for 语句都能做，且在效率上更加高效。

### 嵌套循环

在使用循环的时候可以嵌套，即一个循环包含另一个循环。嵌套循环通常用来处理多行多列的问题，如打印乘法口诀表：

```c
for (i = 1; i <= 9; i++)
{
    for (j = 1; j <= i; j++)
        printf("%d*%d=%d\t", j, i, i * j);
    printf("\n");
}
```
运行结果：

>   1\*1=1
>   1\*2=2   2\*2=4
>   1\*3=3   2\*3=6   3\*3=9
>   1\*4=4   2\*4=8   3\*4=12  4\*4=16
>   1\*5=5   2\*5=10  3\*5=15  4\*5=20  5\*5=25
>   1\*6=6   2\*6=12  3\*6=18  4\*6=24  5\*6=30  6\*6=36
>   1\*7=7   2\*7=14  3\*7=21  4\*7=28  5\*7=35  6\*7=42  7\*7=49
>   1\*8=8   2\*8=16  3\*8=24  4\*8=32  5\*8=40  6\*8=48  7\*8=56  8\*8=64
>   1\*9=9   2\*9=18  3\*9=27  4\*9=36  5\*9=45  6\*9=54  7\*9=63  8\*9=72  9\*9=81

第 1 行的 for 语句为**外层循环**，第 3 行的 for 语句为**内层循环**。注意第 5 行的 printf 函数并不属于内层循环的循环体。

### 循环的另类使用方式

不管是 while 语句、do while 语句还是 for 语句，其括号中的内容本质是表达式，既然是表达式，则不会仅仅有着诸如初始化、更新等最基础的操作，实际上它可以是任何一种合法的表达式：

```c
while (scanf("%d", &i) == 1)
for (i = 1, printf("OK!"); i < 10; scanf("%d", &i))
```

### continue 和 break

一般来说，在进入循环后，执行完循环体中所有语句之前都不会跳出循环，如果想要忽略一部分语句，提前结束循环，可以使用 `continue` 和 `break` 语句。

三种循环都可以使用这两种语句，使用 continue 时，会跳过本次迭代剩余部分，直接开始下一次迭代，对于 for 语句来说，执行 continue 语句后，会先执行更新部分，然后开始判断表达式。

使用 break 时，会直接跳出循环，不再执行本次迭代剩余部分。对于 do while 语句和 for 来说，前者最后的判断部分会直接跳过，后者连更新部分也会直接跳过。

这两种语句都只会跳过当前循环语句，也就是说，如果该循环处在一个循环嵌套中，则只会影响内层循环，不会影响到外层循环。

## 跳转

### goto 语句

goto 语句实际上并不是 C 所十分依赖的，且最好不要滥用 goto 语句，虽然 goto 语句很强大，但它十分容易导致代码结构变得混乱。在 C 中，能够使用 if 语句或 switch 语句时，尽量不要用 goto 语句。其通用形式为：

```c
goto 标签
// ...
标签: 语句
```

执行 goto 语句后，程序会直接跳转到标签所在行。

之后会直接从此处开始执行程序。

实际上，break 语句和 continue 语句都是 goto 语句的特殊形式。通常使用 goto 从一组出现问题的循环中跳出：

```c
while (表达式)
{
    // ...
    while (表达式)
    {
        // ...
        if (出现问题)
            goto help;
    }
}
help : 语句
```

跳转可以往后跳，也可以往前跳。

# 5 函数

## 函数概述

函数是用于完成特定任务的独立程序代码单元，免于编写重复代码，在使用某一特定功能时，调用函数即可。函数可以看作一个黑盒，不必关心其内部实现细节。

```c
void add(int, int);         // 声明函数原型

int main(void)
{
    int a = 2, b = 3;
    add(a, b);              // 把 a、b 当作参数传递给 add 函数
    return 0;
}

void add(int a, int b)      // 定义 add 函数
{
    printf("%d\n", a + b);  // 打印两个数相加的值
}
```

程序在三处位置使用了 add 标识符。

第 1 处，在程序第 1 行，声明了一个函数原型，目的是告诉编译器函数的类型，void 说明了函数的返回值类型，这里不返回任何值，即**空类型**，后面的圆括号有两个 int，声明了两个变量，表示接受由 main 函数传递过来的两个 int 型的参数。

第 2 处，在程序第 6 行，在 main 函数中调用了 add 函数，把输入的两个数传递给 add 函数，main 函数称为**调用函数**，add 函数称为**被调函数**。

第 3 处，在程序第 10 行，定义了 add 函数。在定义函数时，参数必须有标识符。功能是输出 a + b 的值，定义函数时后面不加分号，因为它不是一个语句。

**函数原型**告诉编译器函数的类型，**函数调用**表明在此处执行函数，**函数定义**指明了函数要做什么，这些信息称为函数的**签名**。

函数声明是声明一个函数的原型，其通用格式为：

```c
返回值类型 函数名字(参数类型);
```

多个参数用逗号隔开，每个参数前都必须声明类型，且参数为这个函数所私有，是局部变量，所以调用函数和被调函数即使用了相同的变量名，也互不影响。函数原型中的参数为**形式参数**，仅仅是告诉编译器该函数参数的类型，并不会为其分配空间，在**声明函数原型时可以省略变量标识符**。

在定义函数时也支持 ANSI C 以前的形式：

```c
void functoin(a, b)
int a, b;
{
    // ...
}
```

若是声明多个类型相同的参数可以用这种方法。若是不带任何参数，则在括号里加上 void，也可以使用旧的函数声明，即一个空圆括号。函数定义中的参数为**实际参数**，编译器会为其分配空间。

若需要 add 函数返回一个值：

```c
int add(int a, int b)
{
    return a + b;
}
```

add 函数回返回一个 int 型的值给 main 函数，return 语句有终止函数的作用：

 ```c
int judge(int a, int b); // 函数声明
int judge(int a, int b)  // 函数定义
{
    if (a > b)
        return a;
    else
        return b;
    printf("End\n");
}
 ```

这里的 printf 函数用永远不会被执行，因为在执行 printf 函数之前，必定会遇到 return 语句，则会终止函数的执行，并把控制交给 main 函数。

声明函数时必须声明函数类型，有返回值的函数其类型必须与返回值类型相同，没有返回值即为 void 类型。以下两种声明方式都是可以的：

```c
/* 放在main函数之前 */
void add(int a, int b); // 函数声明
int main(void)
{
    int a, b;
    // ...
    add(a, b);          // 函数调用
    // ...
}
void add(int a, int b) // 函数定义
{
    // ...
}
```

函数声明和函数定义是不同的，必须在使用函数之前进行函数声明，以告知编译器这个函数的信息，这样当在程序中调用函数时，编译器就知道如何处理。而函数定义是函数功能的具体实现，如 math.h 头文件中有 sqrt 函数的声明，但是其定义却在另一个库函数文件中。

**如果把函数定义放在使用之前，也可以不声明。**

## ANSI C 函数原型

ANSI C 之前的函数原型：

```c
int function();
```

它告知了函数返回值的类型，但是并没有说明函数参数的类型与个数，如果使用了错误的参数类型和个数，编译器将不会发现这种错误。

```c
int add();              // 不确切的函数声明

int main(void)
{
    // ...
    add(a, b);          // 接受两个参数
}

int add(int a, int b)
{
    return a + b;
}
```

这里的函数声明部分并没有明确说明参数类型和个数，就算在定义函数时说明了参数类型及个数，编译器也不会检查实际传递参数时的正确性。

调用函数把要传递的参数放在内存中一个叫做**栈**的临时存储区域中，然后被调函数从栈中读取这些参数，但是这两个过程并没有协调进行，调用函数根据实际传递的参数确定其类型和个数，但是被调函数根据其形式参数确定其类型和个数。

若是传递的参数类型不正确，如对 add 函数只传递一个浮点类型的参数：

```c
add(12.5, 30);
```

由于没有声明参数类型，所以调用函数根据实际传递参数确定其类型。这里第一个为浮点数，自动转换为 double 类型，占用 8 个字节；第二个为 int 型，占用 4 个字节。而被调函数读取时根据其定义类型来读取，即读取两个 int 型数值，首先读取 4 个字节，为 double 值的前 4 个字节，然后再读取 4 个字节，为 double 值的后 4 个字节，那么栈就会出问题，结果不可知。

若是传递的参数个数不正确，如只传递一个参数：

```c
add(30);
```

这里只有一个参数，所以先读取 4 个字节，再往后读取 4 个字节，栈也会出问题，结果也是不可知的。

所以我们需要在声明函数时正确声明其形式参数的类型，如果有一个参数类型不匹配的情况，编译器会自动转换为相匹配的类型。**但是有一个例外**，就是在使用之前就已经定义了函数，这种情况也不会发生。

一个程序中的每个 C 函数和其它函数之间是平等的，每一个函数都可以调用其它函数，或者被其它任何一个函数调用（包括 main 函数）。

## 递归

C 允许函数调用它自己（包括 main 函数），这个过程称为**递归**，递归一般可以代替循环语句使用，但效率没有循环语句高。

设有以下代码：

```c
void recursion_function(int);

int main(void)
{
    recursion_function(1);
    return 0;
}

void recursion_function(int n)
{
    printf("Level %d, n location = %p\n", n, &n);
    if (n < 4)
        recursion_function(n + 1);
    printf("Level %d, n location = %p\n", n, &n);
}
```

运行结果：

>   Level 1, n location = 000000000061FE00
>
>   Level 2, n location = 000000000061FDD0
>
>   Level 3, n location = 000000000061FDA0
>
>   Level 4, n location = 000000000061FD70
>
>   Level 4, n location = 000000000061FD70
>
>   Level 3, n location = 000000000061FDA0
>
>   Level 2, n location = 000000000061FDD0
>
>   Level 1, n location = 000000000061FE00

通过分析可以知道递归的基本原理。

第一，每一级函数调用都有自己的变量（即使它们名字一样），但这几个变量是独立的，我们从执行结果看出，每一级变量的值和内存中的地址都不一样。

第二，每一次函数调用都有一次返回，当程序到递归的结尾时，它会转移到上一级继续执行，程序不能直接返回第一个调用函数，只能每一级逐级返回。

第三，在递归中，位于递归调用前的语句被顺序执行，递归返回时反序执行，当最后一次递归完成后，从最后一次递归后的 printf 函数开始执行。

第四，递归函数必须包含终止递归的程序，否则将会一直递归下去。

递归调用语句放在 return 语句之前的递归叫做**尾递归**，相当于一个循环语句：

```c
void re_fu(int n)
{
    if (n > 0)
        return re_fu(n - 1);
    else
        return 0;
}
```

虽然这里的调用不是在函数中的最后一行，但它是在 n > 0 的情况下执行的最后一条语句，所以也算尾递归。

因为递归函数的每一级都拥有自己独立的变量，所以会占用较多的内存，且每次递归函数都会把参数放在栈中，所以执行效率和速度会下降，递归会占用较多的计算机资源。

递归效率虽然不高，且占用资源较多，但是在处理倒序问题时比循环更方便，如打印一个整数的二进制形式时：

```c
void to_binary(unsigned long n);

int main(void)
{
    unsigned long num = 255;
    to_binary(num);
    return 0;
}

void to_binary(unsigned long n)
{
    int r;
    r = n % 2;
    if (n >= 2)
        to_binary(n / 2);
    putchar(r == 0 ? '0' : '1');
    return 0;
}
```

运行结果：

>   11111111

又如计算斐波那契数列的函数可以这样定义：

```c
unsigned long fibonacci(unsigned n)
{
    if (n > 2)
        return fibonacci(n - 1) + fibonacci(n - 2);
    else
        return 1;
}

```

## 使用头文件

如果把 main 函数放在一个文件中，而把自定义函数放在另一个文件中，那么在 main 函数中使用自定义函数前仍需要声明原型，而如果把函数声明放在一个头文件中，就不必每次使用这些函数时都声明一次。又如定义常量时，如果把这个常量放在一个文件中，如果另一个文件想要使用这个常量，那么就需要在另一个文件中同样定义这个常量，如果把这些常量统一放在一个头文件中，那么只用在需要使用的文件前加上 `#include` 指令。

```c
/* 文件 function.h */
#include <stdio.h>
#define NUM
void function(void);

/* 文件 main.c */
#include "function.h" // 自定义头文件用双引号扩起来，被包含的文件位于当前工作目录下
int main(void)
{
    //  ...
    function();
    // ...
    return 0;
}

/* 文件 function.c */
#include "function.h"
void function(void)
{
    // ...
}
```

以上三个文件放在一个项目里一起编译即可。

# 6 数组和指针

## 数组

数组由一系列类型相同的元素组成，在内存中**顺序存储**，属于派生类型，因为它是建立在其它类型之上的。数组声明包括数组元素的类型和数目：

```c
int ar[5]; // 声明一个包含 5 个 int 类型元素的数组
```

方括号 `[]` 表示 ar 是一个数组，其内的数字指明了数组所包含元素的数目，**且只能是整型常量或整型表达式**。要访问数组中的元素，可以使用**下标**来表示单个元素，从零开始计数，如 ar[0] 表示数组的第 1 个元素。

### 初始化

变量在声明时可以初始化，数组同样也可以，ANSI C 支持以下方式进行初始化：

```c
int ar[5] = {1, 2, 3, 4, 5}; // 花括号表示这是一个列表，数值之间以逗号隔开
```

在只需要检索数组值的时候，可以把数组声明为只读（常量数组）：

```c
const int ar[5] = {1, 2, 3, 4, 5}; // 声明时必须初始化，之后不能再修改
```

初始化列表中的元素数目应该和数组大小相同。若是小于数组大小，则其余元素会被默认初始化为 `0`（浮点数为 `0.0`，字符为 `'\0'`）；若大于数组大小，则报错。

若在声明时省略方括号中的数字，则必须初始化，编译器会根据初始化元素数目自动匹配数组大小。

#### 指定初始化器

C99 允许初始化指定元素，未经初始化的元素同上。此种方式初始化数组有两个特性：

第一，如果在一个指定初始化元素后跟有不只一个值：

```c
int ar[5] = { [2] = 3, 4, 5}; // 后续数值将用来对指定元素的后续元素初始化
```

第二，多次对同一个元素进行初始化，则最后一次有效：

```c
int ar[5] = {1, 2, 3, 4, [2] = 5, 6}; // ar[2] = 5，ar[3] = 6，ar[4] = 0
```

如果在指定初始化时未确定数组大小：

```c
int ar[] = {1, [3] = 6, 8}; // 实际元素个数为 5
```

那么编译器会把数组大小设置为足够装得下初始化的值。

### 给数组元素赋值

声明数组后（不管它是否初始化），之后都可以对它进行赋值（只读数组除外）。C 不支持把数组作为一个整体来进行赋值，也不支持用花括号（列表）的形式进行赋值（初始化除外），只能进行单个赋值：

```c
int ar[5];
int ar2[5] = {1, 2, 3, 4, 5};
ar = ar2;                       // 错误
ar[5] = {1, 2, 3, 4, 5};        // 错误
ar[5] = ar2[5];                 // 语法上没有错误，但下标越界
```

要注意的是，除了声明以外，下标的最大值为 `数组元素个数 - 1`，因为在使用数组时下标是从 `0` 开始的。

### 数组边界

使用数组时要注意下标不能超过数组的边界，因为编译器不会检查下标的合法性（为了使程序运行更快）。在 C 中使用越界下标的行为是未定义的，一旦使用了错误的下标，那么结果通常不可知，程序可能出错也可能得到一个垃圾值还可能改变其它在该程序中的变量的值：

```c
int value = 1, value2 = 2;
int ar[5] = {3, 4, 5, 6, 7};
ar[-1] = 10;
ar[5] = 20;
```

如果 value 在内存中的位置正好在元素 ar[0] 之前，那么 value 的值会被改变为 10，value2 也可能同样如此，还有可能什么都不发生。

## 多维数组

形如这样的数组：

```c
int ar[3][3]; // 声明一个二维数组
```

它表示由 3 个元素且每个元素由 3 个 int 型数值组成的数组的数组。如 ar[0] 是一个包含 3 个 int 数值的数组，ar[1] 也同样如此。ar\[n\][m] 可以理解为一个 n 行 m 列的一个矩阵。

### 二维数组的初始化

二维数的初始化建立在初始化一维数组的基础上：

```c
int ar[3][3] = {{1, 2}, {6, 7}}; // 行与行之间以逗号隔开
int ar[3][3] = {1, 2, 0, 6, 7};
```

上面这两行是等价的，未被初始化的元素会被默认初始化为 0。

若是超出了边界：

```c
int ar[3][3] = {{1, 2, 3, 4}, {8, 9, 10}}; // 错误
```

对二维数组指定初始化：

```c
// ar[0][0] = 1, ar[0][1] = 2, ar[2][0] = 5, ar[2][1] = 6
int ar[3][3] = {1, 2, [2] = 5, 6};
```

二维以上的数组对此同样适用：

```c
// ar[0][0][0] = 1, ar[0][0][1] = 2, ar[2][0][0] = 5, ar[2][1][0] = 8
int ar[3][3][3] = {1, 2, [2] = 5, [2][1] = 8};
```

## 变长数组

C99 新增了变长数组（VLA），它允许使用变量来定义数组的维度：

```c
int i = 3, j = 4;
int ar[i][j];
```

变长数组有一些限制：第一，必须是自动存储类别；第二，声明时不能初始化。

变长数组和普通数组一样，并不意味着它的维度可以随时改变，而是只要确定了维度，就不能再改变，作为维数的变量必须在数组声明之前：

```c
void fuction(int i, int j, int ar[i][j]); // 正确
void fuction(int ar[i][j], int i, int j); // 错误
```

声明函数时，形参名可以省略，但对于变长数组来说，必须在方括号中加 `*` 号：

```c
void fuction(int, int, int ar[*][*]); // 省略了形参名
```

C11 把变长数组作为一个可选特性，而不是强制实现的特性，目前完全支持这一特性的编译器不多。在 C99 / C11中，作为变长数组维数的变量可以用关键字 const 来声明：

```c
const int SIZE = 5;
int ar[SIZE];
```

而 C90 则未定义，对于不同的环境，可能允许或不允许。

## 指针

### 指针简介

指针是一种新的数据类型，其值为一个数据对象的地址，由无符号整数表示，但不能被看作整数。如 int 变量的值为整数，char 变量是一个数值为字符的变量（本质上也是 int），double 变量是一个数值为浮点数的变量，而指针表示数值的地址。

设指针变量 `pt`：

```c
pt = &a; // 把 a 的地址赋给 pt
```

对于这个语句，称 pt 指向 a，pt 是一个变量，而 &a 是一个常量，其值为 a 的地址，& 为**地址运算符**，用来获取变量的地址。

### 声明指针

声明指针前，需要明确指针所指向变量的类型，因为不同变量类型所占内存空间和在内存中的存储方式不同，如 int 在内存中占 4 个字节，short 在内存中占 2 个字节；又如 int 和 ﬂoat 都在内存中占 4 个字节，但是在内存中存储方式完全不同。

```c
int *pi;          // pi 是指向 int 指针
char *pc;         // pc 是指向 char指针
float *pf1, *pf2; // pf1 和 pf2 都是指向 float 的指针
```

类型标识符表明了被指向变量的类型，`*` 表示该变量为一个指针。

### 初始化

指针在声明后必须初始化，如果不进行初始化，那么它的值并不确定，以后在使用时，并不清楚到底对内存中哪个地址进行了操作，这种指针俗称**野指针**。

```c
int *pi; // 野指针
*pi = 5;
```

由于 pi 并没有初始化，所以它的初值是任意的，也就是说它随便指向内存中的某个位置，这时改变了这个地址的值，也就有可能改变内存中任意位置的值，可能覆盖一个本身存在的值，也可能导致程序出错。虽然编译器不会报错，但是在使用指针时务必立即初始化。

### 取值

可以用间接运算符 `*` 取出指针所指向地址的值：

```c
int i = 1;
int *pi = &i;
printf("pi = %p, *pi = %d\n", pi, *pi);
```

运行结果：

> pi = 000000000062FE14, *pi = 1

即：

>   pi = &i
>
>   *pi = *&i = i

这里的 `*` 与声明指针所用的 `*` 意义不同，在使用时它是间接运算符，而声明时它代表这个变量是一个指针，可以简单的看作把 `&` 和 `*` 放在一起时可以相互抵消。

### 指针和指针的地址

指针和指针的地址是两个概念。指针是一个指向某个内存空间的变量，其值是所指向内存空间的地址。而指针的地址表示指针本身这个变量在内存中的地址。

```c
int i = 1;
int *pi = &i;
printf("i = %d, &i = %p\n", i, &i);
printf("*pi = %d, pi = %p, &pi = %p\n", *pi, pi, &pi);
```

运行结果：

> i = 1, &i = 000000000062FE1C
>
> *pi = 1, pi = 000000000062FE1C, &pi = 000000000062FE10

### 指向指针的指针

指针可以指向指向任何类型，包括指针类型，声明一个指向指针的指针：

```c
int n = 5;
int m = 10;
int *p = &n;            // p 的值为 n 的地址，*p 为 n 的值
int **pp = &p;          // pp 的值为 p 的地址，*pp 为 p 的值，即 n 的地址，**pp 为 n 的值
printf("&n = %p, p = %p, &p = %p\n", &n, p, &p);
printf("pp = %p, *pp = %p, **p = %d\n", pp, *pp, **pp);
*pp = &m;               // 通过 pp 来改变 p 所指向的地址，此时 p 的值为 m 的地址
printf("&m = %p, p = %p, &p = %p\n", &m, p, &p);
printf("pp = %p, *pp = %p, **p = %d\n", pp, *pp, **pp);
```

运行结果：

> &n = 000000000062FE14, p = 000000000062FE14, &p = 000000000062FE08
>
> pp = 000000000062FE08, *pp = 000000000062FE14, **p = 5
>
> &m = 000000000062FE10, p = 000000000062FE10, &p = 000000000062FE08
>
> pp = 000000000062FE08, *pp = 000000000062FE10, **p = 10

### 函数和指针

函数中的变量为自己私有的，也就是说，被调函数不能直接影响调用函数中变量的值，但通过指针，可以获取调用函数中变量的地址来改变它的值，即使是两个毫不相干的函数。

```c
void swap(int *a, int *b);

int main(void)
{
    int a = 1, b = 2;
    printf("a = %d, b = %d\n", a, b);
    swap(&a, &b);
    printf("Now, a = %d, b = %d\n", a, b);
    return 0;
}

void swap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
```

运行结果：

> a = 1, b = 2

> Now, a = 2, b = 1

通过传递变量的地址而不是传递变量本身，来改变变量的数值，一个变量的地址在运行时是不会变化的，所以可以使用指针来改变变量的值。

其中函数接受的参数类型也改变了，通过加 `*` 号，使函数接受一个 int 变量的地址。

变量有两种属性：标识符和值。当程序被加载时，数据被加载到内存中，此时变量在计算机中的名字变为了地址。标识符是我们赋予变量的名字，而地址是计算机赋予变量的名字。

普通变量把它的数值作为基本数值量，通过 `&` 运算符来间接获取它的地址。对指针来说，地址是它的基本数值量，它的值需要通过 `*` 运算符来间接获取。两者不同的是，数值可以改变，地址不能改变。

### 数组和指针

数组实际上是一种变相使用指针的形式，指针能够有效处理数组：

```c
int ar[5] = {1, 2, 3};
```

数组名 ar 不仅是该数组的名字，还是该数组首元素 a[0] 的地址，即：

>   ar = &ar = &ar[0]

这三者都是该数组的首地址，且都为常量，不能更改其值，但是可以把它们赋给指针变量，修改指针变量的值。

```c
int *p = ar; // p 的值为数组 ar 的首地址
p++;         // 把 p 所指向的地址往下移动一个单位，即 ar[1] 的地址 &ar[1]
*p = 5;      // 取出 *p 的值，并改变值，即 ar[1] = 5
```

对一个指针加 1 的结果是对该指针增加 1 个存储单元（所指向类型的字节大小）。对数组而言，地址会增加到下一个元素的地址，而不是下一个字节。

可以用指针标识数组的每个元素，并得到其数值，即对同一个对象有两种不同的表示方法，如定义 ar[n] 时，意思是 `*(ar + n)`，即寻址到内存中的 ar，然后移动 n 个单位，再取出该单位所对应的数值。

```c
*(ar + i); // 该数组的第 i 个元素的值，等同于 ar[i]
*ar + i;   // 第 1 个元素的值和 i 相加，等同于 ar[0] + i
```

### 函数、数组和指针

若要一个函数（如 sum 函数返回该数组中所有元素之和）对数组进行操作：

```c
int ar[5] = {1, 2, 3, 4, 5};
int result = sum(ar, 5);
```

C 不支持把整个数组作为函数参数进行传递，但可以传递数组的地址。

这里的第一个参数把数组首地址和类型的信息传递给函数；第二个参数把数组中的元素个数传递给函数。

声明函数原型：

```c
int sum(int *ar, int n);
```

由于声明函数原型和函数定义时可以省略名称，并且数组名本质上是一个指针，则还可以使用这三种形式：

```c
int sum(int *, int);
int sum(int ar[], int n);
int sum(int [], int);
```

在这种情况下，C 对 `int ar[]` 和 `int *ar` 作出同样的解释，但另外一种情况就不同了：

```c
void size_of_ar(int ar[])
{
    printf("%zd\n", sizeof(ar));
}

int main(void)
{
    int ar[5];
    printf("%zd\n", sizeof(ar));
    size_of_ar(ar);
    return 0;
}
```

运行结果：

> 20
>
> 8

第 1 个 sizeof 返回数组 ar 的大小，int 为 4 个字节，那么大小就为 20。而 size_of_ar 函数获得的参数的值实际上是数组 ar 的首地址，传递过来的是一个指针，所以第 2 个 sizeof 返回的是这个指针的大小，在 64 位系统上大小为 8。

设 sum 函数有两个参数，一个是指向数组 ar 首地址的指针，一个是数组 ar 末地址的指针：

```c
int sum(int *st, int *end)
{
    while (st < end)
        result += *st++; // * 和 ++ 优先级相同，但从右至左结合
    return result;
}

int main(void)
{
    int ar[5] = {1, 2, 3, 4, 5};
    printf("sum = %d\n", sum(ar, ar + 5));
    return 0;
}
```

运行结果：

> sum = 15

传递给函数的第一个参数是数组 ar 的首地址，也就是 &ar[0]。第二个参数 ar + 5 等同于 &ar[5]，但数组 ar 最后一个元素的下标为 4，按理说下标越界了。实际上，虽然在 while 中结束循环的判定点在 &ar[5] 之前，但是 end 指向数组 ar 之后的地址类型并不一定是 int 型的，所以 C 保证在为数组分配存储空间的时候，指向数组后的第一个位置的指针也是合法的（仅仅是可以指向，但不能取值）。

### 指针操作

可以对指针进行操作，有以下几种方式：

-   **赋值**——可以把地址赋给一个指针，通常使用取地址运算符 &、数组名和另一个指针来进行。地址类型应该和指针类型兼容，如不能把一个 double 类型的地址赋给一个指向 int 的指针。

-   **解引用**——取值运算符 `*` 可取出指针指向地址中所存储的值。

-   **取地址**——可以用 `&` 得到存储该指针本身的地址。

-   **指针与整数相加**——可以使用 `+` 运算符把指针与整数相加，这个整数会和这个指针所指向类型的大小的字节数相乘，然后加到这个指针上。如果相加的结果超出了指针所指向地址的范围，则结果是未定义的。

-   **指针与整数相减**——可以使用 `-` 运算符把指针与整数相减，指针必须是第一个操作数，这个整数会和这个指针所指向类型的大小的字节数相乘，然后指针减去这个数。如果相减的结果超出了指针所指向地址的范围，则结果是未定义的。

-   **指针自增自减**——相当于相 / 加减的整数为 1，即把指针移至数组的下 / 上一个元素。

-   **指针求差**——计算两个指针间的差值，**有效指针差运算的前提是参加运算的两个指针是指向同一个数组**，以求出两个指针所指向元素的距离，单位是该类型大小。如果不是指向同一个数组，则结果是未定义的。

-   **指针比较**——使用关系运算符来比较两个指针的大小，前提是两个指针都指向相同的类型的对象。

```c
int ar[3] = {1, 2, 3};
int *p = ar;
int *p2 = &ar[2];
printf("p + 2 = %p\n", p + 2);       // 等同于 &ar[2]
printf("*(p + 2) = %d\n", *(p + 2)); // 等同于 ar[2]
printf("*(p + 3) = %d\n", *(p + 3)); // 等同于 ar[3]，下标越界，结果未定义
printf("p2 - p = %ld\n", p2 - p);    // ar[2] 和 ar[0] 相差了 2 个单位距离
```

运行结果：

> p + 2 = 000000000062FE08
>
> *(p + 2) = 3
>
> *(p + 3) = 0 （结果不确定）
>
> p2 - p = 2

C 并不检查指针是否仍然指向数组中的某个元素，只保证指向数组元素的指针和指向数组后的第一个地址的指针是有效的，但如果在指针在进行运算时超出了这个范围，那么结果将是未定义的，另外不可以对指向数组后第一个地址的指针进行取值运算，尽管这样的指针是合法的。

### 保护数组内容

是否需要传递给函数一个指针，取决于是否需要在函数内改变传递过来的值。但在传递一个数组时，只能使用指针传递，这时可以使用关键字 const 来保护数组内容不被改变：

```c
int sum(const int ar[], int n); // 函数原型
```


该指针指向一个 int 常量，它是一个指向常量的指针，于是该函数不能修改数组 ar 中的内容。

将常量或非常量赋给一个指向常量的指针是合法的，但是将常量赋给一个普通指针是非法的，这意味着可以使用普通的指针修改常量的值。指向常量的指针本身是一个变量，它自身可以改变。

```c
int a = 1, b = 2;
const int *p = &a; // p 的值可以改变，但不能改变 *p
p = &b;            // 正确
*p = 3;            // 错误
```

也可以声明一个常量指针，这意味着指针的值不能改变，但指针所指向地址的值可以改变：

```c
int a = 1, b = 2;
int *const p = &a; // p 的值不能改变，但可以改变 *p
p = &b;            // 错误
*p = 3;            // 正确
```

还可以声明一个指向常量的常量指针，这意味着既不能改变指针的值，也不能改变指针所指向地址的值，且必须初始化：

```c
int a = 1, b = 2;
const int *const p = &a; // p 和 *p 的值都不能改变
p = &b;                  // 错误
*p = 3;                  // 错误
```

一切都取决于 const 的位置和个数。

### 指针和多维数组

声明一个二维数组：

```c
int ar[5][5];
```

数组名 ar 是该数组的首地址，也就是该数组第一个元素的地址，即 &ar[0]，而第一个元素本身也是一个包含 5 个 int 型数值的数组，所以 ar[0] 既是数组 ar 的第一个元素，又是数组 ar[0] 的数组名，同时还是数组 ar[0] 的首地址，即 ar[0] = &ar\[0\][0]（可以把 ar[0] 当作一个数组的名字）。在数值上，ar = &ar[0] = ar[0] = &ar[0]

但这并不代表 ar 等同于 ar[0]，因为 ar 是指向一个包含 5 个 int 型的数组地址的指针，而 ar[0] 是指向一个 int 型地址的指针，两者的数值可能等同，但是类型不同。

```c
int ar[5][5] = {{1, 2, 3}, {6, 7, 8}};
*ar;              // 等同于 *&ar[0]       = ar[0]
**ar;             // 等同于 *ar[0]        = *&ar[0][0]   = ar[0][0]
ar + 1;           // 等同于 &ar[1]
*ar + 1;          // 等同于 ar[0] + 1     = ar[1]        = &ar[1][0]
**ar + 1;         // 等同于 *ar[0] + 1    = ar[0][0] + 1 = 2
*(ar + 1);        // 等同于 *(&ar[0] + 1) = *&ar[1]      = ar[1]      = &ar[1][0]
**(ar + 1);       // 等同于 **&ar[1]      = *ar[1]       = *&ar[1][0] = ar[1][0] = 6
*(ar + 1) + 1;    // 等同于 &ar[1][0] + 1 = &ar[1][1]
*(*(ar + 1) + 1); // 等同于 *&ar[1][1]    = 7
```

二维数组用指针表示的通用形式为：

>   ar\[n\][m] = \*(\*(ar + n) + m)

### 指向二维数组的指针

声明一个指向二维数组的指针：

```c
int ar[5][5];
int *p;      // 错误，但是可以指向 ar[m]，0 ≤ m ≤ 4
int *p[5];   // 错误，[] 的优先级高于 *，是一个包含 5 个指向 int 元素的指针数组
int (*p)[5]; // 正确，指向一个数组，数组的每个元素由 5 个 int 元素组成
```

### 处理二维数组的函数

声明一个处理二维数组的函数，其函数原型为：

```c
int ar[5][5];
void fuction(int (*p)[5]);
```

当且仅当 p 是函数的形式参数时，也可以这样声明：

```c
void fuction(int p[][5]); // 第一个方括号是空的，表示它是一个指针
```

声明 N 维数组的指针时，除了最左边的方括号可以留空之外，其它都需要填写：

```c
int ar[5][5][5];
void fuction(int p[][5][5]);
// 等同于
void fuction(int (*p)[5][5]);
```

### 指针的兼容性

指针之间的赋值规则更为严格，不用类型转换就可以把 int 型值赋给 double 型，但指针不可以。

```c
int n = 5;
double x;
int *pi = &n;
double *pd = &x;
x = n;   // 允许
pd = pi; // 错误
```

前面所说可以把一个常量或非常量数值赋给一个指向常量的指针，这有一个前提——**只进行一层间接运算**，在进行多层运算时，将不再安全：

```c
const int n = 1;
const int **pp;
int *p;
pp = &p;  // 这将导致 const 失效
*pp = &n; // p 的值被改变为 &n
*p = 2;   // 常量 n 的值被改变了
```

C 标准规定通过非 const 指针更改 const 数据的行为是未定义的。

## 复合字面量

C99 新增了复合字面量，字面量是除符号常量外的常量。如 3 是 int 型字面量，3.14 是 double 型字面量，'a' 是 char 型字面量，"abcdefg" 是字符串字面量。而表示数组内容和结构的字面量称为复合字面量。

定义复合字面量：

```c
int ar[3] = {1, 2, 3};             // 普通数组声明并初始化方法
(int[3]){1, 2, 3};                 // 复合字面量，它缺少了名字和赋值运算符
(int[]){1, 2, 3, 4, 5};            // 复合字面量也可以省略大小，编译器会自动计算
(int[2][3]){{1, 2, 3}, {4, 5, 6}}; // 复合字面量类型为 int[2][3]
```

复合字面量是匿名的，不能先创建后使用，必须在创建时同时使用它，可以使用指针记录字面量的地址：

```c
int *pt = (int [2]){1, 2};
int (*pt)[2] = (int [][2]){ {1, 2}, {3, 4}, {5, 6} };
```

还可以把复合字面量作为实际参数传递给函数：

```c
total = sum((int []){1, 2, 3, 4, 5}, 5);
```
